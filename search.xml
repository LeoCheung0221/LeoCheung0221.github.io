<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[网络工具篇 - 抓包(Fiddler)]]></title>
      <url>%2F2017%2F01%2F04%2F%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E7%AF%87-%E6%8A%93%E5%8C%85-Fiddler%2F</url>
      <content type="text"><![CDATA[序章Fiddler是一个很好用的抓包工具，可以将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作。也可以用来检测网络安全。这里搜集各大网络的资料，总结了常用的功能。 1. Fiddler 抓包简介Fiddler是通过改写HTTP代理，让数据从它那通过，来监控并且截取到数据。Fiddler在打开时，就设置好了浏览器的代理。当关闭的时候，又把代理还原了。 1） 字段说明Fiddler想要抓到数据包，要确保Capture Traffic是开启，在File –&gt; Capture Traffic。开启后在左下角会有显示，也可以直接点击左下角的图标来关闭/开启抓包功能。 Fiddler开始工作，抓到的数据包就会显示在列表里面，下面总结这些什么意思： 名称 含义 # 抓取HTTP Request的顺序,从1开始，以此递增 Result HTTP状态码 Protocol 请求使用的协议，如HTTP/HTTPS/FTP等 Host 请求地址的主机名 URL 请求资源的位置 Body 该请求的大小 Caching 请求的缓存过期时间或者缓存控制值 Content-Type 请求响应的类型 Process 发送此请求的进程：进程ID Comments 允许用户为此回话添加备注 Custom 允许用户设置自定义值 图标 含义 请求已经发往服务器 已从服务器下载响应结果 请求从断点处暂停 响应从断点处暂停 请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body） 请求使用 HTTP 的 POST 方法 请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道 响应是 HTML 格式 响应是一张图片 响应是脚本格式 响应是 CSS 格式 响应是 XML 格式 响应是 JSON 格式 响应是一个音频文件 响应是一个视频文件 响应是一个 SilverLight 响应是一个 FLASH 响应是一个字体 普通响应成功 响应是 HTTP/300、301、302、303 或 307 重定向 响应是 HTTP/304（无变更）：使用缓存文件 响应需要客户端证书验证 服务端错误 会话被客户端、Fiddler 或者服务端终止 2）. Statistics 请求的性能数据分析点击一个请求，可以看到Statistics关于HTTP请求的性能以及数据分析： 3）. Inspectors 查看数据内容Inspectors用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容： 4）. AutoResponder 允许拦截指定规则的请求AutoResponder允许你拦截指定规则的求情，并返回本地资源或Fiddler资源，从而代替服务器响应。看下图5步，将“baidu”这个关键字与我的电脑“F:\Users\YukiO\Pictures\boy.jpeg”这张图片绑定了，点击Save保存后勾选Enable rules，再访问baidu，就会被劫持。 1. 字符串匹配（默认）：只要包含指定字符串（不区分大小写），全部认为是匹配 字符串匹配（baidu） 是否匹配 http://www.baidu.com 匹配 http://pan.baidu.com 匹配 http://tieba.baidu.com 匹配 2. 正则表达式匹配：以“regex:”开头，使用正则表达式来匹配，这是区分大小写的 字符串匹配（regex:.+.(jpg / gif / bmp ) $） 是否匹配 http://bbs.fishc.com/Path1/query=foo.bmp&amp;bar 不匹配 http://bbs.fishc.com/Path1/query=example.gif 匹配 http://bbs.fishc.com/Path1/query=example.bmp 匹配 http://bbs.fishc.com/Path1/query=example.Gif 不匹配 5）. Composer 自定义请求发送服务器Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求；Parsed模式下你只需要提供简单的URLS地址即可（如下图，也可以在RequestBody定制一些属性，如模拟浏览器User-Agent） 6）. Filters 请求过滤规则Fiters 是过滤请求用的，左边的窗口不断的更新，当想看系统的请求的时候，刷新一下浏览器，一大片请求一直刷新屏幕。这时通过过滤规则来过滤掉不想看到的请求。 勾选左上角的Use Filters开启过滤器，这里有两个最常用的过滤条件：Zone和Host 1、Zone 指定只显示内网（Intranet）或互联网（Internet）的内容： 2、Host 指定显示某个域名下的会话： 7）. Timeline 请求响应时间在左侧会话窗口点击一个或多个（同时按下 Ctrl 键），Timeline 便会显示指定内容从服务端传输到客户端的时间： 2. Fiddler 设置解密HTTPS的网络数据Fiddler可以通过伪造CA证书来欺骗浏览器和服务器。Fiddler是个很会装逼的好东西，大概原理就是在浏览器面前Fiddler伪装成一个HTTPS服务器，而在真正的HTTPS服务器面前Fiddler又装成浏览器，从而实现解密HTTPS数据包的目的。解密HTTPS需要手动开启，依次点击： Tools –&gt; Fiddler Options –&gt; HTTPS 勾选Decrypt HTTPS Traffic 点击OK 3. Fiddler 抓取iPhone / Android数据包想要Fiddler抓取移动端设备的数据包，其实很简单，先来说说移动设备怎么去访问网络，看了下面这张图，就明白了。 可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）： 打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行） 打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options] 点击 [Connections] ，设置代理端口是8888， 勾选 Allow remote computers to connect， 点击OK 这时在 Fiddler 可以看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP） 在手机端连接PC的wifi，并且设置代理IP与端口（代理IP就是上图的IP，端口是Fiddler的代理端口8888） 访问网页输入代理IP和端口，下载Fiddler的证书，点击下图FiddlerRoot certificate 【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（Fiddler 设置解密HTTPS的网络数据） No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet? 安装完了证书，可以用手机访问应用，就可以看到截取到的数据包了。（下图选中是布卡漫画的数据包，下面还有QQ邮箱的） 4. Fiddler 内置命令与断点 Fiddler还有一个藏的很深的命令框，就是眼前，我用了几年的Fiddler都没有发现它，偶尔在别人的文章发现还有这个小功能，还蛮好用的，整理下记录在这里。 FIddler断点功能就是将请求截获下来，但是不发送，这个时候你可以干很多事情，比如说，把包改了，再发送给服务器。 命令 对应请求项 介绍 示例 ? All 问号后边跟一个字符串，可以匹配出包含这个字符串的请求 ?google &gt; Body 大于号后面跟一个数字，可以匹配出请求大小，大于这个数字请求 &gt;1000 &lt; Body 小于号跟大于号相反，匹配出请求大小，小于这个数字的请求 &lt;100 = Result 等于号后面跟数字，可以匹配HTTP返回码 =200 @ Host @后面跟Host，可以匹配域名 @www.baidu.com select Content-Type select后面跟响应类型，可以匹配到相关的类型 select image cls All 清空当前所有请求 cls dump All 将所有请求打包成saz压缩包，保存到“我的文档\Fiddler2\Captures”目录下dump start All 开始监听请求 start stop All 停止监听请求 stop 断点命令 命令 对应请求项 介绍 示例 bpafter All bpafter后边跟一个字符串，表示中断所有包含该字符串的请求 bpafter baidu（输入bpafter解除断点） bpu All 跟bpafter差不多，只不过这个是收到请求了，中断响应 bpu baidu（输入bpu解除断点） bps Result 后面跟状态吗，表示中断所有是这个状态码的请求 bps 200（输入bps解除断点） bpv / bpm HTTP方法 只中断HTTP方法的命令，HTTP方法如POST、GET bpv get（输入bpv解除断点） g / Go All 放行所有中断下来的请求 g 示例演示： ? &gt; &lt; = @ select cls dump 断点命令： 断点可以直接点击Fiddler下图的图标位置，就可以设置全部请求的断点，断点的命令可以精确设置需要截获那些请求。如下示例： 命令： bpafter bps bpv g / go 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2017/01/04/网络工具篇-抓包-Fiddler/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信小程序系列-组件篇]]></title>
      <url>%2F2016%2F12%2F26%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97-%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信小程序系列-入门篇]]></title>
      <url>%2F2016%2F12%2F26%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[先来一张马总演讲照片镇镇楼微信小程序自9月份发出内测邀请函后就颇受外界各大技术媒体及群众关注，进而又在十一月份实行正式对外开放公测。而在几天前的深商互联网大会上，鹅厂马厂长又宣布称春节前会推出微信“小程序”，这应该是近几年各大APP群雄割据之下商业入口点切得最深最狠的一次，算得上是在革APP的命。这种不需要下载安转即可使用的应用，实现了应用“At your fingertips”的梦想,用户扫一扫或者搜一下即可打开应用。也体现出“用完即走”的理念，用户不用关心是否安装太多应用的问题。真正做到应用将无处不在，而又随时可用，但又无需安装卸载。这也势必在移动应用江湖中掀起一场血雨腥风。BTW，掌握这门开发技术，也能给自己求职加加筹码，加之微信端入口流量之大，对于想创业的IT人来说门槛也降低了不少，那么就开始吧！ 概要基于目前暂不支持个人开发注册小程序，如果以政府，企业，媒体，其他组织来开发的话，可以参考一下具体流程 百度经验，个人开发者也不是不能开发，只是在使用开发工具时，选择不填写AppID就行。接着选择创建项目，或者导入本地项目，这里面为方便初学者快速了解小程序代码结构以及开发，如果选择的本地文件夹是空文件夹，开发者工具会自动提示，是否需要创建一个quick start项目，依据个人情况，试一下就知道了。 附上 开发工具下载 简介进入项目 通过创建小程序实例，进入到项目，几乎所有操作都在左侧菜单栏上 编辑 查看和编辑项目代码 调试 测试代码及模拟小程序在微信客户端效果 项目 可以发送到手机中预览实际效果 这里说一下，如果想删除项目，要先点进项目，然后左侧菜单点击“项目”进入，最下就有“删除”按钮 开发项目目录介绍进入 “编辑” ：项目结构如下这些都是初始化项目所包含的必不可少的 app.js(脚本) 处理监听小程序生命周期函数、声明全局变量、获取小程序实例、响应页面交互等等 123456789101112131415161718192021222324252627282930//app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) &#125;, getUserInfo:function(cb)&#123; var that = this if(this.globalData.userInfo)&#123; typeof cb == "function" &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo typeof cb == "function" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) app.json(配置) 小程序全局配置，配置页面、窗口背景色、导航条样式、默认标题等等 123456789101112&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;&#125; app.wxss(样式) 小程序的公共样式表 12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 创建页面1）初始项目包含两个页面: index页面和logs页面，即应用欢迎页和小程序启动日志页面，都在pages目录下。2）微信小程序的每一个页面的【路径+页面名】都需要写在app.json的pages中,且pages的第一个页面是小程序的首页。3）每一个小程序页面都是由同路径下同名的四个不同后缀文件组成 .js 后缀 - 脚本文件 .json 后缀 - 配置文件 .wxss 后缀 - 样式表文件 .wxml 后缀 - 页面布局文件 说明: 稍加注意会发现在index文件下并没有对应的index.json；这是因为如果未给页面的文件夹下设置.json配置文件,系统会默认配置项目中的app.json文件供页面使用。可以试着将logs文件夹下的.json文件删除即可理解。 手机预览进入左侧菜单“项目” -》 点击“预览” -》扫码后即可在微信客户端中体验由于个人开发暂不可申请AppID，所以预览功能还未开放给个人。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/12/26/微信小程序系列-入门篇/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法总结]]></title>
      <url>%2F2016%2F12%2F14%2FMarkdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[想必写博客的人最有发言权，普通编辑器是没法写出加粗、超链接、标题效果的，要写出类似html各个标签效果同时又能降低学习成本,那么首选就是Markdown语法了。Markdown 是一种轻量级的「标记语言」,它的优点很多,目前也被越来越多的写作爱好者,撰稿者广泛使用。 Markdown 编辑器语法指南基本技巧代码如果你只想高亮语句中的某个函数名或关键字，可以使用 function_name() 实现 通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 12345```javascript$(document).ready(function () &#123; alert(&apos;hello world&apos;);&#125;); 支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml 也可以使用 4 空格缩进，再贴上代码，实现相同的的效果 def g(x): yield from range(x, 0, -1) yield from range(x) 标题文章内容较多时，可以用标题分段： 标题1 ====== 标题2 ----- ## 大标题 ## ### 小标题 ### 粗斜体*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 链接常用链接方法 文字链接 [链接名称](http://链接网址) 网址链接 &lt;http://链接网址&gt; 高级链接技巧 这个链接用 1 作为网址变量 [Google][1]. 这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo]. 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 列表普通无序列表 - 列表文本前使用 [减号+空格] + 列表文本前使用 [加号+空格] * 列表文本前使用 [星号+空格] 普通有序列表 1. 列表前使用 [数字+空格] 2. 我们会自动帮你添加数字 7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 列表嵌套 1. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格 2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱 3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格 4. 列表里代码段： 1前面四个空格，之后按代码语法 ``` 书写 或者直接空八个，引入代码块 引用普通引用 &gt; 引用文本前使用 [大于号+空格] &gt; 折行可以不加，新起一行都要加上哦 引用里嵌套引用 &gt; 最外层引用 &gt; &gt; 多一个 &gt; 嵌套一层引用 &gt; &gt; &gt; 可以嵌套很多层 引用里嵌套列表 &gt; - 这是引用里嵌套的一个列表 &gt; - 还可以有子列表 &gt; * 子列表需要从 - 之后延后四个空格开始 引用里嵌套代码块 &gt; 同样的，在前面加四个空格形成代码块 &gt; &gt; 12&gt; 或者使用 ``` 形成代码块&gt; 图片跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？ ![图片名称](http://图片网址) 当然，你也可以像网址那样对图片网址使用变量 这个链接用 1 作为网址变量 [Google][1]. 然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png 也可以使用 HTML 的图片语法来自定义图片的宽高大小 &lt;img src=&quot;htt://example.com/sample.png&quot; width=&quot;400&quot; height=&quot;100&quot;&gt; 换行如果另起一行，只需在当前行结尾加 2 个空格 在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 前面的段落 --- 后面的段落 高级技巧行内 HTML 元素目前只支持部分段内 HTML 元素效果，包括 &lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt; ， 如键位显示 使用 &lt;kbd&gt;Ctrl&lt;kbd&gt;+&lt;kbd&gt;Alt&lt;kbd&gt;+&lt;kbd&gt;Del&lt;kbd&gt; 重启电脑 代码块 使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块 粗斜体 &lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt; 符号转义 如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \_ \# \* 进行避免。 \_不想这里的文本变斜体\_ \*\*不想这里的文本被加粗\*\* 扩展支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。 http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/ https://gist.github.com/{gist_id} http://runjs.cn/detail/{id} http://v.youku.com/v_show/id_{video_id}.html 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： $$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$ $$ x \href{why-equal.html}{=} y^2 + 1 $$ 同时也支持 HTML 属性，如： $$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$ $$ (x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}} $$ 最后附带插入视频，gif语法插入视频代码： &lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot;&gt; 插入gif代码： &lt;iframe height=500 width=500 src=&quot;http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif&quot;&gt; 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/12/14/Markdown语法总结/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列之年末总结——我的2016]]></title>
      <url>%2F2016%2F12%2F12%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%88%91%E7%9A%842016%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android部落格之Dagger 2框架]]></title>
      <url>%2F2016%2F12%2F09%2FAndroid%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BDagger%202%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[和Java一样, Android开发也有自己的依赖注入框架, 但是和Spring不同的是, Spring注入的原理是通过Java反射来实现的, 但Android却不能通过这个方式来实现, 对于惜内存如金的Android设备, 这种方式无异于将应用程序运行效率降低了一个档次。基于此Dagger就应运而生了 概述:基于Java平台的依赖注入库，通过使用注解实现依赖注入 实现原理: 利用APT(Annotation Process Tool)在编译时生成辅助类，这些类继承特定父类或实现特定接口，程序运行时依靠Dagger加载这些辅助类，调用相应接口完成依赖生成和注入。 基本使用：1）构造函数无参 - 对象生成通过@Inject 2) 构造函数有参 参数也需注解 @Provides注解 常用注解方法:@Inject - 类/字段@Module - 管理方法@Provide - 定义方法(参数!参数!参数)@Component - 管理所有@Modules注入对象关联@Inject对象@Scope - 限定注解作用域@Qualifier - 注解依赖标示 区别1） @Inject 和 @Provides 两种依赖生成方式： a. @Inject 用于注入可实例化的类； @Provides 用于注入所有类 b. @Inject 用于修饰属性和构造函数，用于任何非Module类； @Provides 只可用于修饰非构造类函数，且必须在Module内部 c. @Inject 修饰的函数只能是构造函数； @Provides 修饰的函数必须以provide开头 编译检查错误（1） 所有需要依赖注入的类，需要显式声明在相应的 Module 中（2） 一个 Module 中所有 @Provides 函数的参数都必须在这个 Module 中提供相应的被 @Provides 修饰的函数，或者在 @Module 注解后添加 “complete = false” 注明这是一个不完整的 Module ，表示它依赖不属于这个 Module 的其他 Dependency 。（3） 一个 Module 中所有的 @Provides 函数都要被它声明的注入对象所使用，或者在 @Module 注解后添加 “library = true”注明它含有对外的 Dependency，可能被其他 Module 依赖。 工作原理（1） 编译时，通过APT查看所有的java文件，并根据注解生成一些新的java文件（2）（3） KNOWLEADGE@Inject - 无法注解抽象类一、Dagger 2中有3种提供依赖方式1) 构造器注入 @Inject标注在构造器上，代表: ① Dagger 2可以使用这个构造器构建对象 ② 注入构造器所需要的参数的依赖 构造器注入的局限: 如果有多个构造器，只能标注其一，无法标注多个。 2) 属性注入被标注的属性不能使用private修饰，否则无法注入。 3) 方法注入标注在public方法上，Dagger 2会在构造器执行之后立即调用被注解方法。 二、方法注入 &amp; 属性注入如果依赖需要this对象，使用方法注入可以提供安全的this对象 @Component这个注解本身并没有意义，它需要依赖注入框架才有意义。用来标记需要被注入框架的注入方法、属性、构造。一、Component中一般使用两种方式定义方法1) void inject(目标类 obj);Dagger 2会从目标类开始查找@Inject注解，自动生成依赖注入的代码，调用inject可完成依赖的注入。 2) Object getObj();Dagger 2会到Object类中找被@Inject注解标注的构造器，自动生成提供Object依赖的代码，这种方式一般为其他Component提供依赖。 此处介绍Component中方法的第三种定义: @Component class AComponent{ XxxComponent plus(Module... modules) // XxxComponent是该AComponent的依赖，被@Subcomponent标注 // modules则是XxxComponent指定的Module } @Subcomponent(modules = xxxx) class XxxComponent{ } 二、流程说明1）Dagger 2框架以Component中定义的方法作为入口，到目标类中寻找JSR-330定义的@Inject标注，生成一系列提供依赖的Factory类和注入依赖的Injector类；2）Component联系Factory和Injector，最终完成依赖的注入。 @Module 和 @Provides一、如何使用1) @Module标记在类上2) @Provides标记在方法上3) @Component中指定Module 二、流程说明1) @Module 需要和 @Provides 同时使用才具有作用，并且@Component也需要指定Module；2) @Module 是告诉Component,可以从这里获取依赖对象。Component会去找被@Provides标注的方法 注:① @Component 可以指定多个 @Module② @Component 可以依赖其他 Component @Qualifier 和 @Named@Qualifier 限定符@Named 基于String的限定符 比较:1) @Qualifier作用和 @Named几乎一样，推荐使用前者，因为 @Named需要手写字符串2）@Qualifier不是直接注解在属性上，而是用来自定义注解的 @Component的dependence 和 @Subcomponent一、比较适合使用Subcomponent场景1) 很多工具类需要使用到Application的Context对象，此时可以用一个Component负责提供，可以命名为AppComponent；2) 需要用到context对象的SharePreferenceComponent、ToastComponent就可以作为Subcomponent；3) 在AppComponent，可以很清晰的知道哪些子Component，XxxComponent plus(Module… modules) Component dependences 和 Subcomponent 区别:1) dependences能单独使用，Subcomponent必须由Component调用方法获取；2) dependences可以清楚得知依赖哪个Component，Subcomponent不知道被谁引用；3）使用区别Subcomponent -&gt; DaggerAppComponent.plus(new SharePreferenceModule());dependences -&gt; DaggerAppComponent.sharePreferenceComponent(SharePreferenceCompont.create()) 二、总结 Component dependences: 1. 想保留独立的某个组件 2. 要明确的显示该组件所使用的其他依赖 Subcomponent 1. 两个组件间关系紧密 2. 只关心Component，而Subcomponent只作为Component拓展，可以通过Component.xxx调用 @Scope 和 @Singleton一、介绍@Scope 用来管理依赖的生命周期 和@Qualifier一样用来自定义注解的@Singleton 是@Scope的默认实现 注解单例 二、注意1）@Scope是需要成对存在的，在Module中的Provide方法使用@Scope，那么对应的Component中也必须使用@Scope注解，当两边的@Scope名字一样是（比如同为@Singleton），那么该Provide方法提供的依赖将会在Component中保持“局部单例”；而在Component中标注@Scope，provide方法没有标注，那么这个Scope是不会起作用的，而Component上的Scope作用也只是为了能顺利通过编译。2）@Singleton是自定义的@Scope，作用如上所述。由于是框架默认定义，因此比自定义Scope多了一个编译检测功能，用以防止不规范的使用Scope注解。3）如何做到全局单例？做到 （1）依赖在Component中是单例的。（供该依赖的provide方法和对应的Component类使用同一个Scope注解） （2）对应的Component在App中只初始化一次，每次注入依赖都使用这个Component对象。（在Application中创建该Component） 三、总结1）Scope是用来给开发者管理依赖的生命周期，它可以让某个依赖在Component中保持“局部单例”，如果将Component保存在Application中复用，则可以让该依赖在app中保持单例。2）通过自定义不同的Scope注解来标记这个依赖的生命周期，因此命名规范很重要@Singleton 依赖是单例的@ActivityScope 依赖的生命周期和Activity一样@FragmentScope 依赖的生命周期和Fragment一样… … @MapKey 和 Lazy一、介绍@MapKey用来定义依赖集合（Maps 和 Sets）目前只提供两种类型 - String 和 Enum LazyDagger2支持Lazy模式，通过Lazy模拟提供的实例，在@Inject的时候并不初始化，而是使用时，主动调用其get方法获取实例。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/12/09/Android部落格之Dagger 2框架/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目开发]]></title>
      <url>%2F2016%2F11%2F27%2F%E6%83%B3%E4%B8%8D%E5%87%BA%E6%A0%87%E9%A2%98JUST4LIFE%2F</url>
      <content type="text"><![CDATA[前言装修一直是互联网极力想颠覆的领域之一，十年之前，大量的建材采购电商就已兴起。然而直至今日，互联网家装仍难以见到大规模的发展趋势。其实家装就是房地产下游产业，要想解决用户需求，首先要了解的就是互联网家装发达地区，也就是北上广深杭这些地方的买房人群。 第一部分 摘要一、项目背景 数据显示，2011年居民用来装修的总费用高达1.85万亿元，而在2013年就超过2万亿元，自2014年爱空间家装推出699元/平方米的产品后，来自不同品牌的698元/平方米、666元/平方米、599元/平方米的服务就层出不穷，有的企业还细分了施工包或者主材包，也用类似的定价模式。 互联网让家装公司离客户越来越近，所以中间的环节都不再需要。企业之间通过竞争，不断有效地应对环境的变化，自然而然进入了微利时代。这种模式的代表企业有爱空间、居然装饰、圣点装饰、实创装饰、东易日盛、速美集家等。 同时，装修一直是互联网极力想颠覆的领域之一，十年之前，大量的建材采购电商就已兴起。然而直至今日，互联网家装仍难以见到大规模的发展趋势。其实家装就是房地产下游产业，要想解决用户需求，首先要了解的就是互联网家装发达地区，也就是北上广深杭这些地方的买房人群。 自2016年“去库存”政策一出，房地产行业整体呈现回暖趋势，随之一起的家装行业也迎来春天。与传统家装思维不同的是，生活在这些倍感压力的城市，买房本属不易，却不想装修又费神费力，因此势必会顺应O2O的懒人经济潮流，这直接导致他们非常重视消费体验。 这样的情况下，未来的国内家装O2O呈现一种趋势－一站式整体家装，从建材到设计，从装修到家居，这里面行业分散带来的弊病才是用户需求的痛点所在，家居建材行业无法直接对接到C端用户，而作为家装服务流程中的一环，打通家装产业链，对接上下游资源，自然就应运出了一站式整体家装模式。这里稍加解释，所谓的家装业上下游产业即上游的家具销售、家居品销售、家电销售，下游的家装设计服务。 二、开发项目简介 考虑贵公司暂无相关线上产品，前期推荐的互联网产品包括：官网 + 淘宝店铺/天猫旗舰店 + 微信公众号/服务号 + 朋友圈H5营销 三、项目开发价格说明官网定制开发域名可在新网购买zhaizi .com / .cn / .net均被注册，后续考虑其他名称 1、设计报价 项目 内容说明 报价 页面美工设计 根据客户提出的需求方案或草图，进行布局与整体效果设计 2000 元 特效页面 含有特殊效果的页面 500 元/页 Banner设计 根据客户需求设计 150 元/个 Logo设计 根据客户需求设计 200 元/个 2、内容页报价 项目 内容说明 报价 首页制作 按照设计图，优化页面和相应的图形，静态页面在60K以内，动态页面在80K以内。 1800 元 栏目页制作 在栏目页模板里划分区域、填充内容、优化细节 1500 元/套 内容页制作 在内容页模板里填充内容、优化细节 1500 元/套 3、功能模块报价 项目 内容说明 报价 预约功能 风格与网站统一，及时收集和反馈客户信息。 1800 元/套 JS特效 整体页面特效包含(滚动切换、瀑布流、H5动感特效等) 3000 元/套 (包括设计) 信息检索系统 在web中，提供方便、高效的查询服务，查询可以按照分类，关键字等查询，也可以基于全文内容的全文检索。支持对任意字段的复杂组合检索；支持中英文混合检索；支持智能模糊检索。 1200 元/套 发布与更新系统 资讯类别动态管理，后台添加，前台实时展示，可按类别、日期、内容等关键字，对资讯进行查询，后台设置管理员维护界面，可对每条资讯进行编辑，图片位置，实现图文绕字，可议论热点资讯，优先显示。 3200 元/套 地图功能 页面排版设计+调用(百度/高德/腾讯/搜狗)地图API动态页面 1500 元/套 后台管理系统 产品信息类别动态管理,后台添加,前台实时展示,可按类别、内容等关键字，对产品信息进行查询，后台设置管理员维护界面，可对每条产品信息进行编辑，产品图的增加、修改和删除，文字信息的增加和修改。 4000 元/个 会员注册与管理系统 用户可以在网站上登记注册,选择会员的类别、查看的权限范围并成为预备会员，提交到用户管理数据库。待后台管理人员审核通过成为正式会员，享有网站提供的相应服务。 3000 元/个 在线客服系统 B/S架构，兼容主流浏览器，标识客户IP信息，主动发起邀请对话等。 2500 元 服务器费用 腾讯云服务器-双核-2G-5M 宽带-50G硬盘 2500 元/年 移动端微信定制开发1、设计报价 项目 内容说明 报价 页面美工设计 根据客户提出的需求方案或草图，进行布局设计与整体效果设计。 1200 元 H5动感页面 基于HTML5通过JS特效渲染界面。 600 元/页 PC和移动端打通 一个后台控制PC端和移动端主页面内容。 3000 元 2、内容页报价 项目 内容说明 报价 移动页制作 根据需求和行业由美工进行设计。 3200 元/套 微相册 在移动页面展示客户照片和产品照片。 800 元/套 关键词/图文回复 根据用户属性、需求，编辑设定相关的关键词并回复相应内容。 600 元/套 微信会员卡 根据会员以及商家特征，设计具有吸引力的微信会员特权 1200 元/套 微抽奖 根据商家的奖励制度，设置相应的中奖几率 500 元/套 位置查询回复 客户发送微信位置后，可根据用户的位置返回最近的门店信息 1600 元/套 快捷操作 用户点击可以直接跳转电话、地图导航、可以直接按照地理位置查询路线。进行导航。（一键通话、一键导航等等） 1000 元/整包 360度全景 通过全景可以360度完美展示企业形象，提升用户的体验感 3600 元/份 微社区 通过微社区搭建、可以让客户自由交流秀图、在微社区后台可及时删除不良信息、让客户自由发布活动项目、快速打造粉丝活跃度。 1000 元/搭建 3500 元/开发 注意事项 项目 内容说明 HTML页面 甲方须提供相关文字和图片资料等素材、设计依照素材布局，对无素材部分，可提出要求，由本团队自行设计，费用单独核算 制作规格 文字规格统一用一种字体、图片按24色标准制作 加急费用 页面制作时间根据客户具体情况而定。如需在指定日期以内完成，则按照总开发设计合同加收20%至50%的加急费用。 文字输入 用户需提供word文档格式的文件，如需我方提供文字输入按 20元/千字 计算。 网站维护及迭代更新 4000元/年(包含空间费用) 第二部分 家装行业与市场分析一、市场环境分析 现状家装行业虽然很大，但是家装行业的企业规模是比较小的。每家公司的市场份额都很小，究其根本原因就是传统的家装公司所采取的运营模式就是传统的裁缝铺式的模式。所谓的裁缝铺式额模式，就是整个家装过程都由一个人具体负责的，比如客户接待-量房-设计-选材等，这种模式下工作的效率是十分低下的，同时对企业来说也是十分难扩大规模。 家装行业面临着巨大的挑战：第一是进入家装行业的门槛逐渐提高，因为行业准入制度和行业标准都更加严格。因此，家装企业的经营风险也加大了。第二个就是家装企业的成本也逐渐提高了，比如说人力成本和房租等，因此家装企业的盈利能力因为成本的提高而降低了，落后的企业最终结果就是被淘汰。 (一)政策环境分析 国家出台政策支持住宅精装修业务，这对家装行业而言是利好消息；同时房地产调控政策对住宅精装修化也有不小的影响。 (二)经济环境分析1、装饰建材业需求持续强劲，装修规模仍保持较大幅度增长。2、国家的房地产调控政策虽然将继续进行，但房地产作为国民经济支柱产业的地位不会改变3、环保、节能、减排、低碳，以及更加严格的工艺标准，对建筑装饰装修材料的技术要求越来越高。 二、家装行业预测分析 网络的盛行使得电子商务对客户的影响也逐渐上升了。互联网优点就是信息透明化，比如价格、设计等，许多人都可以通过互联网完成洽商、设计、购买材料等过程，有的公司还在天猫开设网络旗舰店，许多公司的网络营销的销量甚至占到业务量的50%。不仅如此，未来的家装行业还可以满足不同的客户个性化定制，家装的产品品质和服务都可以得到整体的提升，也本着绿色环保的原则进行标准化施工。透明化的企业管理和信息公开，全新的商业模式也会使得家装行业未来的前景十分广阔。 三、家装行业目标市场分析 传统家装行业的目标市场单一而薄利，这主要是基于模式而言的；现代互联网+思维下的家装行业，则更多的聚焦于个性化定制上。这里需理解的是，互联网消费本就是中低端消费，所以切入点围绕预算，视工头为核心。主要模式可分为以下三种：私人定制型模式：有钱人（毕竟少数）传统家装型模式：固定家庭（中坚力量）现代快装型模式：不固定家庭（崛起势力）因此最好的发展：重点发展现代快装型模式家装，择优选择传统家装型模式家装，适当选择发展私人定制型模式家装行业定位: 追求高端 – 实践中端 – 兼顾低端 四、市场分析小结 市场造就了各个公司和各种模式，各种模式的并存及发展反应了不同的需求，也可以理解为一种摸索的过程，一种发展的不确定性，更可以说是一个更大的发展空间。但模式归纳一下，无非是家装引导产品、产品引导家装而已。 A、家装引导产品如目前的元洲、龙发、美巢等，营销点更多的是放在家装上面，以传统家装为先，然后销售产品。无论在宣传上以工地材料为卖点，还是以设计为卖点，还是以套餐模式，最终形成完整家居服务。这种模式也是目前的主流，因为是基于消费者的消费习惯之上的。 优势： 运营灵活度较高，营销点多，设计，工程都可入手； 客户容易接受及认可； 产品可先度高，可供客户选择面多； 和主材市场可相互借力，冲突小； 完整家居服务符合目前的主流消费。 劣势： 竞争相对激烈； 过于依赖设计师，客户如不认识设计师，刚一切成空； 价格战在接触消费者时已开始； B、产品引导家装如博洛尼、东易、家得宝等。以产品或是产品设计组合为入口，来带动整体销售，甚至是可以只消费产品，而不做家装。 优势： 客户自由度相对较高； 卖场能快速吸引客户； 前期产品，后期家装，更容易把握客户； 单值容易做大； 价格对比相对隐藏； 劣势： 前期投入相对大； 产品局限性大，可供选择面小； 消费群相对缩小； 对产品的依赖性过强； 第三部分 团队介绍一、成员基本情况二、擅长业务领域介绍三、组织架构第四部分 产品与技术一、主要产品介绍公司官网主要服务于公司业务介绍，案例展示 优点：公司门户，业务案例展示，提高企业知名度、信誉度 缺点：前期访问流量少，需长期运营维护 淘宝 &amp; 天猫（天猫家装）主要服务于产品升级，线上业务扩展淘宝开店铺： 开店流程参考文章天猫开旗舰店： 开店流程参考文章 优点: 入口流量大，开店成本运营较低，方便推广 缺点: 线上竞争激烈，受制于信誉评级 齐家 &amp; 土巴兔 &amp; 一起装修网入驻商家平台，扩展线上业务 优点：专业家装线上平台，客源多，便于推广运营 缺点：同行恶意竞争打压，业务不稳定，同样受制于信誉评级 微信主要服务于产品升级，线上业务扩展公众号: 开设流程参考文章服务号: 开设流程参考文章应用号(MiniApp): 开设流程参考文章 优点：潜在客户群庞大，易于客户维护，适合群体销售 缺点：前期流量引导较难，短时间内提升信誉度较难 类似知乎、房天下等大型问答社区主要服务于运营和推广 优点：耗费极少人力，宣传成本低，点对点解决用户需求 缺点：引导客户难，成单率低，时效性低 二、技术与研发 考虑到产品组合涉及前端、后端开发，具体技术如下: 网站开发: 动画，图片处理，Javascript，CSS+DIV，表格，XML，OS设置，对系统有一定的认知，以及网站的IDE的熟悉；同时熟悉动态技术 ASP、ASP.NET、PHP、JSP 等等。 微信开发: 熟悉服务器语言asp.net，php，JSP等；客户端掌握html，css，javascript等知识，html5实现较为炫酷的动画效果。 (一)关键技术介绍网站开发1、网站版面开发技术为DIV+CSS2、开发技术选择ASP/JSP/PHP3．动态网页转换静态网页 （1）动态网页以数据库技术为基础，可以大大降低网站维护的工作量 （2）采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线搜索、用户管理、订单管理等等； （3）动态网页实际上并不是独立存在于服务器上的网页文件，只有当用户请求时服务器才返回一个完整的网页； （4）静态网页每个网页都有一个固定的URL； （5）静态网页的内容相对稳定，因此容易被搜索引擎检索。 网店设立包括注册、实名认证、店铺装修、上架商品等等 微信开发1、微信平台上实现和特定群体的文字、图片、语音、视频的全方位沟通、互动，形成了一种主流的线上线下微信互动营销方式；2、制作微官网，自由选择微网站模板，包括微信会员卡、微餐饮、微酒店、微婚庆、微商城、微团购、微调研、微投票、自定义菜单、大转盘、刮刮卡、优惠券、砸金蛋等活动。 (二)技术亮点(三)持续创新安排第五部分 营销规划一、营销战略线上运营推广:线下展销活动: 二、营销措施一、品牌建设二、市场推广 第六部分 项目发展规划一、发展战略 从建材到设计，从装修到家居，消费者希望有一种模式，能用相对合理具有性价比的方式把这几项进行整合，作为好不容易买房的新主们，可以更加省心的搞定自己的爱巢。所以站在客户角度，公司需要不断摸索，连接消费者和行业人士。 个人更倾向消费者连接消费者（UGC）引导 ，建立社群，实现运营，自主导向流量。前期的用户获取，考虑当地房产中介，这个获取成本很低而且迅速精准 二、阶段发展规划短期规划：立足闵行区，以当前项目为基础，力争品牌、开拓市场中期规划：未来几年内实现累计市场份额突破X个亿，上海市内做到知名企业，在行业中做到一定知名度长期规划：是否IPO 三、风险因素 合同风险 工程款支付方式 成本控制 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/11/27/想不出标题JUST4LIFE/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【译】Must Have Libraries]]></title>
      <url>%2F2016%2F11%2F16%2F%E3%80%90%E8%AF%91%E3%80%91Must%20Have%20Libraries%2F</url>
      <content type="text"><![CDATA[概述Android开发有很多第三方库，但其实它们大多数都是相当流行的“必须具备”的库并且经常被用在几乎所有的Android项目中。每个库都有其用途，但是它们所有的库都是为了使开发者的开发生活更加愉快。 下面列出了几个分类里主要的库。 标准包装这个”标准包”下面列出的库是非常主流，应用广泛的，并且可能需要被安装在大多数Android App项目里: 名称 描述 Retrofit 一个类型安全的使用注解的方式智能映射API到客户端接口Android REST客户端 Glide 一个强大的Android图片下载和缓存库 ButerKnife 使用Java注解方式，让Android开发可以更好的简化常用任务 Parceler 可以很方便的通过代码生成Android Parcelable接口 IcePick 简化Android对象实例状态框架，用于简化保存和恢复实例状态的生命周期 LeakCanary 捕获内存溢出框架 Espresso UI 自动化测试框架 Robolectric 高效的Android单元测试框架 进阶包装 这个”进阶包”下面列出的是附加的库，它们使用起来更高级，但是却在一些优秀的Android团队中很流行。请注意这些库可能不适合你的处女App。这些高级的库包括： 名称 描述 Dagger 2 一个快速管理对象的的依赖注入器框架 RxJava Anroid开发全响应式的组件框架 EventBus 为简单组件通信的Android事件总线框架 AndroidAnnotations 强大的注解用来减少样板代码 Retrolambda 支持Android操作λ块 请记住这些库的组合可能并不能很好的相互处理。接下部分突出了其中的一些问题。 Parceler 和 IcePick请记住你不能使用IcePick保存Parceler对象的当前状态。关于更多的情境之为何它们不适合请看这个GitHub话题。你将需要使用IcePick显示地包裹化对象。你可以考虑替换Parceler为AutoParceler，这并不影响使用IcePick。 ButterKnife 和 Parceler和Parceler库一起使用ButterKnife库会造成多个javax.annotation.processing.Processor声明。在这种情况下，你不得不在你的app/build.gradle文件里排除这种冲突: packagingOptions{ exclude &apos;META-INF/services/javax.annotation.processing.Processor&apos; //butterknife } ButterKnife 和 自定义View通常你可能会发现在你的构造器中声明ButterKnife或者Dagger注入器的使用会阻止Android Studio去预览你的自定义视图布局。你可能会看到一个关于需要 isEditMode() 的错误。本质上这个方法是用来执行一段代码前使你的代码发生短路，那样就可能被用于运行时但是不能再预览窗口中执行。 public ContentEditorView(Context context, AttributeSet attrs) { super(context, attrs); LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); inflater.inflate(R.layout.view_custom, this, true); // short circuit here inside the layout editor if(isInEditMode()) { return; } ButterKnife.bind(this); } 便利性 Dagger - 一个快速的Android和Java依赖注入器 Spork - Spork是一个基于注解进程的库，用来加速项目开发。它允许你编写更少的样板代码来使代码可读性更强，并且更易于维护。 AutoParcel - Google AutoValue Android端Parcelable代产品 Hugo - 在app里记录日志更为简单 Logger - 更为简洁的日志追踪消息 LeakCanary - 发生内存泄露时捕获更为简单 AndroidAnnotation - 加快Android开发的框架。它负责管道，从而让你专注到真正重要的事情上来。通过简化代码，它很便于维护 Calligraphy - 自定义字体更为简单 EasyFonts - 在应用程序里加载自定义字体更为简单 AndroidViewAnimations - 使常见属性动画使用更为简单 AboutLibraries - 使用库会自动生成一个 关于这个app 的列表部分。 SDK Manager Plugin - 如果你缺失了一个SDK版本、还没有下载一个API版本，或者你的支持库已经更新，这会是很有用的插件特别是小组项目。 EasyDeviceInfo - 以超级简单的方式获取设备信息 Sensey - 立马即可检测手势 拓展 RxJava - JVM响应式扩展 EventBus - Android最佳化事件总线，简化组件间通信 Tape - Tape是Android和Java的一个队列相关的集合类 Priority - 简单的后台任务 网络通信 Retrofit - 一个Android和Java基于注解方式的智能映射API为客户端接口类型安全的REST客户端 Picasso - 一个强大的图片下载和缓存的Android库 Ion - 强大的异步网络通信库。点击这里下载jar包 Android Async HTTP - 加载远程JSON等内容的异步网络通信客户端 Volley - Google的HTTP库，让Android网络通信变得更简单并且最重要的是更快 OkHttp - Square的底层网络通信库，支持异步请求 Glide - Picasso是Google的支持的可供选择的图片加载框架 Android Universal Image Loader - 可供选择的主流图像加载框架，可以被用来替换Picasso和Glide Fresco - fb的一个图片管理库 Fast Android Networking - 一个在OkHttp网络层之上Android应用中做任何类型的网络通信的强大库 列表（ListView） EasyListViewAdapters - 用于构建更加简洁容易的多行类型列表 GridListViewAdapters - 轻松构建无限制王哥卡片式列表就像play市场。（ListView的工作就如无限制的网格列表） StickyListHeaders - 一个节标头停滞在列表头部的Android库 PinnedListView - 有固定部分的列表 ListViewAnimations - 可以简单实现列表子项动画方式 Cardslib - 列表或者网格的卡牌式UI PullToRefresh-ListView - 列表使用pull-to-refresh功能更为简单。下载和作为一个库项目安装 QuickReturn - 显示或者隐藏列表列表滚动方向的头部或者底部 Paginated Table - 这是一个允许任何对象的列表动态分页的表格。图标可以被添加到列中和自定义项，例如复选框以及按钮一样 列表（RecyclerView） UltimateRecyclerView - 加强版RecyclerView，含有刷新，加载更多，动画以及许多其他功能。 AdvRecyclerView - 被扩展的RecyclerView，含有滑动删除，以及拖动和展开项功能 android-parallax-recyclerview - 一个可以用来实现视差效果的RecyclerView的适配器 sticky-headers-recyclerview - RecycelrView可以实现粘滞头部装饰器 FastAdapter - 简化加速RecyclerView填充数据速度的适配器 ItemAnimatiors - RecyclerView动画器为了实现子项增/删/移动画 GreedoLayout - RecyclerView拥有完整的长宽比网格布局管理器 RecyclerViewHelper - 为RecyclerView提供最常用的功能，比如滑动删除，拖放，UI分隔线，子项被选择与否时的事件，以及点击子项设置监听器等等 async-expandable-list - 简单api提供方法来展示header-sub-items结构，以及异步加载sub-list到一个可扩展的列表。 简单页面导航 JazzyViewPager - 拥有很多动画的页面 ParallaxPager - 拥有滑动视差效果的ViewPager ParallaxHeaderViewPager - 另一种有滑动视差效果的ViewPager SlidingMenu - 允许开发者简单创建侧滑菜单应用的库，比如在那些Google+，YouTube，以及Facebook app里就非常流行 Android Satellite Menu - 可配置的”路径”菜单风格的圆形菜单 ArcMenu - 仿照”路径”菜单风格的提供选择的圆形菜单 AndroidSlidingUpPanel - 上滑面板 DraggablePannel - 可拖放的面板 MaterialDrawer - 轻松添加Material风格抽屉式导航以及账户切换功能 UI 组件 SparkButton - 创建像Twitter的带有动画的爱心喜欢按钮的库 Crouton - 上下文相关的，可配置的提示通知比土司弹出更为优雅。下载jar包在这里，更多代码示例看这里 BetterPickers - BetterPikers方便输入选择 android-shape-imageview - 自定义形状的Android ImageView控件，包括气泡型，星型，爱心型，钻石型。 RoundedImageView - 这个流行库非常方便地塑成圆角或者创建椭圆图形 Android StackBlur - 动态模糊图像 Android Bootstrap - Bootstrap UI控件 PhotoView - 支持触摸手势的ImgeView ShowcaseView - 突出你应用最好的部分 FadingActionBar - 很酷的actionbar渐变特效 ProgressWheel - 较好的进度条库 SmoothProgressBar - 水平不确定进度条 CircularFillableLoaders - 漂亮的带有动画的填充式加载器 Rebound - 简单弹簧动力学反弹库 AndroidImageSSlider - 图像平移转变动画库 FloatingActionButton - Material design风格悬浮按钮 Foursquare-CollectionPicker - 如方形兴趣品味选择器一样的项选择器 NexusDialog - 轻松创建表格对话框 dialogplus - 简单简洁的对话框库 Iconify - 轻松嵌入图标至应用中 Android StepsView - Android创建步骤视图的库 Android-Iconics - 添加可伸缩多样化的图标至应用中 Scissors - 一个简单的图片裁剪库 Material-SearchView - 漂亮的Material类型的简单搜索视图 PersistentSearchBar - 实现持久化搜索导航条 Android Material Intro Screen - 轻松添加App介绍页的库 绘图 MPAndroidChart - 一个强大的Android图表/曲线库。支持线型-柱型-饼状-雷达状-气泡状-蜡烛线图表以及缩放、拖放、和其他动画。 HoloGraphLibrary - 新的图形图表库 EazeGraph - 另一个新的有潜力的图表库 AndroidCharts - 轻松使用图表的一个库 AndroidGraphView - 创建灵活好看的图表库 AndroidPlot - Android测绘库 WilliamChart - 灵活有用的运动功能图表库 HelloCharts - 支持缩放,滚动及动画的Android图表/图形库 Leonids - 简单易懂的粒子特效(参见教程) Confetti - 新的粒子特效库 AChartEngine - 一个Android应用程序图表软件库 图像处理 AndroidPhotoFilters - 在你选择的任何图片上创建感兴趣效果的库。带有预览样本的效果。 android-gpuimage - 主流的GPU图像处理库 android-image-filter - 旧版图像滤光库 picasso-transformations - Picasso图像处理库 glide-transformations - Glide图像处理库 ImageEffectFilter - 简单代码实现图像处理库 VidEffects - 操纵效应引入视频库 扫描 ZXing - 条形码或者QR扫描库 ZXing Android Embedded - 和zxing可交替使用的扫描库 barcodescanner - 新的扫描库 CamView - 和ZXing一样可供选择的库 android-quick-response-code - 另一种可供选择的扫描库 持久化 ActiveAndroid DBFlow - 一款强大、健壮并且非常简单的基于注解处理的ORM android数据库 greenDAO SugerORM RxCache - Android响应式缓存库 Android-Orma - Android SQLite数据库封装成的类型安全的ORM ORMLite SQLBrite - SQLiteOpenHelper的轻量级封装库 Cupboard - 主流的SQL封装库 StorIO - 新生代轻量级的SQL封装库 Realm NexusData Hawk - 持久安全的键值存储库 Poetry - 持久化JSON直入SQLite JDXA - Android符合KISS原则（Keep It Simple and Straightforward）的ORM - 简单，非侵入式，灵活 #数据绑定 RecyclerViewBinding - RecyclerView轻松添加数据绑定的库 CommandDataBinding - 更好处理点击动作的库 兼容性 NineOldAndroids - 完全兼容性动画库，在Android所有版本中都能工作，被广泛使用。下载和作为库项目安装。 HoloEverywhere - Android Holo主题4.2到2.1+补丁库 CropImage - 裁剪图片意图简单兼容库 滚动和视差这是一个主流的滚动和视差库列表 QuickReturn - 显示或隐藏列表滚动方向上的页眉或页脚 ParallaxPagerTransformer - Android页面变换视差效果 ParallaxHeaderViewPager - 另一种ViewPager视差滑动特效 Android-ObservableScrollView - 可滚动视图中观察滚动事件的Android库 Scrollable - 实现滚动选项卡时自动滚动逻辑 ParallaxPager - 滚动视差效果ViewPager android-parallax-recyclerview - 可实现视差效果的RecyclerView适配器 调试 Stetho - Android应用程序调试桥，可以多种用途并不局限于网络监测，数据库监测以及Javascript控制台 Bugfender - app日志云存储，追踪用户行为从而找到应用程序中的问题 资源参阅以下资源寻找库: http://android-arsenal.com Wasabeef Core Libraries Wasabeef UI Libraries Snowdream Android Library Repository Android-Libs.com http://androidlibs.org/ http://appdevwiki.com/wiki/show/HomePage http://www.libtastic.com 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/11/16/【译】Must Have Libraries/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava系列-操作符]]></title>
      <url>%2F2016%2F08%2F20%2FRxJava%E7%B3%BB%E5%88%97-%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[这篇关于Rx的操作符整理，是旨在不熟悉操作符情况下，便于查询以及参考理解之用。 用于创建Observable的操作符 Create — 通过调用观察者的方法从头创建一个Observable Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable Empty/Never/Throw — 创建行为受限的特殊Observable From — 将其它的对象或数据结构转换为Observable Interval — 创建一个定时发射整数序列的Observable Just — 将对象或者对象集合转换为一个会发射这些对象的Observable Range — 创建发射指定范围的整数序列的Observable Repeat — 创建重复发射特定的数据或数据序列的Observable Start — 创建发射一个函数的返回值的Observable Timer — 创建在一个指定的延迟之后发射单个数据的Observable 变换操作这些操作符可用于对Observable发射的数据进行变换，详细解释可以看每个操作符的文档 Buffer — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个 FlatMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。 GroupBy — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 Map — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项 Scan — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值 Window — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集 过滤操作这些操作符用于从Observable发射的数据中进行选择 Debounce — 只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作 Distinct — 去重，过滤掉重复数据项 ElementAt — 取值，取特定位置的数据项 Filter — 过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的 First — 首项，只发射满足条件的第一条数据 IgnoreElements — 忽略所有的数据，只保留终止通知(onError或onCompleted) Last — 末项，只发射最后一条数据 Sample — 取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst Skip — 跳过前面的若干项数据 SkipLast — 跳过后面的若干项数据 Take — 只保留前面的若干项数据 TakeLast — 只保留后面的若干项数据 组合操作组合操作符用于将多个Observable组合成一个单一的Observable And/Then/When — 通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集 CombineLatest — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果 Join — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射 Merge — 将两个Observable发射的数据组合并成一个 StartWith — 在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项 Switch — 将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据 Zip — 打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射 错误处理这些操作符用于从错误通知中恢复 Catch — 捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复 Retry — 重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止 辅助操作一组用于处理Observable的操作符 Delay — 延迟一段时间发射结果数据 Do — 注册一个动作占用一些Observable的生命周期事件，相当于Mock某个操作 Materialize/Dematerialize — 将发射的数据和通知都当做数据发射，或者反过来 ObserveOn — 指定观察者观察Observable的调度程序（工作线程） Serialize — 强制Observable按次序发射数据并且功能是有效的 Subscribe — 收到Observable发射的数据和通知后执行的操作 SubscribeOn — 指定Observable应该在哪个调度程序上执行 TimeInterval — 将一个Observable转换为发射两个数据之间所耗费时间的Observable Timeout — 添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知 Timestamp — 给Observable发射的每个数据项添加一个时间戳 Using — 创建一个只在Observable的生命周期内存在的一次性资源 条件和布尔操作这些操作符可用于单个或多个数据项，也可用于Observable All — 判断Observable发射的所有的数据项是否都满足某个条件 Amb — 给定多个Observable，只让第一个发射数据的Observable发射全部数据 Contains — 判断Observable是否会发射一个指定的数据项 DefaultIfEmpty — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据 SequenceEqual — 判断两个Observable是否按相同的数据序列 SkipUntil — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据 SkipWhile — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据 TakeUntil — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知 TakeWhile — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据 算术和聚合操作这些操作符可用于整个数据序列 Average — 计算Observable发射的数据序列的平均值，然后发射这个结果 Concat — 不交错的连接多个Observable的数据 Count — 计算Observable发射的数据个数，然后发射这个结果 Max — 计算并发射数据序列的最大值 Min — 计算并发射数据序列的最小值 Reduce — 按顺序对数据序列的每一个应用某个函数，然后返回这个值 Sum — 计算并发射数据序列的和 连接操作一些有精确可控的订阅行为的特殊Observable Connect — 指示一个可连接的Observable开始发射数据给订阅者 Publish — 将一个普通的Observable转换为可连接的 RefCount — 使一个可连接的Observable表现得像一个普通的Observable Replay — 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅 转换操作 To — 将Observable转换为其它的对象或数据结构 Blocking 阻塞Observable的操作符 操作符决策树几种主要的需求 直接创建一个Observable（创建操作） 组合多个Observable（组合操作） 对Observable发射的数据执行变换操作（变换操作） 从Observable发射的数据中取特定的值（过滤操作） 转发Observable的部分值（条件/布尔/过滤操作） 对Observable发射的数据序列求值（算术/聚合操作） 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/20/RxJava系列-操作符/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列APP重构]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8BAPP%E9%87%8D%E6%9E%84%2F</url>
      <content type="text"><![CDATA[关于App重构对于架构的设计理念，一定随着项目经验的累积而逐渐清晰，我始终坚信，没有哪一个架构完美，如果有，那一定是。。。骗人的！ 而我能做的，就是这个架构设计Bigger than bigger(比逼格更有逼格)，曾经有位同事告诉我，你所认为别人的牛逼，只是你不懂，等你进了这个门，不过就这样。说这些不是为了说明别人所做的事情多么多么简单，而是一定要专注。工作了两年，见到过特别优秀的人有很多，每个人所散发出的气质多少都有不同，但唯一不变的，就是专注的眼神，你专注的干一件事，一年，两年，许多年，相信我，一定会成功。 感（zhuang）慨（bi）结束，开搞！！！ 什么情况下需要重构结构混乱 代码的层次感觉差，无奈业务线傻傻分不清 业务模块间层次交替，主次不分，藕断丝连 架构多样，你喜欢她，她喜欢他，他喜欢他 编码风格各成一派，天下武林本一家，何必 可读性差 能一个类写下的，坚决不写第二个类 – 啊喂 new个class又不要钱 编码格式，我型我秀，自立门派 – 西八 写代码我们是专业的好不 多余，无用代码满屏飞 – 求得麻碟 这还不足以激起你的强迫症吗 注释、注释、注释 – 斯国一 能装一波的地方还浪费掉那就可惜了 继承、接口拼命用 – 他母亲的 可算是找到你大爷的大爷的大爷了 无法弹性适应产品发展 维护困难，牵一发而动全身 业务线转变，代码就会改的面目全非 新功能加入，更是找不到接入点，只能另起炉灶 重构目标重构 = 代码质量 代码质量 代码质量 ….. 请接招 可读性越简单越要做好 － 凭你的智慧，我很难跟你解释 有规矩成方圆 - 统一规范的命名 简洁有效的注释 有问题待解决用TODO 国有国法行有行规 － 你以为躲起来就找不到你了吗？没有用的！像你这样出色的男人，无论在什么地方，都像漆黑中的萤火虫一样，那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣子，神乎其神的刀法，和那杯Dry Martine，都深深地迷住了我。不过，虽然你是这样的出色，但是行有行规，无论怎样你要付清昨晚的过夜费呀，叫女人就不用给钱么？ 结构清层次明 - 能解耦就解，想办法抽离出变化 简约而不简单 － 你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？ 悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又…你看我还没说完你又把棍子给扔掉了！月光宝盒是宝物，你把他扔掉会污染环境，要是砸到小朋友怎么办？就算砸不到小朋友砸到那些花花草草也是不对的！ 逻辑简约 - 拒绝一类含千行 模式虽好不要贪杯 － 唉，那个金刚圈尺寸太差，前重后轻左宽右窄，他戴上之后很不舒服，整晚失眠，会连累我嘛！他虽然是个猴子，可是你也不能这样对他，官府知道了会说我虐待动物的！说起那个金刚圈，去年我在陈家村认识了一位铁匠，他手工精美、价钱又公道、童叟无欺，干脆我介绍你再定做一个吧！ 设计模式 - 用好但不滥用 可维护性 杜绝魔鬼数字、字符串、尺寸值、颜色值等。 代码复用，以便维护。 不写死，预测可能的变化(但不要提前设计)。 可扩展性 良好的分层结构，MVx模式运用。 通过一些设计模式的使用来提高可扩展性。 法则： S(单一职责) － Single Responsibility Principle ******************************* SRP ＝＞ 每个方法或类应当有且仅有一个改变的理由。这明确指出每个方法或类就应该只负责一件事，或者一项职责。 O(开放/封闭)－ Open/Close Principle ****************************************** OCP ＝＞ 软件(方法、类)应当对扩展开放，对修改关闭。 L(里氏替换) － Liskov Substitution Principle ********************************* LSP ＝＞ 用超类代替应用程序中使用的对象时，应当不会破坏应用程序。 I(接口分离) － Interface Segregation Principle ******************************* ISP ＝＞ 不应当强制客户端依赖于其不使用的接口。 D(依赖倒置) － Dependency Inversion Principle ******************************** DIP ＝＞ 代码应当取决于抽象概念，而不是具体实现；这些抽象不应当依赖于细节；而细节应当依赖于抽象。 如何重构何为重构: 软件工程希望建立完美的需求与设计，按照既有的规范编写标准划一的代码。 快速迭代和RAD颠覆&quot;全知全能&quot;的神话,用近乎刀劈斧砍(crack)的方式解决问题。 此为refactoring 作为进行已久的Android工程，该如何重构?以下参考大神blog 架构选择，结构调整 根据Project业务场景(展示型、交互型、后台工具型…)选择合适的架构。 1. 并不是说一定要选用一个架构，比如说后台工具型的App，可能界面不多，与服务器的交互也少，基本都是由Service组成，这样直接用Android原生结构就OK。 2. 界面较多，且与服务器交互较多的建议选用MVP架构。可以通过P来做数据处理，将数据源M与展示层V解耦，便于替换数据源或是改变UI。 根据选用的架构以及业务模块分包 技术/开源库选定 ListView/RecyclerView的选择，Fragment/Activity的选择等。 根据业务特点和选择的架构，选用相关技术/开源库支持或对当前使用的进行整理。 例如HTTP请求库，缓存库，图片加载库等等。 确定规范 指定编码习惯，可以根据Google推荐的Java编码规范，适当定制。 正所谓高冷的英雄从不看身后的火焰！客人你的蛋（代）炒（码）饭（规范）来了。 制定代码提交规范，git flow 管理流程规范等等。 自底而上，由小至大 从底部开始，也就是常说的Model层，数据层开始，因为这部分相对独立，可以通过接口与UI层隔离。 不要一下就大面积重构，需要逐个击破，确保当前的每一次改动都能正常运行。 持续重构，伴随测试 持续进行小范围重构，每次重构都要伴随测试进行，保证重构质量 提取方法,去除重复代码； 结构调整； 融入面向对象/接口编程思想，注意SOLID原则； 多用组合，少用继承 … … 最好有单元测试支持 重构而非重写 看书看书看书 再做总结 －－ 《重构-改善既有代码的设计》 附文 － 关于架构重构的规则Uber技术主管在OSAC上谈及的关于架构重构的12条规则，不一起学习未免可惜： 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/13/进阶系列之APP重构/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列之求职路漫漫]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B1%82%E8%81%8C%E8%B7%AF%E6%BC%AB%E6%BC%AB%2F</url>
      <content type="text"><![CDATA[国内一线互联网公司内部面试题库摘自大神博客，基于面试，个人觉得整理的还是很全面的，大公司看重的技术能力，那一定是在应对项目时常常遇到的技术，能掌握这些，一是让自己的技术水准能更上一层楼，二，是个人观点，男人总得上进，进入大公司，体验500强公司的文化，对做人处世都大有裨益。 So just try it and try it! 一、java基础1.接口的意义**（百度）规范、扩展、回调 2.抽象类的意义**（乐视）为其子类提供一个公共的类型封装子类中得重复内容定义抽象方法，子类虽然有不同的实现 但是定义是一致的 3.内部类的作用**(百度，乐视) 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 创建内部类对象的时刻并不依赖于外围类对象的创建。 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 内部类提供了更好的封装，除了该外围类，其他类都不能访问 4.父类的静态方法能否被子类重写，为什么？**（猎豹）不能。 子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现 5.举1-2个排序算法，并使用java代码实现**（美团）排序算法总结 6.列举java的集合及其之间继承关系**（百度、美团） 7.java虚拟机的特性**（百度、乐视）Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 8.哪些情况下的对象会被垃圾回收机制处理掉**（乐视、美团、小米）Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。 9.进程和线程的区别**（猎豹）简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。 10.Java中==和equals的区别，equals和hashCode的区别**（乐视）区别 11.常见的排序算法时间复杂度**（小米） 12.HashMap的实现原理**（美团）1. HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2. HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 13.java 状态机**状态机 14.java中int char long各占多少字节数**基本类型 位数 字节数 byte 8 1 short 16 2 int 32 4 long 64 8 float 32 4 double 64 8 char 16 2 15.java int与integer的区别**区别 16.string stringbuffer stringbuilder 区别**（小米、乐视、百度）String 字符串常量 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的： String S1 = “This is only a” + “ simple” + “ test”; StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4;这时候 JVM 会规规矩矩的按照原来的方式去做 在大部分情况下 StringBuffer &gt; String StringBuffer Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder &gt; StringBuffer java.lang.StringBuilder java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同 17.Java多态**（乐视）Java多态性理解 Java中多态性的实现 什么是多态 面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。下面是多态存在的三个必要条件，要求大家做梦时都能背出来！ 多态存在的三个必要条件一、要有继承；二、要有重写；三、父类引用指向子类对象。 多态的好处： 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。 18.什么导致线程阻塞**（58、美团）线程的阻塞 为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持. 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。 suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程. wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用. 初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。 上述的核心区别导致了一系列的细节上的区别。 首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。 其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。 wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。 关于 wait() 和 notify() 方法最后再说明两点： 第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。 以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 19.抽象类接口区别**（360） 默认的方法实现抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现 实现子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器抽象类可以有构造器接口不能有构造器 与正常Java类的区别除了你不能实例化抽象类之外，它和普通Java类没有任何区接口是完全不同的类型 访问修饰符抽象方法可以有public、protected和default这些修饰符接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法抽象方法可以有main方法并且我们可以运行它接口没有main方法，因此我们不能运行它。 多继承抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 速度它比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。 20.容器类之间的区别**（乐视、美团）总结1 总结2. 总结3 21.java 内部类**（小米）详细介绍 22.Java中hashmap和hashtable的区别**（乐视、小米）区别 23.ArrayMap VS HashMap**比较 二、android基础1.数据库的操作类型有哪些，如何导入外部数据库？**把原数据库包括在项目源码的 res/raw android系统下数据库应该存放在 /data/data/com..（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录. 2.是否使用过本地广播，和全局广播有什么差别？**因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。 不用担心别的应用伪造广播，造成安全隐患。 相比在系统内发送全局广播，它更高效。 3.是否使用过intentService，作用是什么，AIDL解决了什么问题？**(小米)生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intent。 生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。 该服务提供了一个onBind()方法的默认实现，它返回null 提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。 AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。 4.Activity、Window、View三者的差别，fragment的特点？**（360）Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。 1. 在Activity中调用attach，创建了一个Window 2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow 3. 在Activity中调用setContentView(R.layout.xxx) 4. 其中实际上是调用的getWindow().setContentView() 5. 调用PhoneWindow中的setContentView方法 6. 创建ParentView： 作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类） 7. 将指定的R.layout.xxx进行填充 ,通过布局填充器进行填充【其中的parent指的就是DecorView】 8. 调用到ViewGroup 9. 调用ViewGroup的removeAllView()，先将所有的view移除掉 10. 添加新的view：addView() fragment 特点 Fragment可以作为Activity界面的一部分组成出现； 可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用； 在Activity运行过程中，可以添加、移除或者替换Fragment； Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。 5.描述一次网络请求的流程**（新浪） 6.Handler、Thread和HandlerThread的差别**（小米）http://blog.csdn.net/guolin_blog/article/details/9991569 http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/ 从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。 android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也就是HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。 7.低版本SDK实现高版本api**（小米）自己实现或@TargetApi annotation 8.Ubuntu编译安卓系统**（百度）1. 进入源码根目录 2. . build/envsetup.sh 3. lunch 4. full(编译全部) 5. userdebug(选择编译版本) 6. make -j8(开启8个线程编译) 9.launch mode应用场景**（百度、小米、乐视）standard，创建一个新的Activity。 singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。 singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。 注意: 设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。 在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。 singleInstance，回退栈中，只有这一个Activity，没有其他Activity。 singleTop适合接收通知启动的内容显示页面。 例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。 例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance应用场景： 闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。 10.touch 事件传递流程**（小米）详细介绍 11.view绘制流程**（百度）详细介绍 12.多线程**（360） Activity.runOnUiThread(Runnable) View.post(Runnable),View.postDelay(Runnable,long) Handler AsyncTask 13.线程同步（百度） 详细介绍1 详细介绍2 单例 public class Singleton{ private volatile static Singleton mSingleton; private Singleton(){ } public static Singleton getInstance(){ if(mSingleton == null){\\A synchronized(Singleton.class){\\C if(mSingleton == null) mSingleton = new Singleton();\\B } } return mSingleton; } } 14.什么情况导致内存泄漏**（美团）1.资源对象没关闭造成的内存泄漏 描述： 资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。 程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。 2.构造Adapter时，没有使用缓存的convertView 描述： 以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法： public View getView(int position, ViewconvertView, ViewGroup parent) 来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据 当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。示例代码： public View getView(int position, ViewconvertView, ViewGroup parent) { View view = new Xxx(...); ... ... return view; } 修正示例代码： public View getView(int position, ViewconvertView, ViewGroup parent) { View view = null; if (convertView != null) { view = convertView; populate(view, getItem(position)); ... } else { view = new Xxx(...); ... } return view; } 3.Bitmap对象不在使用时调用recycle()释放内存 描述： 有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释： /** •Free up the memory associated with thisbitmap&apos;s pixels, and mark the •bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or •setPixels() is called, and will drawnothing. This operation cannot be •reversed, so it should only be called ifyou are sure there are no •further uses for the bitmap. This is anadvanced call, and normally need •not be called, since the normal GCprocess will free up this memory when •there are no more references to thisbitmap. */ 4.试着使用关于application的context来替代和activity相关的context 这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免 Android内存泄漏。 5.注册没取消造成的内存泄漏 一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。 比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。 但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。 虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。 6.集合中对象没清理造成的内存泄漏 我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。 15.ANR定位和修正**如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。 主线程中存在耗时的计算 主线程中错误的操作，比如Thread.wait或者Thread.sleep等Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框 应用在5秒内未响应用户的输入事件（如按键或者触摸） BroadcastReceiver未在10秒内完成相关的处理 Service在特定的时间内无法处理完成 20秒 使用AsyncTask处理耗时IO操作。 使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。 Activity的onCreate和onResume回调中尽量避免耗时的代码 BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。 16.什么情况导致oom**（乐视、美团）Introduction 1）使用更加轻量的数据结构 2）Android里面使用Enum 3）Bitmap对象的内存占用 4）更大的图片 5）onDraw方法里面执行对象的创建 6）StringBuilder 17.Android Service与Activity之间通信的几种方式** 通过Binder对象 通过broadcast(广播)的形式 18.Android各个版本API的区别**区别 19. Android代码中实现WAP方式联网**（360）方法 20.如何保证service在后台不被kill**一、onStartCommand方法，返回START_STICKY START_STICKY在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建 service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。 START_NOT_STICKY在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。 START_REDELIVER_INTENT在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。 二、提升service优先级 在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。 三、提升service进程优先级 Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是: 前台进程( FOREGROUND_APP) 可视进程(VISIBLE_APP ) 次要服务进程(SECONDARY_SERVER ) 后台进程 (HIDDEN_APP) 内容供应节点(CONTENT_PROVIDER) 空进程(EMPTY_APP) 当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。 四、onDestroy方法里重启service service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service； 五、Application加上Persistent属性 六、监听系统广播判断Service状态 通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。 21.Requestlayout，onlayout，onDraw，DrawChild区别与联系**（猎豹）requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制任何视图包括该调用者本身。 onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局) 调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法) drawChild()去重新回调每个子视图的draw()方法 22.invalidate()和postInvalidate() 的区别及使用**（百度）使用与区别 23.Android动画框架实现原理**Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。 24.Android为每个应用程序分配的内存大小是多少？**（美团）android程序内存一般限制在16M，也有的是24M 25.Android View刷新机制**（百度、美团）由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。 调用流程 ： mView.draw()开始绘制，draw()方法实现的功能如下： 绘制该View的背景 为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框) 调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法) 调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。 26.LinearLayout对比RelativeLayout**（百度） RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。 27.优化自定义view**（百度、乐视、小米）为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。 你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。 另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。 如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。 28.ContentProvider**（乐视）Introduction 29.fragment生命周期** 30.volley解析**（美团、乐视）Volley源码解析 31.Android Glide源码解析**Glide源码解析1 Glide源码解析2 32.Android 设计模式**设计模式 33.架构设计**（搜狐） 架构设计 34.Android属性动画特性**（乐视、小米）如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。 注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。 然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。 最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/13/进阶系列之求职路漫漫/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列之代码开发规范]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[在开发中，主动权在己之手，因此有些规范实则是人为的一些硬性约束或者说习惯风格，但如若迥异之处过多，不仅影响开发速度，造成团队开发进展迟滞不前，而且对我们程序猿来说，编程素养也未能得到提高，境界上不去，总不能码一辈子吧，所以能有一套主流的开发规范常印脑海，以求不变应万变，才是上上之策。 一些约定 类中public方法在前，private在后，所有不对外的方法，变量全部使用private修饰符。类中public static final的常量在最上方，其次private static final，然后public，private等。 类中定义的接口放在变量声明之后，所有方法之前。 方法相关性，方法之间有调用关系的，按照先后顺序排列在一起。 善用空行，方法体之间必须空行，代码逻辑块之间使用空行分隔，变量声明根据变量类型适当空行。 方法体不要过长，尽量提取小方法代替逻辑块，保证代码可读性。 善用TODO，对于未完成或已完成但是方案不完美需后续跟踪的，使用TODO标签标示，并写好注释。 不建议注释太多，要通过方法名，变量名提高代码可读性，而非注释。但是一些非常规方法，复杂逻辑，需要详细注释说明。 协作中，不要做整个代码的格式化，仅格式化自己编写的那部分。 注意命名以及注释英文单词，不要写错~ 杜绝“Magic Number”, 所有数值根据情况提取为常量，dimen或constant。 代码规范 使用Android Studio提供的格式化规范。 命名规范1. Java命名分类 命名方式 举例 说明 包名 全小写 com.cicaero.kite 公司域名倒序，“.”分隔，单个包名建议不超过12个字母 类名 首字母大写的驼峰 UserInfo 名词形式 接口名 首字母大写的驼峰 ServerInterface 名字形式 方法名 驼峰 getUserInfo 动词结构，含义为一个动作 常量 全大写，单词下划线分隔 MSG_UPDATE_PROGRESS 建议数值类常量从1开始，且根据功能预留数段 成员变量 m/s/is/has开头的驼峰 mImageUrl 正常成员m开头，静态s开头，布尔型is/has开头 局部变量 首字母小写的驼峰 currentPosition 名词形式，除非是循环，否则不建议使用i，j，k等简单变量名 2. 资源命名分类 命名方式 举例 说明 布局 全小写，单词下划线分隔 activity_main.xml Activity以activity开头，Fragment以fragment开头， List、Grid项以item开头，Dialog布局以dialog开头， 自定义View以layout开头，其他被include的或公用组件， 诸如title_bar,bottom_bar,根据实际含义命名 Drawable 全小写，单词下划线分隔 btn_bg.png 根据图片使用方式命名， 图标以ic_开头，背景以_bg结尾， 状态drawable xml以_selector结尾。 Color 全小写，单词下划线分隔 green 尽量根据颜色值命名 String 全小写，单词下划线分隔 app_name 模块多且大的话，根据模块建立不同的String xml 文件 style 首字母大写的驼峰 NoTitleTheme 类似类名，style本身也是有类似类的集成关系 dimension 全小写，单词下划线分隔 left_padding id 全小写，单词下划线分隔 user_name_tv 详细id命名规范参考以下章节 3. 布局文件中的View id命名View 结尾命名规则 TextView tv Button btn EditText et ImageView iv ImageButton img_btn RadioButton rb RadioGroup rg SeekBar seek ProgressBar progress Spinner spinner VideoView vv CheckBox cb ListView lv GridView grid Layout lt 其他规范 Gradle引入第三方库时comment加上库地址。 编译相关的常量写入编译脚本。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/13/进阶系列之代码开发规范/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列之年中总结——我的2016]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%88%91%E7%9A%842016%2F</url>
      <content type="text"><![CDATA[无论怎样 这可能是我人生中搭建的最搓的一次架构煎熬了一个月，项目总算吭哧吭哧的完成，从最初的技术选型，到框架搭建，再到着手开发app，是一次尝试，也让自己越来越坚定的想在Android之路走下去，像这么有意思的事，不做个纪念写点东西是不行的。 开发前就已做好面对各种坑的准备，只是没想到，坑一个个来的都那么的理所当然，甚至理直气壮，关于这些必须针对模块一一列举，本系列文章目前按如下顺序写，这也是我项目开发从零到一的一个思路，可能在以后随着经验值增长，会做的更细致一些。那就开始吧，首先 技术选型之所以把这列为第一项，很大程度上源于我对之前公司开发框架囿于桎梏所做出的一些改变吧，我很难想象再去开发一个app依旧停留在过去的思维之上，所以这次开发之前，就立过决心，这里罗列出当时的想法，一些还没付诸。RxJava/RxAndroid + OkHttp + Retrofit ( + Dagger2 )Dagger2还没有加入项目中，在下一版迭代前加入后来开发中发现MVP模式开发很能解决Activity业务代码繁重的问题，解耦相当好，反正记住一个真理就行：所有牛逼的框架，那一定是解耦和相当出色的。要不然怎么可能你能用他也能用，当然性能也是衡量一个框架的好坏。反正Square公司出品，必属精品。有Github的朋友，快去star 框架搭建开发IDE: Android Studio 主app + Android Lib + Java Lib（1）主app （2）Android lib （3）Java lib 基类封装UI 开发业务编写渠道发包（混淆，签名，加固，上线）性能优化工具辅助基础总结篇Android公共技术：公共技术点之 Android 动画基础 公共技术点之 Java 动态代理 公共技术点之依赖注入 公共技术点之 View 事件传递 公共技术点之 View 绘制流程 1.Android的Framework和Android apk的打包过程底层的Binder驱动，IPC的核心，SGL 2D绘图，OpenGL 3D绘图 2.多线程AsyncTask的缺陷和问题 关于线程池：asynctask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是asynctask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0后默认串行执行，不会出现这个问题)。针对这种情况，可以尝试自定义线程池，配合asynctask使用。 关于默认线程池：核心线程池中最多有CPU_COUNT+1个，最多有CPU_COUNT*2+1个，线程等待队列的最大等待数为128，但是可以自定义线程池。线程池是由AsyncTask来管理的，线程池允许tasks并行运行，xuyao注意的是并发情况下数据的一致性问题，新数据可能会被老数据覆盖掉，类似volatile变量。所以希望tasks能够串行运行的话，使用SERIAL_EXECUTOR。 自定义线程池：executeOnExecutor(Executor exec,Params… params) 自定义Executor execute(Params… params){return executeOnExecutor(sDefaultExecutor,params);} AsyncTask在不同的SDK版本中的区别： 调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案 通过查阅官方文档发现，AsyncTask首次引入时，异步任务是在一个独立的线程中顺序的执行，也就是说一次只能执行一个任务，不能并行的执行，从1.6开始，AsyncTask引入了线程池，支持同时执行5个异步任务，也就是说同时只能有5个线程运行，超过的线程只能等待，等待前面的线程某个执行完了才被调度和运行。换句话说，如果一个进程中的AsyncTask实例个数超过5个，那么假如前5个都运行很长时间的话，那么第6个只能等待机会了。这是AsyncTask的一个限制，而且对于2.3以前的版本无法解决。如果你的应用需要大量的后台线程去执行任务，那么你只能放弃使用AsyncTask，自己创建线程池来管理Thread，或者干脆不用线程池直接使用Thread也无妨。不得不说，虽然AsyncTask较Thread使用起来方便，但是它最多只能同时运行5个线程，这也大大局限了它的实力，你必须要小心设计你的应用，错开使用AsyncTask的时间，尽力做到分时，或者保证数量不会大于5个，否则就会遇到上次提到的问题。可能是Google意识到了AsyncTask的局限性了，从Android3.0开始对AsyncTask的API作出了一些调整：每次只启动一个线程执行一个任务，完成之后再执行第二个任务，也就是相当于只有一个后台线程在执行所提交的任务。 1、生命周期很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsyncTask会一直执行，直到doInBackground()方法执行完毕。然后，如果cancel(boolean)被调用,那么onCancelled(Result result)方法会被执行；否则，执行onPostExecute(Result result)方法。如果我们的Activity销毁之前，没有取消AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确的取消。 2、内存泄漏如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄漏。 3、结果丢失屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。 4、并行还是串行在Android1.6之前的版本，AsyncTask是串行的，在1.6至2.3的版本，改成了并行的。在2.3之后的版本又做了 修改，可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要执行executeOnExecutor(Executor)。 3.Android机制(1)Linux Sandbox 沙箱机制：Android将数据分为system和data两个区。其中system是只读的，dada用来存放应用自己的数据，这保证了系统数据不会被随意改写。 应用之间的数据相互独立，每个应用都会有一个user id和group id，只有相同的user id并且来自同一个作者，才能访问它们的数据。 作者通过对apk签名来标识自己，签名和uid构成了双重的保证。 (2)用户权限机制：文件权限，UID,GID (3)用户权限机制：android permission机制限制应用访问特定的资源，例如照相机、网络、外部存储等api 如何让两个app运行在同一个进程里？ 1. 两个app要用相同的private key来签名 2. 两个app的Manifest文件中要添加一样的属性 android:sharedUserId(设置成相同的UID) 4.Binder机制跨进程间通信(IPC):四大组件之间通过Intent互相跳转，Android实现IPC的方式是binder机制。 android中的跨进程通信的实现（一）——远程调用过程和aidl Android中的Binder机制的简要理解 Android中的Binder机制的简要理解二 In the Android platform, the binder is used for nearly everything that happens accross in the core plateform. 最底层的是Android的ashmen（Anonymous shared memoryy）机制，它负责辅助实现内存的分配，以及跨进程间通信所需要的内存共享。AIDL(Android Interface Definition Language)对BInder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。 从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户区间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动了，ServiceManager提供了辅助管理的功能，Client和Server正是在Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信。 1. Client、Server和ServiceManager实现在用户空间中，Binder驱动程序实现在内核空间中 2. Binder驱动程序和ServiceManager在Android平台已经实现，开发者只需要在用户空间实现自己的Client和Server 3. Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信 4. Client和Server之间的进程间通信通过Binder驱动程序间接实现 5. Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 服务器端：一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用语接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。 Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会相应的创建一个mRemote对象，该对象的类型也是也是Binder类。客户就可以借助这个mRemote对象来访问远程服务。 客户端：客户想要访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。 在这里，我们可以看到，客户端是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，然后相应的在Binder驱动中创建一个Binder对象，接着客户端通过获取Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind（粘连）在一起，实现通信。 mmap将一个文件或者其他对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。munmap执行相反的操作，删除特定地址区域的对象映射。 当使用mmap映射文件到进程后，就可以直接操作这段虚拟内存进行文件的读写等操作，不必再调用read，write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。 采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保存共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。 aidl主要就是帮助我们完成了包装数据和解包的过程，并调用了transact过程，而用来传递的数据包我们就称为parcel AIDL: xxx.aidl-&gt;xxx.java,注册service 1. 用aidl定义需要被调用方法接口 2. 实现这些方法 3. 调用这些方法 5.NDKDalvik虚拟机在调用一个成员函数的时候，如果发现该成员函数是一个JNI方法，那么就会直接跳到它的地址去执行。也就是说，JNI方法是直接在本地操作系统执行的，而不是Dalvik虚拟机解释器执行。由此也可以看出，JNI方法是Android应用程序与本地操作系统直接进行通信的一个手段。 JNI原理： Dalvik虚拟机JNI方法的注册过程分析 例子：当libnanosleep.so文件被加载的时候，函数JNI_OnLoad就会被调用。在函数JNI_OnLoad中，参数vm描述的是当前线程中的Dalvik虚拟机，通过调用它的成员函数GetEnv就可以获得一个JNIEnv对象。有了这个JNIEnv对象之后，我们就可以调用另外一个函数jniRegisterNativeMethods来向当前进程的Dalvik虚拟机注册一个JNI方法。 6.Android系统启动过程，App启动过程App启动过程： Activity启动过程详解 从桌面点击到activity启动的过程 1、Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely,进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。 2、Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity。 3、调用ActivityManagerService的startActivity方法，这里做了进程切换（具体过程请查看源码）。 4、开启Activity，调用onCreate方法 7.Activity,Fragment,Service生命周期常见的例子：程序正运行着来电话了，这个程序咋办呢？中止了呗，如果中止的时候新出的一个Activity是全屏的onPause-&gt;onStop，恢复的时候onStart-&gt;onResume,如果打断这个应用程序的是一个Theme为Translucent或者Dialog的Activity那么只是onPause,恢复的时候onResume。 onPause: 恢复的时候onResume onCreate: 在这里创建界面，做一些数据的初始化工作 onStart: 到这一步变成用户可见不可交互的 onPause: 到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情，应该在这里保存你的一些 数据，因为这个时候你的程序的优先级降低，有可能被 系统回收。在这里保存的数据，应该在onResume里读出来。注意：这个方法里做的事情时间要短，因为下一个Activity不会等到这个方法完成才启动。 onStop: 变得不可见，被下一个Activity覆盖了(onPause和onStop的区别是否可见) onDestroy:这是Activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有一个ProgressDialog在线程中转动，请在onDestroy里把它cancel掉，不然等线程结束的时候，调用Dialog的cancel会抛出异常的。 onPause,onstop,onDestroy，三种状态下，Activity都有可能被系统干掉。 启动另一个Activity然后finish，先调用旧Activity的onPause方法，然后调用新的Activity和onCreate-&gt;onStart-&gt;onResume方法，然后调用旧Activity的onStop-&gt;onDestroy方法。 如果没有调用finish那么onDestroy方法不会被调用，而且在onStop之前还会调用onSavedInstanceState方法 onRestart方法执行完了之后还会调用onStart方法 fragment:[SupportFragmentManager,childFragment] service: Android Service的生命周期 android-Service和Thread的区别 Service和Intent Service:没啥区别，只是IntentService在onCreate方法中开启新的HandlerThread去执行。 Service运行的进程和线程：当它运行的时候如果是LocalService，那么对应的Service是运行在主进程的main线程上的。如onCreate,onStart这些函数都是在系统调用的时候在主进程的main线程上运行的。如果是RemoteSevice，那么对应的Service则是运行在独立的main线程上。 1. 服务不是单一的进程，服务没有自己的进程，应用程序可以不同，服务运行在相同的进程中 2. 服务不是线程，可以在线程中工作 3. 在应用中，如果是长时间的在后台运行，而且不需要交互的情况下，使用服务 4. 同样是在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下使用线程 5. 如果任务占用CPU时间多，资源大的情况下，要使用线程 Thread的运行是独立于Activity的，也就是说当一个Activity被finish之后，如果你没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread就会一直执行。 8.View绘画机制View的绘制主要涉及三个方法：onMeasure()、onLayout()、onDraw() 1. onMeasure主要用于计算view的大小，onLayout主要用于确定view在ContentView中的位置，onDraw主要是绘制View。 2. 在执行onMeasure()、onLayout()方法时都会通过相应的标志位或者对应的坐标点来判断是否需要执行对应的函数， 如我们经常调用的invalidate方法就只会执行onDraw方法，因为此时的视图大小和位置均未发生变化， 除非调用requestLayout方法完整强制进行view的绘制，从而执行上面三个方法。 进度条组件： ProgressView AnnotationView 9.事件传递机制android 事件处理机制总结，ScrollView ViewPager ListView GridView嵌套小结 当手指触摸到屏幕时，系统就会调用相应View的onTouchEvent，并传入一系列的action。 dispatchTouchEvent的执行顺序为： 首先触发ACTIVITY的dispatchTouchEvent,然后触发ACTIVITY的onUserInteraction 然后触发LAYOUT的dispatchTouchEvent，然后触发LAYOUT的onInterceptTouchEvent 这就解释了重写ViewGroup时必须调用super.dispatchTouchEvent(); (1)dispatchTouchEvent:此方法一般用于初步处理事件，因为动作是由此分发，所以通常会调用super.dispatchTouchEvent。这样就会继续调用onInterceptTouchEvent，再由onInterceptTouchEvent决定事件流向。 (2)onInterceptTouchEvent:若返回值为true事件会传递到自己的onTouchEvent();若返回值为false传递到下一个View的dispatchTouchEvent(); (3)onTouchEvent():若返回值为true，事件由自己消耗，后续动作让其处理；若返回值为false，自己不消耗事件了，向上返回让其他的父View的onTouchEvent接受处理 三大方法关系的伪代码：如果当前View拦截事件，就交给自己的onTouchEvent去处理，否则就丢给子View继续走相同的流程。 public boolean dispatchTouchEvent(MotionEvent ev) { boolean consume = false; if(onInterceptTouchEvent(ev)) { consume = onTouchEvent(ev); } else { consume = child.dispatchTouchEvent(ev); } return consume; } onTouchEvent的传递： 当有多个层级的View时，在父层级允许的情况下，这个action会一直传递直到遇到最深层的View。所以touch事件最先调用的是最底层View的onTouchEvent，如果View的onTouchEvent接收到某个touch action并做了相应处理，最后有两种返回方式return true和return false；return true会告诉系统当前的View需要处理这次的touch事件，以后的系统发出的ACTION_MOVE,ACTION_UP还是需要继续监听并接收的，并且这次的action已经被处理掉了，父层的View是不可能触发onTouchEvent的了。所以每一个action最多只能有一个onTouchEvent接口返回true。如果返回false，便会通知系统，当前View不关心这一次的touch事件，此时这个action会传向父级，调用父级View的onTouchEvent。但是这一次的touch事件之后发出任何action，该View都不在接受，onTouchEvent在这一次的touch事件中再也不会触发，也就是说一旦View返回false，那么之后的ACTION_MOVE,ACTION_UP等ACTION就不会在传入这个View,但是下一次touch事件的action还是会传进来的。 父层的onInterceptTouchEvent 前面说了底层的View能够接收到这次的事件有一个前提条件：在父层允许的情况下。假设不改变父层级的dispatch方法，在系统调用底层onTouchEvent之前会调用父View的onInterceptTouchEvent方法判断，父层View是否要截获本次touch事件之后的action。如果onInterceptTouchEvent返回了true，那么本次touch事件之后的所有action都不会向深层的View传递，统统都会传给父层View的onTouchEvent，就是说父层已经截获了这次touch事件，之后的action也不必询问onInterceptTouchEvent，在这次的touch事件之后发出的action时onInterceptTouchEvent不会再被调用，直到下一次touch事件的来临。如果onInterceptTouchEvent返回false，那么本次action将发送给更深层的View，并且之后的每一次action都会询问父层的onInterceptTouchEvent需不需要截获本次touch事件。只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，touch能够传到这里已经是最后一站了，肯定会调用View的onTouchEvent()。 底层View的getParent().requestDisallowInterceptTouchEvent(true) 对于底层的View来说，有一种方法可以阻止父层的View获取touch事件，就是调用getParent().requestDisallowInterceptTouchEvent(true)方法。一旦底层View收到touch的action后调用这个方法那么父层View就不会再调用onInterceptTouchEvent了，也无法截获以后的action（如果父层ViewGroup和最底层View需要截获不同焦点，或不同手势的touch，不能使用这个写死）。 曾经开发过程中遇到的两个示例：左边是处理ViewPager和ListView的冲突，纪录水平和垂直方向的偏移量，如果水平方向的偏移更多的话就让ViewPager处理pager滑动 右边处理的ViewPager和ImageBanner的滑动冲突，同样是纪录偏移量，如果发生在ImageBanner上的水平偏移量大于垂直偏移量的话就让banner滚动 想想为什么右边是重写dispatchTouchEvent方法而不是onInterceptTouchEvent方法？ FixedViewPager @Override public boolean onInterceptTouchEvent(MotionEvent ev) { switch(ev.getAction() &amp; MotionEvent.ACTION_MASK) { case MotionEvent.ACTION_DOWN: mX = ev.getX(); mY = ev.getY(); break; case MotionEvent.ACTION_MOVE: float x = ev.getX(); float y = ev.getY(); float dX = x - mX; float dY = y - mY; float tmp = Math.abs(dX) / Math.abs(dY); mX = x; mY = y; if(tmp &gt; 1) { return true; } else { return super.omInterceptTouchEvent(ev); } } } FixedImageLoadBanner @override public boolean dispatchTouchEvent(MotionEvent ev) { if(mX != 0 || mY != 0) { float dY = ev.getRawY() - mY; float dX = ev.getRawX() - mX; if(Math.abs(dY) &gt; Math.abs(dX)) { requestDisallowInterceptTouchEvent(false); } else { requestDisallowInterceptTouchEvent(true); } } mX = ev.getRawX(); mY = ev.getRawY(); return super.dispatchTouchEvent(ev); } 10.ART和Dalvik区别art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。 ART: Ahead of Time Dalvik: Just in Time 什么是Dalvik： Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 什么是ART: Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。 ART优点： 1. 系统性能的显著提升 2. 应用启动更快、运行更快、体验更流畅、触感反馈更及时。 3. 更长的电池续航能力 4. 支持更低的硬件 ART缺点： 1. 更大的存储空间占用，可能会增加10%-20% 2. 更长的应用安装时间 ###11.Scroller原理 Scroller执行流程里面的三个核心方法 1. mScroller.startScroll() 2. mScroller.computeScrollOffset() 3. view.computeScroll() 1、在mScroller.startScroll()中为滑动做了一些初始化准备，比如：起始坐标，滑动的距离和方向以及持续时间(有默认值)，动画开始时间等。 2、mScroller.computeScrollOffset()方法主要是根据当前已经消逝的时间来计算当前的坐标点。因为在mScroller.startScroll()中设置了动画时间，那么在computeScrollOffset()方法中依据已经消逝的时间就很容易得到当前时刻应该所处的位置并将其保存在变量mCurrX和mCurrY中。除此之外该方法还可判断动画是否已经结束。 12.Activity Manager Service, ActivityThread13.Android几种进程1. 前台进程： 即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的 2. 可见线程： 可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互 3. 服务进程： 其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关系的， 例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等，当系统要用空间运行前两者进程时才会被终止 4. 后台进程： 其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ,这样的进程系统一旦没有内存就首先被杀死。 5. 空进程： 不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的。 如何避免后台进程被杀死？ 1. 调用startForegound,让你的Service所在的进程成为前台进程 2. Service的onStartCommand返回START_STICKY或START_REDELIVER_INTENT 3. Service的onDestroy里面重新启动自己 14.Activity启动模式 standard: Activity的默认加载方式，该方法会通过跳转到一个新的Activity，同时将该实例压入到栈中(不管该Activity是否已经存在在Task栈中，都是采用new操作，生命周期从onCreate()开始)。例如：栈中顺序是A B C D,此时D通过Intent跳转到A，那么栈中结构就变成A B C D A,点击返回按钮的显示顺序是D C B A，依次摧毁。 singleTop: singleTop模式下，当前Activity D位于栈顶的时候，如果通过Intent跳转到它本身的Activity(D)，那么不会重新创建一个新的D实例(走onNewIntent()),所以栈中的结构依次为A B C D,如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个Activity，这肯定用singletop singleTask: singleTask模式下，Task栈中只能有一个对应的Activity实例。例如：Task栈1中结构为：A B C D。此时D通过Intent跳转到B（走onNewIntent()）,则栈的结构变成了:A,B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。通常应用于首页，首页肯定在栈底部，也只能在栈底部。 singleInstance: singleInstance模式下，会将打开的Activity压入一个新的任务栈中。例如：Task栈1中结构为：A B C,C通过Intent跳转到了D（D的模式为singleInstance），那么则会新建一个Task，栈1中结构依旧为A B C,栈2中结构为D。此时屏幕显示D，之后D通过Intent跳转到D，栈2不会压入新的D，所以两个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的launchMode在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C ,此时点击返回按钮，还是在C，栈1的结构变为A B C,而不会回到D。 ## launchMode为singleTask的时候，通过Intent启动到一个Activity，如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而不是调用onNewIntent方法。 onSavedInstanceState的调用遵循一个重要原则，即当系统”未经你许可”时销毁了你的Activity，则onSavedInstanceState会被系统调用，这时系统的责任，因为它必须要提供一个机会让你保存你的数据，至于onRestoreInstanceState方法，需要注意的是，onSavedInstanceState方法和onRestoreInstanceState方法”不一定”是成对调用的。 onRestoreInstanceState被调用的前提是，Activity A确实被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示Activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到Activity A,这种情况下Activity A一般不会因为内存的原因被销毁，故Activity的onRestoreInstanceState方法不会被执行。 另外，onRestoreInstanceStated的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。 onSavedInstanceState(Bundle bundle)通常和onRestoreInstanceState(Bundle bundle)不会成对出现，onRestoreInstanceState这玩意不太好触发，给大家提个好办法，横竖屏切换的时候100%会触发。然后保存在onRestoreInstanceState bundle里面的数据，就是onCreate的那个参数bundle啦，要怎么恢复就看开发者了。 15.TMImageView图片库的设计Feature机制 16.ListView优化1. 首先，虽然大家都知道，还是提一下，利用好convertView来重用View，切忌每次getView都新建。ListView的核心原理就是重用View。 ListView有一个回收器，Item滑出界面的时候view就会回收这里，需要显示新的Item的时候，就尽量重用回收器里面的View。 2. 利用好ViewType，例如你的ListView中有几个类型的Item，需要给每个类型创建不同的View，这样有利于ListView的回收，当然类型不能太多 3. 尽量让ItemView的Layout层次结构简单，这时所有Layout都必须遵守的 4. 善用自定义View，自定义View可以有效的减小Layout的层级，而且对绘制过程可以很好的控制 5. 尽量保证Adapter的hasStableIds()返回true，这样在notifyDataSetChanged()的时候，如果id不变，listView将不会重新绘制这个View，达到优化的目的。 6. 每个item不能太高，特别是不要超出屏幕的高度，可以参考Facebook的优化方法，把特别复杂的Item分解为若干个小的Item. 7. 为了保证ListView滑动的流畅性，getView()中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载。 8.使用RecyclerView代替。ListView每次更新数据都要notifyDataSetChanged(),有些太暴力了。RecyclerView在性能和可定制性上都有很大的改善，推荐使用。 9.有时需要从根本上考虑，是否真的要使用listView来实现你的需求，或者是否有其他选择？ 17.webView如何使用webview在js中调用java方法？ webView.addJavaScriptInterface(new Object(){xxx}, &quot;xxx&quot;); 答案：可以使用WebView控件执行JavaScript脚本，并且可以在JavaScript中执行Java代码。要想让WebView控件执行JavaScript，需要调用WebSettings.setJavaScriptEnabled方法，代码如下： WebView webView = (WebView)findViewById(R.id.webview); WebSettings webSettings = webView.getSettings(); //设置WebView支持JavaScript webSettings.setJavaScriptEnabled(true); webView.setWebChromeClient(new WebChromeClient()); JavaScript调用Java方法需要使用WebView.addJavascriptInterface方法设置JavaScript调用的Java方法，代码如下： webView.addJavascriptInterface(new Object() { //JavaScript调用的方法 public String process(String value) { //处理代码 return result; } }, &quot;demo&quot;); //demo是Java对象映射到JavaScript中的对象名 可以使用下面的JavaScript代码调用process方法，代码如下： &lt;script language=&quot;javascript&quot;&gt; function search() { //调用searchWord方法 result.innerHTML = &quot;&lt;font color=&apos;red&apos;&gt;&quot; + window.demo.process(&apos;data&apos;) + &quot;&lt;/font&gt;&quot;; } 18.SurfaceView和View的最本质的区别SurfaceView是在一个新起的单独线程中可以重新绘制画面，而view必须在UI的主线程中更新画面。 在UI的主线程中更新画面可能会引发问题，比如你更新的时间过长，那么你的主UI线程就会被你正在画的函数阻塞。那么将无法响应按键、触屏等消息。当使用SurfaceView由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要SurfaceView中thread处理，一般就需要有一个event queue的设计来保存touchevent，这会稍稍复杂一点，因为涉及到线程安全。 19.标签 merge和include Android ViewStub的基本使用 简言之，都是用来解决重复布局的问题，但是标签能够在布局重用的时候减少UI层级结构。viewStub标签是用来给其他的View事先占据好位置，当需要的时候用inflater()或者是setVisible()方法显示这些View。 20.ANR排错1、ANR排错一般有三种类型 1. KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应 2. BroadcastTimeout(10 secends) –BroadcastReceiver在特定时间内无法处理完成 3. ServiceTimeout(20 secends) –小概率事件 Service在特定的时间内无法处理完成 2、如何避免 1. UI线程尽量只做跟UI相关的工作 2. 耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理 3. 尽量用Handler来处理UIthread和别的thread之间的交互 3、如何排查 1. 首先分析log 2. 从trace.txt文件查看调用stack，adb pull data/anr/traces.txt ./mytraces.txt 3. 看代码 4. 仔细查看ANR的成因(iowait?block?memoryleak?) 4、监测ANR的Watchdog 21.fragment生命周期 ================================== 常见面试问题 ===================================== 1、横竖屏切换时候Activity的生命周期1. 不设置Activityd饿android:configChanges时，切屏会重新掉哟过各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2. 设置Activity的android:configChanges=”orientation”时，切屏还是会调用各个生命周期，切换横竖屏只会执行一次 3. 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 2、OOM(图片相关的)怎么处理?Android 内存溢出解决方案（OOM） 整理总结 1. 在内存引用上做些处理，常用的有软引用、弱引用 2. 在内存中加载图片时直接在内存中作处理，如：边界压缩 3. 动态回收内存 4. 优化Dalvik虚拟机的堆内存分配 5. 自定义堆内存大小 3、界面优化Android开发——性能优化之如何防止过度绘制 太多重叠的背景(overdraw) 这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。 太多重叠的View 第一个建议是 ：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认是不可见的视图，可以动态的加载一个布局，只要你用到这个重叠着的View的时候才加载，推迟加载的时间。 第二个建议是：如果使用了类似Viewpager＋Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态的Inflation view，它的性能要比SetVisibility好。 复杂的Layout层级 这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。第二个建议是：用标签来合并布局。第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。 4、移动端获取网络数据优化的几个点1. 连接复用：节省连接建立时间，如开启 keep-alive。 对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug， 具体可见：Android HttpURLConnection及HttpClient选择 2. 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。 3. 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 2.0)。 4. 返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。 （也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了） 5. 根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多） 奇迹这个世界每天都有奇迹信不信在你只是发生在你身上的奇迹几乎没有这便是为什么你要努力 for(int 努力 = 0; 努力 &lt; 奇迹.length; 努力++){ if(努力 == 奇迹.length) return success; else return again; } 努力没有失败学习Android，突破自己，一年一总结，我是要当CTO的男人。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/13/进阶系列之年中总结——我的2016/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列之图片缓存技术]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[Android 三大图片缓存原理、特性对比从总体设计和原理上对几个图片缓存进行对比，简单了解他们在某些特性上的实现。 一. 四大图片缓存基本信息Universal ImageLoader是很早开源的图片缓存，在早期被很多应用使用。 Picasso是 Square 开源的项目，且他的主导者是 JakeWharton，所以广为人知。 Glide是 Google 员工的开源项目，被一些 Google App 使用，在去年的 Google I/O 上被推荐，不过目前国内资料不多。 Fresco是 Facebook 在今年上半年开源的图片缓存，主要特点包括： (1) 两个内存缓存加上 Native 缓存构成了三级缓存 (2) 支持流式，可以类似网页上模糊渐进式显示图片 (3) 对多帧动画图片支持更好，如 Gif、WebP 鉴于 Fresco 还没发布正式的 1.0 版本，同时一直没太多时间熟悉 Fresco 源码，后面对比不包括 Fresco，以后有时间再加入对比。 更多图片缓存库可见：Android 图片缓存库 二、基本概念在正式对比前，先了解几个图片缓存通用的概念： (1) RequestManager：请求生成和管理模块 (2) Engine：引擎部分，负责创建任务(获取数据)，并调度执行 (3) GetDataInterface：数据获取接口，负责从各个数据源获取数据。比如 MemoryCache 从内存缓存获取数据、DiskCache 从本地缓存获取数据，下载器从网络获取数据等。 (4) Displayer：资源(图片)显示器，用于显示或操作资源。比如 ImageView，这几个图片缓存都不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。 (5) Processor 资源(图片)处理器负责处理资源，比如旋转、压缩、截取等。 以上概念的称呼在不同图片缓存中可能不同，比如 Displayer 在 ImageLoader 中叫做 ImageAware，在 Picasso 和 Glide 中叫做 Target。 三、共同优点 使用简单都可以通过一句代码可实现图片获取和显示。 可配置度高，自适应程度高图片缓存的下载器(重试机制)、解码器、显示器、处理器、内存缓存、本地缓存、线程池、缓存算法等大都可轻松配置。自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。 多级缓存都至少有两级缓存、提高图片加载速度。 支持多种数据源支持多种数据源，网络、本地、资源、Assets 等 支持多种 Displayer不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。 其他小的共同点包括支持动画、支持 transform 处理、获取 EXIF 信息等。 四、ImageLoader 设计及优点 总体设计及流程 上面是 ImageLoader 的总体设计图。整个库分为 ImageLoaderEngine，Cache 及 ImageDownloader，ImageDecoder，BitmapDisplayer，BitmapProcessor 五大模块，其中 Cache 分为 MemoryCache 和 DiskCache 两部分。 简单的讲就是 ImageLoader 收到加载及显示图片的任务，并将它交给 ImageLoaderEngine，ImageLoaderEngine 分发任务到具体线程池去执行，任务通过 Cache 及 ImageDownloader 获取图片，中间可能经过 BitmapProcessor 和 ImageDecoder 处理，最终转换为Bitmap 交给 BitmapDisplayer 在 ImageAware 中显示。 ImageLoader 优点 (1) 支持下载进度监听 (2) 可以在 View 滚动中暂停图片加载 通过 PauseOnScrollListener 接口可以在 View 滚动中暂停图片加载。 (3) 默认实现多种内存缓存算法 这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。 (4) 支持本地缓存文件名规则定义 五、Picasso 设计及优点总体设计及流程上面是 Picasso 的总体设计图。整个库分为 Dispatcher，RequestHandler 及 Downloader，PicassoDrawable 等模块。 Dispatcher 负责分发和处理 Action，包括提交、暂停、继续、取消、网络状态变化、重试等等。 简单的讲就是 Picasso 收到加载及显示图片的任务，创建 Request 并将它交给 Dispatcher，Dispatcher 分发任务到具体 RequestHandler，任务通过 MemoryCache 及 Handler(数据获取接口) 获取图片，图片获取成功后通过 PicassoDrawable 显示到 Target 中。 需要注意的是上面 Data 的 File system 部分，Picasso 没有自定义本地缓存的接口，默认使用 http 的本地缓存，API 9 以上使用 okhttp，以下使用 Urlconnection，所以如果需要自定义本地缓存就需要重定义 Downloader。 Picasso 优点(1) 自带统计监控功能支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。 (2) 支持优先级处理每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。 (3) 支持延迟到图片尺寸计算完成加载(4) 支持飞行模式、并发线程数根据网络类型而变手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4， 4g 为 3，3g 为 2。这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。 (5) “无”本地缓存无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。 六、Glide 设计及优点总体设计及流程上面是 Glide 的总体设计图。整个库分为 RequestManager(请求管理器)，Engine(数据获取引擎)、 Fetcher(数据获取器)、MemoryCache(内存缓存)、DiskLRUCache、Transformation(图片处理)、Encoder(本地缓存存储)、Registry(图片类型及解析器配置)、Target(目标) 等模块。 简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后 Transformation 处理后交给 Target。 Glide 依赖于 DiskLRUCache、GifDecoder 等开源库去完成本地缓存和 Gif 图片解码工作。 Glide 优点(1) 图片缓存-&gt;媒体缓存Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。 (2) 支持优先级处理(3) 与 Activity/Fragment 生命周期一致，支持 trimMemoryGlide 对每个 context 都保持一个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致，并且有对应的 trimMemory 接口实现可供调用。 (4) 支持 okhttp、VolleyGlide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。 (5) 内存友好① Glide 的内存缓存有个 active 的设计从内存缓存中取数据时，不像一般的实现用 get，而是用 remove，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。 ② 内存缓存更小图片Glide 以 url、view_width、view_height、屏幕的分辨率等做为联合 key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小 ③ 与 Activity/Fragment 生命周期一致，支持 trimMemory ④ 图片默认使用默认 RGB_565 而不是 ARGB_888虽然清晰度差些，但图片更小，也可配置到 ARGB_888。 其他：Glide 可以通过 signature 或不使用本地缓存支持 url 过期 七、汇总三者总体上来说，ImageLoader 的功能以及代理容易理解长度都一般。 Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰，一两个小时就能叫深入的了解完。 Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决。 更多图片缓存库可见：Android 图片缓存库 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/08/13/进阶系列之图片缓存技术/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列MVP架构]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8BMVP%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[MVP(Model-View-Presenter)该软件设计架构在Android开发过程中能够分离出项目的业务逻辑代码和视图展现代码，达到解耦模块化的效果。 MVP如何工作：在项目开发时，将系统分为数据模型（Model），视图（View），和Presenter（预处理层）三个部分。 其中 Presenter 作为中间层，从Model层获取数据,进行处理之后,交给View层进行展示. View 只需要展示数据 Model 完成数据的请求处理 各模块具体职责:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进阶系列设计模式]]></title>
      <url>%2F2016%2F08%2F13%2F%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[笔记源于阅读《HeadFirst设计模式》一书 HeadFirst设计模式一、 设计原则1） 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 2） 针对接口编程，而不是针对实现编程。 3） 多用组合，少用继承。 4） 为了交互对象之间的松耦合设计而努力。 二、 设计模式『策略模式』定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 『观察者模式』]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优秀第三方SDK分析-Fresco]]></title>
      <url>%2F2016%2F06%2F20%2F%E4%BC%98%E7%A7%80%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E5%88%86%E6%9E%90-Fresco%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android优化交互-协调布局详解]]></title>
      <url>%2F2016%2F06%2F20%2FAndroid%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%8D%8F%E8%B0%83%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[现如今移动开发对用户交互体验要求越来越高,各式自定义控件,动画层出不穷,不过今天所记录的不是这两块知识,而是基于Support Library库里的CoordinatorLayout-协调布局实现交互的行为。摘录 Android Support Library 原文链接 CoordinatorLayout is intended for two primary use cases: 1. As a top-level application decor or chrome layout 2. As a container for a specific interation with one or more child views 首先解释协调布局最主要两个用途: 1) 作为应用的顶层布局管理器 2) 作为单个子view或者多个子view进行特定交互的容器 在介绍用途之前,需先了解什么是Behavior: 1) Behavior是一个抽象类,是CoordinatorLayout的子view进行行为交互的插件; 2) 行为对象(Behavior)实现了用户子view的一个或多个的交互功能,这些交互包括: 拖曳,侧滑,速滑,以及其他手势。 简单介绍Behavior(基于这个对象是引起view之间交互动作的一个因素,以下称其为行为因子),再看: 在单个父view和那些能相互交互的view之间,通过指定行为因子(Behaviors)就可以为协调布局(CoordinatorLayout)的子view提供很多不同的交互。 当作为协调布局(CoordinatorLayout)的子view使用默认行为(DefaultBehavior)注解时,View类可以指定一个默认的行为因子(behavior) 行为因子(Behaviors)可用来实现各式各样的交互和布局变化,比如侧滑菜单栏、可滑动删除的UI元素,以及跟随其他UI元素移动的按钮等 协调布局(CoordinatorLayout)的子View可能有一个锚点(anchor)).这个子View的id一定对应这个协调布局的一个任意后代(意思是这个id一定被某个view以anchor属性锁定),但是它可能不是锁定的子view本身或者锁定的子view一个后代.这可以被用作放置悬浮视图关联其他任意内容窗格 子view可以指定边缘镶嵌(insetEdge:一个重力值)来描述如何将view嵌入协调布局(CoordinatorLayout)中.通过dodgeInsetEdges属性设置的任一子view是来避免相同的边缘镶嵌,这些被设置的子view将会被适当移动以免视图重叠 以上是支持库中针对原文的一些理解 以下开搞 彻底搞懂 1231、CoordinatorLayout对交互行为本身没有起到太多作用，实现主要依靠其内部类 - Behavior；2、CoordinatorLayout的**直接子View**绑定一个Behavior，这个Behavior会拦截发生在这个View上的Touch事件、嵌套滚动等等。3、Behavior还可以拦截对与它绑定的View的测量及布局 深入理解Behavior 拦截Touch事件 CoordinatorLayout事实上重写了onInterceptTouchEvent()方法，如下1234567891011121314151617181920212223@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); // Make sure we reset in case we had missed a previous important event. if (action == MotionEvent.ACTION_DOWN) &#123; resetTouchBehaviors(); &#125; final boolean intercepted = performIntercept(ev, TYPE_ON_INTERCEPT); if (cancelEvent != null) &#123; cancelEvent.recycle(); &#125; if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123; resetTouchBehaviors(); &#125; return intercepted; &#125; 可以看出，在按下的事件中有方法resetTouchBehaviors()，这样就为Behavior提供了先于View处理Touch事件的条件。再考虑到CoordinatorLayout是应用的顶层布局管理器，所以它的拦截方法内部是会遍历所有直接子View的，对于绑定了Behavior属性的直接子View，它会调用Behavior的onInterceptTouchEvent()方法，如果返回true，那后续本该由View处理的Touch事件都会交由Behavior处理。那么该由什么条件来判断是否返回true呢？就是通过下面这重写方法判断1234@Overridepublic boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123; return super.layoutDependsOn(parent, child, dependency);&#125; 判断是否有依赖对象(dependent view),默认返回的是false如果有则返回true,这个依赖的view可以视为被观察者,一般通过操作符instanceof来进行dependency判断是否是某个特定类的实例 而下面这个重写方法，是当dependent view(被观察者) 发生变化时child(观察者)做出响应的方法1234@Overridepublic boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123; return super.onDependentViewChanged(parent, child, dependency);&#125; ☆ layoutDependsOn()方法在界面布局时至少会被调用一次；☆ layoutDependsOn()方法是用来确定dependent view 的；☆ 页面渲染(初始化未经手势操作)时就会依次执行这两个方法，只要观察者child设置的Behavior在覆写layoutDependsOn()方法时返回true；☆ 如果layoutDependsOn()方法返回false，onDependentViewChanged()方法是不会执行的。 拦截测量及布局 同样，在Behavior处理有没拦截Touch事件时，也一并重写了测量onMeasure()及布局onLayout()方法onMeasure()方法如下:1234567891011121314151617181920212223242526@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; prepareChildren(); ensurePreDrawListener(); //根据需要添加或者删除预绘制监听器 ... ... //省略 主要是获取padding,ViewCompat属性,view宽高,等等 final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); ... ... //省略 主要是对子View的布局测量模式讨论及设值 final Behavior b = lp.getBehavior(); if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0)) &#123; onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0); &#125; ... ... //处理计算得出子View的widthUsed, heightUsed及childState &#125; ... ... //重新计算宽高 setMeasuredDimension(width, height);&#125; 1、prepareChildren()方法会先遍历所有直接子View 2、若该子View绑定了Behavior，就会调用相应的onMeasureChild()方法12345public boolean onMeasureChild(CoordinatorLayout parent, V child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; return false;&#125; 如果这个方法返回true,那么CoodinatorLayout就不会测量该View,从而由Behavior接管测量同样布局也是如此！ View依赖关系确定 交互过程中两个View的主从关系确认child - 做出响应的个体dependent view - child依赖的View 显式依赖: 为child绑定一个Behavior, 覆写layoutDependsOn()方法，即当传入的dependency为dependent view时返回true，以此建立child和dependent view的依赖关系。 隐式依赖: 通过anchor属性来确立。把child的layout_anchor属性设置为dependent view 的id，然后设置child的layout_anchorGravity属性，这个属性是用来当dependent view变化时做出怎样的响应的。 无论显式还是隐式，当dependent view发生变化时，Behavior类中onDependentViewChanged()方法都会被调用。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/06/20/Android优化交互-协调布局详解/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android优化交互-嵌套机制详解]]></title>
      <url>%2F2016%2F06%2F20%2FAndroid%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio之Plugins]]></title>
      <url>%2F2016%2F06%2F14%2FAndroidStudio%E4%B9%8BPlugins%2F</url>
      <content type="text"><![CDATA[插件会持续整理 … 现在Android开发说不用AndroidStudio恐怕真的很少，甚至你在开发群里抛问题截图带Eclipse都会被大伙嘲讽一通，不得不说这是Google一个明智的决定，弃用ES拥抱AS。这里面对于新的IDE，有针对的使用IDE Plugins能快速提高开发效率。不想偷懒的程序猿不是一个好程序猿 以下是开发中亲历亲测可用的一些插件, 整理如下: ☆ 注: 插件需先下载 Ctrl+Alt+S -&gt; Plugins -&gt; Browse repositories -&gt; 安装 -&gt; restart AS环境：win10 OS GsonFormat此货排第一,应该无异议吧能快速将json转换为Java Bean使用方法: 快捷键Alt+S/Fn+Alt+Insert -&gt; GsonFormat Android ButterKnife Zelezny对于无ButterKnife不开发的我来说,这个也是必用的配合黄油刀, 解放双手, 哪有那么多控件绑定要你写使用方法: 快捷键Fn+Alt+Insert -&gt; Generate Butterknife Injections Android Code Generator根据布局文件快速生成对应的Activity、Fragment、Adapter、Menu使用方法: 右键 -&gt; Generate Android Code -&gt; select Android Parcelable code generatorJavaBean序列化，快速实现Parcelable接口使用方法: 快捷键Fn+Alt+Insert -&gt; Parcelable Android Methods Count显示依赖库中的方法数 Lifecycle Sorter根据Activity或Fragment的生命周期对其覆写的生命周期方法位置进行先后排序 CodeGlance→_→预览程序代码，实现快速定位 findBugs-IDEA查找bug的插件Android Studio也提供了代码审查的功能（Analyze-Inspect Code…） ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI JsonOnlineViewerAndroid Studio中请求、调试接口插件 Android Styler根据xml自动生成style插件 Android Drawable Importer图片导入插件(导入图片的各种dpi对应的图片) SelectorChapek for Android通过资源文件名自动生成selector文件 GenerateSerialVersionUID实现Serializable序列化Bean Genymotion手机模拟器 Android Postfix Completion根据后缀快速生成代码 Android Holo Colors Generator通过自定义Holo主题颜色生成对应的Drawable和布局文件 GradleDependenciesHelperPluginmaven gradle 依赖支持自动补全 ,jar包下载地址 RemoveButterKnife去除黄油刀注解的代码,恢复findViewById()真身 AndroidProguardPlugin一键生成项目混淆代码插件, jar包下载地址 otto-intellij-pluginotto事件导航工具, jar包下载地址 eventbus-intellij-plugineventbus导航插件, jar包下载地址 idea-markdownmarkdown插件, 参考链接https://github.com/vsch/idea-multimarkdown Sexy Editor设置AS代码编辑区的背景图 folding-plugin布局文件分组的插件 Android-DPI-CalculatorDPI计算插件 , 参考链接https://plugins.jetbrains.com/plugin/7832使用：或者 gradle-retrolambda在java 6 7中使用 lambda表达式插件, 修改编译的jdk为java8参考链接https://github.com/evant/gradle-retrolambda Android Studio Prettify可以将代码中的字符串写在string.xml文件中 Material Theme UIMaterial主题插件 .ignore过滤不想提交的文件 CheckStyle-IDEA检查代码风格的插件 Markdown NavigatorMarkdown插件 ECTranslation翻译插件 PermissionsDispatcher plugin自动生成6.0权限的代码 WakaTime记录在IDE上工作时间的插件 AndroidWiFiADB无线调试应用插件 AndroidLocalizationer用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/06/14/AndroidStudio之Plugins/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio之Gradle]]></title>
      <url>%2F2016%2F06%2F07%2FAndroidStudio%E4%B9%8BGradle%2F</url>
      <content type="text"><![CDATA[Gradle 概述是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – Groovy) 编写而成，再加上DSL（领域特定语言）组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。 analysis in ASAndroid Studio新建一个工程后，默认生成两个build.gralde文件，一个位于project根目录下，一个位于app目录下。除此还有一个文件settings.gradle。 根目录下的脚本文件是针对module的全局配置，它的作用域内包含的所有 module 是通过settings.gradle来配置。app文件夹就是一个module，如果在当前project中新增Module – library，就要在settings.gralde文件中包含这个新的module。 当然很多朋友我相信在新建项目以及库的时候更多是通过右键建立的，这样更加方便，但要知晓其中的原理，对于熟悉gradle构建系统来说是不可或缺的。 gradle脚本的基本结构用新建工程为例，根目录的build.gradle的内容如下所示：1234567891011121314151617181920212223// Top-level build file where you can add configuration options common to all sub-projects/modules. buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; allprojects &#123; repositories &#123; jcenter(） &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 然后是 settings.gradle 文件：1include ':app' app就是应用程序的一个module，如果有多个module，可以在为 include 方法添加多个参数，并以逗号隔开。 最后是app/build.gradle 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061apply plugin: 'com.android.application' android &#123; compileSdkVersion 23 buildToolsVersion "23.0.3" compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125; defaultConfig &#123; applicationId "app full name" minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName "1.0.0" &#125; signingConfigs &#123; release &#123; storeFile file('release.keystore') storePassword "yourstorepassword" keyAlias "yourkeyalias" keyPassword "yourkeypassword" &#125; debug &#123; storeFile file('debug.keystore') &#125; &#125; buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release &#125; debug &#123; signingConfig signingConfigs.debug &#125; &#125; productFlavors &#123; market &#123; Wandoujia &#123;&#125; ... &#125; &#125;&#125; repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.4.0'&#125; Groovy 的基本语法方法调用1apply plugin: 'com.android.application' 以上语句中的apply是一个方法，给它传递了一个参数plugin，plugin 的值是’com.android.application’。 如果有多个参数，则以逗号隔开，例如1compile name: 'supertoasts', ext: 'aar' 闭包 Groovy中花括号包含的部分成为一个闭包（Closure）。例如下面的代码1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7&#125; compileOptions 是一个 Method， 它的参数是一个闭包， 这个闭包内依次执行了两个方法 – sourceCompatibility 和targetCompatibility， 参数都是JavaVersion.VERSION_1_7,即是你jdk配置环境所使用的版本。 闭包也可以嵌套包含12345repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; 常见使用方法包依赖（aar）使用aar时可以分为两种情况① aar位于本地目录 首先在 Build.gradle(Module:app) 中 android 的参数闭包中添加调用方法 repositories12345repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; 然后在 dependencies 的参数闭包中添加1compile name: 'supertoasts', ext: 'aar' ② aar位于远程仓库 这里以maven为例，当然也可以使用其他类型的仓库，例如 Ivy、Bintray。 只需要在jar包引用方式后面添加一个@aar就可以了1compile 'com.github.johnpersano:supertoasts:1.3.4@aar' 包依赖（jar）1compile group:'com.github.johnpersano',module: 'supertoasts',version: '1.3.4' 可以简写成1compile 'com.github.johnpersano:supertoasts:1.3.4' 去掉重复依赖123compile 'com.github.johnpersano:supertoasts:1.3.4' &#123; exclude module: 'annotations', group: 'com.google.android'&#125; 使用 Java7 或者 Java81234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7&#125; 针对JDK1.8, 等公司项目上线我会专门看一些这方面的资料进行博客整理，主要对RetroLambda结合RxJava的一些功能展示及Sourcecode理解 productFlavors（渠道打包）该部分在项目完成上线之前，会将所看资料整合另开一篇文章说明。 总结其实在使用Gradle构建时，如果项目引用的依赖过于多而杂，而又需要考虑到这些依赖版本的更新问题，参考过MarkZhai的博客,本人也偏向于新建全局gradle，专门用于管理版本的迭代问题，不用一处改处处改，效果在试过之后会能明显feel到。 刚来新公司，一个人负责项目从零起步到最后打包上线，不得不说，这是一个挑战，但这又何尝不是一个机会，目前还处于app开发阶段。在抛弃前公司一直沿用的Volley Network Framework之后，我一直在尝试着使用更多以前未接触过的技术，RxJava，Dagger，OkHttp+Retrofit，Stetho+GsonFormat and so on，包括这次的关于Gradle的博客书写，发现Gradle其实也蛮好（zhuang）用(bi)的！当然用这些新技术需要花不少的时间成本，但“ 总有人要赢的，那个人为什么不是我 ”， 爱豆科比的经典名言啊。努力 奋斗 致每一位正在努力的小婊砸 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/06/07/AndroidStudio之Gradle/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android部落格之RxJava框架]]></title>
      <url>%2F2016%2F06%2F07%2FAndroid%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRxJava%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[基本概念a library for composing asynchronous and event-based programs using observable sequences for the Java VM 一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库 Observables(被观察者/事件源) ———–&gt; 发出事件 Subscribers(观察者) ————————–&gt; 订阅接收,进行处理 类似观察者模式,不同之处在于： 如果没有Subscribers，Observables是不会发出任何事件。 更接近于观察者模式 + 迭代器模式 , 这样的模式组合可以确保每一个事件都能发送到Subscribers上进行处理。 不过与迭代器模式不同之处在于 ： 迭代器模式在事件处理上采用的是“同步/拉式”的方式，而Observable采用的是”异步/推式”的方式 基本实现创建Observer可以通过两种方式进行观察者对象的创建: Observer 和 Subscriber Observer&lt;Strting&gt; observer = new Observer&lt;String&gt;(){ @override public void onNext(String s){ //todo } @override public void onCompleted(){ //todo } @override public void onError(Throwable e){ //todo } } 或 Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;(){ @override public void onNext(String s){ //todo } @override public void onCompleted(){ //todo } @override public void onError(){ //todo } } 区别: (1) onStart() 这是Subscriber增加的方法,会在事件未发送之前被调用,该方法是可选方法。需记住该方法所在的线程和subscribe 所发生的线程是一致的。 (2) unsubscribe() 这是Subscriber所实现的另一个接口方法,用于取消订阅.该方法被调用后,Subscriber不再接收任何事件,一般 在此方法调用前,先进行isUnsubscribed()判断一下.这个方法的重要性在于能有效降低Observable持有Subscriber的引用而造 成的内存泄漏问题 创建ObservableObservable observable = Observable.create( new Observable.OnSubscribe&lt;String&gt;(){ @override public void call(Subscriber&lt;? super String&gt; subscriber){ subscriber.onNext(); subscriber.onNext(); subscriber.onNext(); subscriber.onCompleted(); } } ); 这里传入一个OnSubscribe对象作为参数,该对象会被存储在返回的Observable对象中.它的作用类似于一个计划表，当Observable被订阅时，OnSubscribe的call()方法会自动被调用，事件序列会依照设定顺序依次触发。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 这里create()方法是RxJava最基本的创造事件序列的方法.当然也还有其他快捷创建事件序列方式，如下： just(T…) 将传入的参数依次发送出来Observable observable = Observable.just(&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;); // 将会依次调用: // onNext(&quot;AA&quot;); // onNext(&quot;BB&quot;); // onNext(&quot;CC&quot;); // onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;) 将传入的数组或Iterable拆分成具体的对象后,依次发送出来String[] words = {&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;}; Observable observable = Observable.from(words); // 将会依次调用: // onNext(&quot;AA&quot;); // onNext(&quot;BB&quot;); // onNext(&quot;CC&quot;); // onCompleted(); 以上两种方式都和create()方式是等价的 订阅Subscribe创建了Observable 和 Observer对象之后，用subscribe()方法将其联结, 整条链子就能执行工作。代码如下： observable.subscribe(observer); // 或者 observable.subscribe(subscriber); 内部代码实现 public Subscription subscribe(Subscriber subscriber){ subscriber.onStart(); onSubscribe.call(subscriber); return subscriber; } subscriber()主要负责三件事: 1) 调用Subscriber.onStart() ————— 这个方法之前描述过,是一个可选方法 2) 调用Observable的OnSubscribe.call(Subscriber) ————— 这里事件的发送逻辑开始执行，从这里看出，在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在被订阅时，即当subscribe()方法执行的时候发送。 3) 将传入的Subscriber作为Subscription返回 ————— 这是为方便unsubscribe()。 除了subscribe(Observable) 和 subscribe(Subscriber) , subscribe() 还支持不完整定义的回调,RxJava会自动根据定义创建出Subscriber。形式如下： Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;(){ // onNext() @override public void call(String s){ //todo } }; Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;(){ //onError @override public void call(Throwable e){ //todo error handling } }; Action0 onCompletedAction = new Action0(){ //onCompleted() @override public void call(){ //todo } } // 自动创建 Subscriber, 并使用 onNextAction 来定义 onNext() observable.subscribe(onNextAction); // 自动创建 Subscriber, 并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError() observable.subscribe(onNextAction, onErrorAction); // 自动创建 Subscriber, 并使用 onNextAction 、 onErrorAction 和 onCompletedAction 来定义 onNext() 、 onError() 和 onCompleted() observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 注: Action0 是RxJava的一个接口，它只有一个call()，这个方法是无参无返回值的； onCompleted()方法也是无参无返回值，因此Action0 可以被当成是一个包装对象; Action1 也是一个接口,也只有一个call(T param), 这个方法也没有返回值, 但有参数； onNext(obj)方法 和 onError(error) 方法 均可以被当成是一个包装对象 线程控制 - Scheduler在不指定线程的情况下, RxJava遵循的是线程不变的原则, 即: 在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如需切换线程，就需要Scheduler(调度器) Scheduler APIScheduler － 调度器，相当于线程控制器，RxJava通过它来指定每一段代码应该运行在哪一个线程中。RxJava内置了一些Scheduler，适用场景如下： Schedulers.immediate(): 直接在当前线程中运行，默认的Scheduler Schedulers.newThread(): 总是启用新线程,并在新线程中执行操作 Schedulers.io: I/O操作(读写文件、读写数据库、网络信息交互等)所使用的Scheduler；类似于newThread()，区别在io()的内部实现是使用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。记住：不要把计算放在io()中，可以避免创建不必要的线程。 Schedulers.computation(): 计算Scheduler。这个计算指CPU密集型计算，即不会被I/O等操作限制性能的操作，比如图形的计算。该Scheduler使用固定的线程池，大小为CPU核数。切记，不要把I/O操作放在computation()中,否则I/O操作的等待时间会浪费CPU。 另外Android还有一个专用的AndroidSchedulers.mainThread()，它指定的操作将在Android主线程中运行。 有了上述Scheduler，就可以使用subscribeOn() 和 observerOn() 来控制线程。 subscribeOn(): 指定subscribe()所发生的线程，即Observable.OnSubscribe 被激活时所在的线程/事件产生的线程。 observeOn(): 指定Subscriber所运行的线程/事件消费的线程。 示例Observable.just(1,2,3,4) .subscribeOn(Schedulers.io()) // 指定 subscribe()发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定Scheduler 的回调发生在主线程中 .subscribe(new Action1&lt;Integer&gt;(){ @override public void call(Integer number){ //todo } }); 这种在subscribe()之前写上线程控制的多适用于 『后台线程取数据，主线程显示』的程序策略。 Scheduler 原理TBD。。。 变换RxJava提供了对事件序列进行变换的支持 所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 （1）API首先看map()示例: Observable.just(&quot;image/ic_launcher.png&quot;) // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;(){ @override public Bitmap call(String filePath){ // 参数类型 Strting return getBitmapFromPath(filePath); // 返回类型 } }) .subscribe(new Action1&lt;Bitmap&gt;(){ @override public void call(Bitmap bitmap){ // 参数类型 Bitmap showBitmap(bitmap); } }); 注 类Func1，也是RxJava的一个接口，用于包装含有一个参数的方法。 FuncX 和 ActionX 区别，FuncX包装的是有返回值的方法 （2）常用变换 map() —————– 事件对象的直接变换，是RxJava最为常用的变换 flatMap()————– 事件对象的扁平变换，是map()的升级版 解释: 将Observable发射的数据变换为Observables集合,然后将Observab发射的数据 『铺平化』放进一个单独的Observable中。 可以理解为将嵌套的数据结构展开的过程。 map() 和 flatMap() 区别: 相同: 均可以把传入的参数转化之后返回另一个对象 不同: flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到Subscriber的回调方法中。 flatMap() 原理 1、 利用传入的事件对象创建一个Observable对象 2、 不发送这个Observable对象，而是将其激活，再开始发送事件 3、 每一个创建出来的Observable发送的事件，都被汇总到同一个Observable，再由这个汇总Observable对象负责将这些事件统一交给Subscriber的回调方法 这三个步骤,其实是将事件拆成了两级,通过一组新创建Observable将初始的对象『铺平』之后，通过统一的路径分发下去。 throttleFirst() ——– 在每次事件触发之后的一定时间间隔内丢弃新的事件。 常用作去抖动过滤，例如按钮的点击监听器： RxView.clickEvents(button) .throttleFirst(500, TimeUnitMILLISECONDS) //设置防抖间隔 500ms .subscribe(subscriber); 这样就可以解决手抖出现点开两个重复的界面问题 （3）变换的原理: lift()变换的实质： 针对事件序列的处理和再发送 lift() 内部实现代码 public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator){ return Observable.create(new OnSubscribe&lt;R&gt;(){ @override public void call(Subscriber subscriber){ Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); } }); } 分析： 生成一个新的Observable并返回，且新创建的Observable所用的参数OnSubscribe的回调方法call()中的onSubscribe.call(subscribe)中的onSubscribe所指代的对象不同。 subscribe()中onSubscribe指的是Observable中的onSubscribe对象,但是lift()之后对象就不一样; 当含有lift()时： 1. lift()创建了一个Observable后，加上原Observable对象，就有两个Observable； 2. 新Observable里的新OnSubscribe加上原Observable中的OnSubscribe，也就有两个OnSubscribe; 3. 当用户调用经过lift()后的Observable的subscribe()时候,使用的是lift()所返回的新的Observable, 于是它所触发的onSubscribe.call(subscribe)，也是用的新Observable中的OnSubscribe，即在lift()中生成的那个Observable; 4. 而这个新OnSubscribe的call()方法中的onSubscribe，就是指的原始Observable中的原始OnSubscribe， 在这个call()方法里，新OnSubscribe利用operator.call(subscribe)生成一个新的Subscriber (operator就是在这里，通过自己的call()方法将新Subscribe和原始Subscriber进行关联，并插入自己的『变换』代码来实现变换)， 接着利用这个新Subscriber向原始Observable进行订阅。 这样就实现lift()过程，比较像代理机制，通过事件拦截和处理实现事件序列的变换。 换种方式理解： 在Observable执行了lift(Operator)方法之后，会返回一个新的Observable， 这个新的Observable会向代理一样， 负责接收原始的Observable发出的事件，并在处理之后发送给Subscriber。 未完待续。。。 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/06/07/Android部落格之RxJava框架/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android部落格之Retrofit框架]]></title>
      <url>%2F2016%2F06%2F02%2FAndroid%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRetrofit%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android部落格之OkHttp框架]]></title>
      <url>%2F2016%2F06%2F01%2FAndroid%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BOkHttp%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[来自OkHttp官方网站 整体流程图-参考 OkHttp 官网概述：Android和Java应用程序的HTTP&amp;HTTP/2的客户端 简单使用1、创建OkHttpClint对象OkHttpClient client = new OkHttpClient(); 当然也可以通过Build构造自定义的Http客户端 2、发起HTTP请求String run() throws IOException{ Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } OkHttpClient实现了Call.Factory, 它是负责创建HTTP请求,负责根据请求创建新的Call,代码如下: /** * Prepares the {@code request} to be executed at some point in the future. */ @override public Call newCall(Request request){ return new RealCall(this,request); } 下面针对RealCall,分情况研究: 2.1 同步网络请求@override public Response execute() throws IOException{ synchronized(this){ if(executed) -------------------------------------------------------------(1) throws new IllegalStateException(&quot;Already Exceuted&quot;); executed = true; } try{ client.dispatcher().exedcuted(this); -------------------------------------(2) Response result = getResponseWithInterceptorChain(); ---------------------(3) if(result == null) throws new IOException(&quot;Canceled&quot;); return result; }finally{ client.dispatcher().finished(this); --------------------------------------(4) } } 步骤分解: (1): 检查这个call是否已经执行过，每个call只能被执行一次 (2): 利用client.dispatcher().executed(this)来实际执行请求 (3): 调用函数获取HTTP响应结果,在这个过程中还会进行一个拦截链操作 (4): 通知dispatcher执行完毕 而真正发出网络请求,解析返回结果的,还是getResponseWithInterceptorChain: private Response getResponseWithInterceptorChain() throws IOException{ //Build a full stack of interceptors List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if(!retryAndFollowUpInterceptor.isForWebSocket()){ interceptors.addAll(client.networkInterceptors()); } interceptors.add( new CallServerInterceptor( retryAndFollowUpInterceptor.isForWebSocket())); Interceptor.Chain chain = new RealInterceptorChain( interceptors,null,null,null,0,originalRequest); return chain.proceed(originalRequest); } Interceptor其实是最核心的一个东西,并非简简单单的拦截器,它把实际的网络请求、缓存等等功能全部统一起来，每个功能都只是一个Interceptor,再连接成一个Interceptor.Chain,最终完成一次圆满的网络请求. 依照上面代码块,Interceptor.Chain的分布: 结构图 1.在配置OkHttpClient时设置的interceptors; 2.负责失败重试以及重定向的RetryAndFollowUpInterceptor; 3.负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的BridgeInterceptor; 4.负责人读取缓存直接返回、更新缓存的CacheInterceptor; 5.负责和服务器建立连接的ConnectInterceptor; 6.配置OkHttpClient时设置的networkInterceptors; 7.负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor. 这里位置决定功能，最后一个Interceptor一定是负责和服务器实现通信的，而重定向、缓存等一定是在通信之前完成。 2.1.1 建立连接:ConnectInterceptor@override public Response intercept(Chain chain) throws IOException{ RealInterceptorChain realChain = (RealInterceptorChain)chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } 建立连接其实就是创建HttpCodec对象,HttpCodec是对HTTP协议操作的抽象,在HttpCodec中,它利用Okio对socket的读写操作进行封装. 2.1.2 发送和接收数据:CallServerInterceptor@override public Response intercept(Chain chain) throws IOException{ HttpCodec httpCodex = ((RealInterceptorChain)chain).httpStream(); StreamAllocation streamAllocation = ((RealInterceptorChain)chain).streamAllocation(); Request request = chain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request); ----------------------------------------------------------(1) if(HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body()!=null){ ---------------------(2) Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); } httpCodec.finishRequest(); Response response = httpCodec.readResponseHeaders() ----------------------------------------------(3) .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); if (!forWebSocket || response.code() != 101) { response = response.newBuilder() -------------------------------------------------------------(4) .body(httpCodec.openResponseBody(response)) .build(); } if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) { streamAllocation.noNewStreams(); } // 省略部分检查代码 return response; } 主要部分: 1.向服务器发送request header; 2.如果有request body，就向服务器发送; 3.读取response header，先构造一个Response对象; 4.如果有response body,就在3的基础上加上body构造一个新的Response对象 2.2 异步网络请求 - 详见Dispatcher.javaclient.newCall(request).enqueue(new Callback(){ @override public void onFailure(Call call, IOException e){ } @override public void onResponse(Call call, Response response) throws IOException{ System.out.println(response.body().string()); } }); //RealCall#enqueue @override public void enqueue(Callback responseCallback){ synchronized(this){ if(executed) throws new IllegalStateException(&quot;Already Executed&quot;); executed = true; } client.dispatcher().enqueue(new AsyncCall(responseCallback)); } //Dispatcher#enqueue synchronized void enqueue(AsyncCall call){ if(runningAsyncCalls.size()&lt;maxRequests &amp;&amp; runningCallForHost(call)&lt;maxRequestsPerHost){ runningAsyncCalls.add(call); executorService().execute(call); }else{ readyAsyncCalls.add(call); } } 此处可以看到dispatcher在异步执行请求过程中的作用.如果当前还能执行一个并发请求,那就立即执行,否则就加入readyAsyncCalls队列,而正在执行的请求执行完毕之后,会调用promoteCalls()函数,来迭代readyAsyncCalls队列,next()出AsyncCall,并将AsyncCall加入到runningAsyncCalls队列中,开始执行. AsyncCall是RealCall的一个innerClass,继承NamedRunnable抽象类,该抽象类实现了Runnable接口,功能是设置线程名称.所以AsyncCall其实就是被OkHttp命名规范的一个异步请求类,它可以被提交到ExecutorService上执行,在执行时会调用getResponseWithInterceptorChain()函数,并将结果通过responseCallback回调传递给上层使用. 如此,同步和异步其实原理是一样的,都是在getResponseWithInterceptorChain()函数中通过Interceptor链来实现网络请求逻辑,而异步则是通过ExecutorService来实现的. 3、获取响应数据在同步(Call#execute()执行之后)或者异步(Callback#onResponse()回调中)请求完成之后,可以从Respouse对象中华获取到响应数据,包括HTTP status code, status message, response header, response body等等.这里的body需通过数据流方式来进行访问。 响应body被封装到 ResponseBody类中,需注意亮点: 1) 每个body只能被消费一次,多次消费会抛出异常; 2) body必须被关闭,否则会发生资源泄漏 4、HTTP缓存在建立连接、和服务器通信之前，就是CacheInterceptor,在建立连接之前,我们检查响应是否已经被缓存、缓存是否可用，如果是则直接返回缓存的数据，否则就进行后面的流程，并在返回之前，把网络的数据写入缓存中。 CacheInterceptor类里主要逻辑都在覆写的intercept方法里,通过缓存策略获取networkRequest和cacheResponse进行检查判断,也可以通过实现InternalCache接口,在构造OkHttpClient时进行设置,这样就可以自定义缓存策略了。 Summary 友情提醒 如果有任何疑问，请留言或者找到我的联系方式进行联系我，希望文章对你有所帮助！ 本文永久链接：http://tufusi.com/2016/06/01/Android部落格之OkHttp框架/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十里平湖霜满天]]></title>
      <url>%2F2016%2F05%2F31%2F%E5%8D%81%E9%87%8C%E5%B9%B3%E6%B9%96%E9%9C%9C%E6%BB%A1%E5%A4%A9%2F</url>
      <content type="text"></content>
    </entry>

    
  
  
</search>
