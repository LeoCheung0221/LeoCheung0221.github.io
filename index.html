<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="OnePiece" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="做人如果没有梦想,那和咸鱼有什么分别">
<meta property="og:type" content="website">
<meta property="og:title" content="OnePiece">
<meta property="og:url" content="http://tufusi.com/index.html">
<meta property="og:site_name" content="OnePiece">
<meta property="og:description" content="做人如果没有梦想,那和咸鱼有什么分别">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OnePiece">
<meta name="twitter:description" content="做人如果没有梦想,那和咸鱼有什么分别">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> OnePiece - 做人如果没有梦想,那和咸鱼有什么分别 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">OnePiece</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Some of life, you have to go to the great challanges. - By Kobe Bryant</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-drygoods">
          <a href="/drygoods" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            menu.drygoods
          </a>
        </li>
      

      

	  <li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
    function c() {
        var e = document.createElement("link");
        e.setAttribute("type", "text/css");
        e.setAttribute("rel", "stylesheet");
        e.setAttribute("href", f);
        e.setAttribute("class", l);
        document.body.appendChild(e)
    }

    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t < e.length; t++) {
            document.body.removeChild(e[t])
        }
    }

    function p() {
        var e = document.createElement("div");
        e.setAttribute("class", a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }

    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }

    function v(i) {
        var s = d(i);
        return s.height > e && s.height < n && s.width > t && s.width < r
    }

    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }

    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e && !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }

    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }

    function E(e) {
        var t = m(e);
        return t >= w && t <= b + w
    }

    function S() {
        var e = document.createElement("audio");
        e.setAttribute("class", l);
        e.src = i;
        e.loop = false;
        e.addEventListener("canplay", function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e < O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener("ended", function() {
            N();
            h()
        }, true);
        e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
        document.body.appendChild(e);
        e.play()
    }

    function x(e) {
        e.className += " " + s + " " + o
    }

    function T(e) {
        e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
    }

    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp("\\b" + s + "\\b");
        for (var n = 0; n < e.length; ) {
            e[n].className = e[n].className.replace(t, "")
        }
    }

    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
    var s = "mw-harlem_shake_me";
    var o = "im_first";
    var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
    var a = "mw-strobe_light";
    var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
    var l = "mw_added_css";
    var b = g();
    var w = y();
    var C = document.getElementsByTagName("*");
    var k = null;
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn("Could not find a node of the right size. Please try a different page.");
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
    })()    '>High一下</a> </li>
    </ul>
  

  
</nav>
 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之求职路漫漫/" itemprop="url">
                  进阶系列之求职路漫漫
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:28:17+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之求职路漫漫/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之求职路漫漫/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="国内一线互联网公司内部面试题库"><a href="#国内一线互联网公司内部面试题库" class="headerlink" title="国内一线互联网公司内部面试题库"></a>国内一线互联网公司内部面试题库</h1><p>以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库</p>
<p>熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。</p>
<p>欢迎一线公司员工提交内部面试题库，欢迎star。</p>
<p>###一、java基础</p>
<p><strong>1.接口的意义</strong>（百度）</p>
<p>规范、扩展、回调</p>
<p><strong>2.抽象类的意义</strong>（乐视）</p>
<p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>
<p><strong>3.内部类的作用</strong>(百度，乐视)</p>
<ol>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>
</ol>
<p><strong>4.父类的静态方法能否被子类重写，为什么？</strong>（猎豹）</p>
<p>不能</p>
<p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现</p>
<p><strong>5.举1-2个排序算法，并使用java代码实现</strong>（美团）</p>
<p><a href="http://blog.csdn.net/qy1387/article/details/7752973" target="_blank" rel="external">排序算法总结</a></p>
<p><strong>6.列举java的集合和继承关系</strong>（百度、美团）</p>
<p><img src="https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/collection.png" alt=""></p>
<p><strong>7.java虚拟机的特性</strong>（百度、乐视）</p>
<p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<p><strong>8.哪些情况下的对象会被垃圾回收机制处理掉</strong>（乐视、美团、小米）</p>
<p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>
<p><strong>9.进程和线程的区别</strong>（猎豹）</p>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p>
<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p>
<p><strong>10.Java中==和equals的区别，equals和hashCode的区别</strong>（乐视）</p>
<p><a href="http://blog.csdn.net/tiantiandjava/article/details/46988461" target="_blank" rel="external">区别</a></p>
<p><strong>11.常见的排序算法时间复杂度</strong>（小米）</p>
<p><img src="https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/algorithm.png" alt=""></p>
<p><strong>12.HashMap的实现原理</strong>（美团）</p>
<pre><code>1. HashMap概述：
      HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 
2. HashMap的数据结构：
   在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
</code></pre><p><img src="https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/hashmap.jpg" alt=""></p>
<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>
<p><strong>13.java 状态机</strong></p>
<p><a href="http://www.jdon.com/designpatterns/designpattern_State.htm" target="_blank" rel="external">状态机</a></p>
<p><strong>14.java中int char long各占多少字节数</strong></p>
<p>byte 位数 8 字节数 1</p>
<p>short 16 2</p>
<p>int 32 4</p>
<p>long 64 8</p>
<p>float 32 4</p>
<p>double 64 8</p>
<p>char 16 2</p>
<p><strong>15.java int与integer的区别</strong></p>
<p><a href="http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html" target="_blank" rel="external">区别</a></p>
<p><strong>16.string stringbuffer stringbuilder 区别</strong>（小米、乐视、百度）</p>
<p>String 字符串常量</p>
<p>StringBuffer 字符串变量（线程安全）</p>
<p>StringBuilder 字符串变量（非线程安全）</p>
<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<p>String S1 = “This is only a” + “ simple” + “ test”;</p>
<p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p>
<p>在大部分情况下 StringBuffer &gt; String</p>
<p>StringBuffer</p>
<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>
<p>java.lang.StringBuilder</p>
<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p>
<p><strong>17.Java多态</strong>（乐视）</p>
<p>Java多态性理解</p>
<p>Java中多态性的实现</p>
<p>什么是多态</p>
<p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>
<p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p>
<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p>
<p>多态的作用：消除类型之间的耦合关系。</p>
<p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>
<p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>
<p> 多态的好处：</p>
<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>
<p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>
<p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p>
<p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>
<p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>
<p><strong>18.什么导致线程阻塞</strong>（58、美团）</p>
<p>线程的阻塞</p>
<p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<ol>
<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>
<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>
<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li>
<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li>
</ol>
<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>
<p>上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：</p>
<p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<p><strong>19.抽象类接口区别</strong>（360）</p>
<ol>
<li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p>
</li>
<li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p>
</li>
<li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p>
</li>
<li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p>
</li>
<li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p>
</li>
<li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p>
</li>
<li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p>
</li>
<li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p>
</li>
<li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</li>
</ol>
<p><strong>20.容器类之间的区别</strong>（乐视、美团）</p>
<p><a href="http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html" target="_blank" rel="external">总结1</a></p>
<p><a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external">总结2</a>.</p>
<p><a href="http://tianmaying.com/tutorial/java_collection" target="_blank" rel="external">总结3</a></p>
<p><strong>21.java 内部类</strong>（小米）</p>
<p><a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">详细介绍</a></p>
<p><strong>22.Java中hashmap和hashtable的区别</strong>（乐视、小米）</p>
<p><a href="http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html" target="_blank" rel="external">区别</a></p>
<p><strong>23.ArrayMap VS HashMap</strong></p>
<p><a href="http://lvable.com/?p=217" target="_blank" rel="external">比较</a></p>
<p>###二、android基础</p>
<p><strong>1.数据库的操作类型有哪些，如何导入外部数据库？</strong></p>
<p>把原数据库包括在项目源码的 res/raw </p>
<p>android系统下数据库应该存放在 /data/data/com.<em>.</em>（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.</p>
<p><strong>2.是否使用过本地广播，和全局广播有什么差别？</strong></p>
<pre><code>因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。
不用担心别的应用伪造广播，造成安全隐患。
相比在系统内发送全局广播，它更高效。
</code></pre><p><strong>3.是否使用过intentService，作用是什么，AIDL解决了什么问题？</strong>(小米)</p>
<p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>
<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>
<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>
<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>
<p>AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。<br>AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。</p>
<p><strong>4.Activity、Window、View三者的差别，fragment的特点？</strong>（360）</p>
<p>Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）<br>LayoutInflater像剪刀，Xml配置像窗花图纸。</p>
<pre><code>1.  在Activity中调用attach，创建了一个Window
2.  创建的window是其子类PhoneWindow，在attach中创建PhoneWindow
3.  在Activity中调用setContentView(R.layout.xxx)
4.  其中实际上是调用的getWindow().setContentView()
5.  调用PhoneWindow中的setContentView方法
6.  创建ParentView： 作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）
7.  将指定的R.layout.xxx进行填充 ,通过布局填充器进行填充【其中的parent指的就是DecorView】
8.  调用到ViewGroup
9.  调用ViewGroup的removeAllView()，先将所有的view移除掉
10. 添加新的view：addView()
</code></pre><p>fragment 特点</p>
<ul>
<li>Fragment可以作为Activity界面的一部分组成出现；</li>
<li>可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；</li>
<li>在Activity运行过程中，可以添加、移除或者替换Fragment；</li>
<li>Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。</li>
</ul>
<p><strong>5.描述一次网络请求的流程</strong>（新浪）</p>
<p><img src="https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/http.png" alt=""></p>
<p><strong>6.Handler、Thread和HandlerThread的差别</strong>（小米）</p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p>
<p><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="external">http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/</a></p>
<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>
<p>android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p>
<p><strong>7.低版本SDK实现高版本api</strong>（小米）</p>
<p>自己实现或@TargetApi annotation</p>
<p><strong>8.Ubuntu编译安卓系统</strong>（百度）</p>
<pre><code>1. 进入源码根目录
2. . build/envsetup.sh
3. lunch
4. full(编译全部)
5. userdebug(选择编译版本)
6. make -j8(开启8个线程编译)
</code></pre><p><strong>9.launch mode应用场景</strong>（百度、小米、乐视）</p>
<p>standard，创建一个新的Activity。</p>
<p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p>
<p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p>
<p>注意:</p>
<ol>
<li>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。</li>
<li>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。</li>
<li>在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</li>
</ol>
<p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p>
<p>singleTop适合接收通知启动的内容显示页面。</p>
<p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>
<p>singleTask适合作为程序入口点。</p>
<p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<p>singleInstance应用场景：</p>
<p>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>
<p><strong>10.touch 事件传递流程</strong>（小米）</p>
<p><a href="http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">详细介绍</a></p>
<p><strong>11.view绘制流程</strong>（百度）</p>
<p><a href="http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f" target="_blank" rel="external">详细介绍</a></p>
<p><strong>12.多线程</strong>（360）</p>
<ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable),View.postDelay(Runnable,long)</li>
<li>Handler</li>
<li>AsyncTask</li>
</ul>
<p><strong>13.线程同步</strong>（百度）</p>
<p><a href="http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more" target="_blank" rel="external">详细介绍1</a></p>
<p><a href="http://www.juwends.com/tech/android/android-inter-thread-comm.html" target="_blank" rel="external">详细介绍2</a></p>
<p>单例</p>
<pre><code>public class Singleton{    
private volatile static Singleton mSingleton;
private Singleton(){
}

public static Singleton getInstance(){
    if(mSingleton == null){\\A
        synchronized(Singleton.class){\\C
         if(mSingleton == null)
              mSingleton = new Singleton();\\B
          }
    }
    return mSingleton;
      }
}
</code></pre><p><strong>14.什么情况导致内存泄漏</strong>（美团）</p>
<p>1.资源对象没关闭造成的内存泄漏</p>
<p>描述：<br>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p>
<p>2.构造Adapter时，没有使用缓存的convertView</p>
<p>描述：<br>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<br>public View getView(int position, ViewconvertView, ViewGroup parent)<br>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:<br>android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。<br>示例代码：</p>
<pre><code>public View getView(int position, ViewconvertView, ViewGroup parent) {
    View view = new Xxx(...); 
    ... ... 
    return view; 
} 
</code></pre><p>修正示例代码：</p>
<pre><code>public View getView(int position, ViewconvertView, ViewGroup parent) {
    View view = null; 
    if (convertView != null) { 
    view = convertView; 
    populate(view, getItem(position)); 
    ... 
    } else { 
        view = new Xxx(...); 
        ... 
    } 
    return view; 
} 
</code></pre><p>3.Bitmap对象不在使用时调用recycle()释放内存</p>
<p>描述：<br>有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：</p>
<p>/<em>*<br>•Free up the memory associated with thisbitmap’s pixels, and mark the<br>•bitmap as “dead”, meaning itwill throw an exception if getPixels() or<br>•setPixels() is called, and will drawnothing. This operation cannot be<br>•reversed, so it should only be called ifyou are sure there are no<br>•further uses for the bitmap. This is anadvanced call, and normally need<br>•not be called, since the normal GCprocess will free up this memory when<br>•there are no more references to thisbitmap. 
</em>/ </p>
<p>4.试着使用关于application的context来替代和activity相关的context</p>
<p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免<br>Android内存泄漏。</p>
<p>5.注册没取消造成的内存泄漏</p>
<p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。<br>比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。<br>虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p>
<p>6.集合中对象没清理造成的内存泄漏</p>
<p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p>
<p><strong>15.ANR定位和修正</strong></p>
<p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。</p>
<ul>
<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等<br>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</li>
<li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver未在10秒内完成相关的处理</li>
<li><p>Service在特定的时间内无法处理完成 20秒</p>
</li>
<li><p>使用AsyncTask处理耗时IO操作。</p>
</li>
<li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>
<li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>
<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>
<li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li>
</ul>
<p><strong>16.什么情况导致oom</strong>（乐视、美团）</p>
<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html" target="_blank" rel="external">Introduction</a></p>
<pre><code>1）使用更加轻量的数据结构
2）Android里面使用Enum
3）Bitmap对象的内存占用
4）更大的图片
5）onDraw方法里面执行对象的创建
6）StringBuilder
</code></pre><p><strong>17.Android Service与Activity之间通信的几种方式</strong></p>
<ul>
<li>通过Binder对象</li>
<li>通过broadcast(广播)的形式</li>
</ul>
<p><strong>18.Android各个版本API的区别</strong></p>
<p><a href="http://blog.csdn.net/lijun952048910/article/details/7980562" target="_blank" rel="external">区别</a></p>
<p><strong>19. Android代码中实现WAP方式联网</strong>（360）</p>
<p><a href="http://blog.csdn.net/asce1885/article/details/7844159" target="_blank" rel="external">方法</a></p>
<p><strong>20.如何保证service在后台不被kill</strong></p>
<p>一、onStartCommand方法，返回START_STICKY</p>
<ol>
<li><p>START_STICKY<br>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。</p>
</li>
<li><p>START_NOT_STICKY<br>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p>
</li>
<li><p>START_REDELIVER_INTENT<br>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p>
</li>
</ol>
<p>二、提升service优先级</p>
<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
<p>三、提升service进程优先级</p>
<p>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:</p>
<ol>
<li>前台进程( FOREGROUND_APP)</li>
<li>可视进程(VISIBLE_APP )</li>
<li>次要服务进程(SECONDARY_SERVER )</li>
<li>后台进程 (HIDDEN_APP)</li>
<li>内容供应节点(CONTENT_PROVIDER)</li>
<li>空进程(EMPTY_APP)</li>
</ol>
<p>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</p>
<p>四、onDestroy方法里重启service</p>
<p>service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>
<p>五、Application加上Persistent属性</p>
<p>六、监听系统广播判断Service状态</p>
<p>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。</p>
<p><strong>21.Requestlayout，onlayout，onDraw，DrawChild区别与联系</strong>（猎豹）</p>
<p>requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。<br>说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制<br>任何视图包括该调用者本身。</p>
<p>onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)</p>
<p>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</p>
<p>drawChild()去重新回调每个子视图的draw()方法</p>
<p><strong>22.invalidate()和postInvalidate() 的区别及使用</strong>（百度）</p>
<p><a href="http://blog.csdn.net/mars2639/article/details/6650876" target="_blank" rel="external">使用与区别</a></p>
<p><strong>23.Android动画框架实现原理</strong></p>
<p>Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。</p>
<p><strong>24.Android为每个应用程序分配的内存大小是多少？</strong>（美团）</p>
<p>android程序内存一般限制在16M，也有的是24M</p>
<p><strong>25.Android View刷新机制</strong>（百度、美团）</p>
<p>由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。</p>
<p>调用流程 ：</p>
<p>mView.draw()开始绘制，draw()方法实现的功能如下：</p>
<ol>
<li>绘制该View的背景</li>
<li>为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          </li>
<li>调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li>
<li>调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>
</ol>
<p><strong>26.LinearLayout对比RelativeLayout</strong>（百度）</p>
<ol>
<li>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure</li>
<li>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</li>
<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</li>
</ol>
<p>最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>
<p><strong>27.优化自定义view</strong>（百度、乐视、小米）</p>
<p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>
<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>
<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>
<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>
<p><strong>28.ContentProvider</strong>（乐视）</p>
<p><a href="http://blog.csdn.net/coder_pig/article/details/47858489" target="_blank" rel="external">Introduction</a></p>
<p><strong>29.fragment生命周期</strong></p>
<p><img src="https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/fragment-life.png" alt=""></p>
<p><strong>30.volley解析</strong>（美团、乐视）</p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley源码解析</a></p>
<p><strong>31.Android Glide源码解析</strong></p>
<p><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" target="_blank" rel="external">Glide源码解析1</a></p>
<p><a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="external">Glide源码解析2</a></p>
<p><strong>32.Android 设计模式</strong></p>
<p><a href="http://blog.csdn.net/bboyfeiyu/article/details/44563871" target="_blank" rel="external">设计模式</a></p>
<p><strong>33.架构设计</strong>（搜狐）</p>
<p><img src="https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/architucture.png" alt=""></p>
<p><a href="http://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="external">架构设计</a></p>
<p><strong>34.Android属性动画特性</strong>（乐视、小米）</p>
<p>如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p>
<p>注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p>
<p>然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p>
<p>最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之代码开发规范/" itemprop="url">
                  进阶系列代码开发规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:27:45+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之代码开发规范/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之代码开发规范/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><ul>
<li>类中public方法在前，private在后，所有不对外的方法，变量全部使用private修饰符。类中public static final的常量在最上方，其次private static final，然后public，private等。</li>
<li>类中定义的接口放在变量声明之后，所有方法之前。</li>
<li>方法相关性，方法之间有调用关系的，按照先后顺序排列在一起。</li>
<li>善用空行，方法体之间必须空行，代码逻辑块之间使用空行分隔，变量声明根据变量类型适当空行。</li>
<li>方法体不要过长，尽量提取小方法代替逻辑块，保证代码可读性。</li>
<li>善用TODO，对于未完成或已完成但是方案不完美需后续跟踪的，使用TODO标签标示，并写好注释。</li>
<li>不建议注释太多，要通过方法名，变量名提高代码可读性，而非注释。但是一些非常规方法，复杂逻辑，需要详细注释说明。</li>
<li>协作中，不要做整个代码的格式化，仅格式化自己编写的那部分。</li>
<li>注意命名以及注释英文单词，不要写错~</li>
<li>杜绝“Magic Number”, 所有数值根据情况提取为常量，dimen或constant。</li>
</ul>
<p>###代码规范</p>
<ul>
<li>使用Android Studio提供的格式化规范。</li>
</ul>
<p>###命名规范</p>
<p>####1. Java命名<br>    分类                命名方式                   举例                                  说明</p>
<pre><code>包名                 全小写             com.cicaero.kite       公司域名倒序，“.”分隔，单个包名建议不超过12个字母

类名             首字母大写的驼峰              UserInfo                                名词形式

 接口名         首字母大写的驼峰          ServerInterface                           名字形式

方法名              驼峰                 getUserInfo                       动词结构，含义为一个动作

常量           全大写，单词下划线分隔       MSG_UPDATE_PROGRESS             建议数值类常量从1开始，且根据功能预留数段

成员变量      m/s/is/has开头的驼峰           mImageUrl               正常成员m开头，静态s开头，布尔型is/has开头

局部变量         首字母小写的驼峰          currentPosition          名词形式，除非是循环，否则不建议使用i，j，k等简单变量名
</code></pre><p>####2. 资源命名</p>
<pre><code>分类                命名方式                   举例                                  说明

布局           全小写，单词下划线分隔        activity_main.xml         Activity以activity开头，Fragment以fragment开头，
                                                             List、Grid项以item开头，Dialog布局以dialog开头，
                                                             自定义View以layout开头，其他被include的或公用组件，
                                                             诸如title_bar,bottom_bar,根据实际含义命名

Drawable    全小写，单词下划线分隔         btn_bg.png              根据图片使用方式命名， 图标以ic_开头，背景以_bg结尾，
                                                             状态drawable xml以_selector结尾。

Color         全小写，单词下划线分隔           green              尽量根据颜色值命名

String         全小写，单词下划线分隔          app_name              模块多且大的话，根据模块建立不同的String xml 文件

style           首字母大写的驼峰              NoTitleTheme            类似类名，style本身也是有类似类的集成关系

dimension     全小写，单词下划线分隔        left_padding     

id             全小写，单词下划线分隔        user_name_tv          详细id命名规范参考以下章节
</code></pre><p>####3. 布局文件中的View id命名</p>
<pre><code>  View          结尾命名规则

TextView          tv
Button              btn
EditText          et
ImageView          iv
ImageButton      img_btn
RadioButton      rb
RadioGroup       rg
SeekBar          seek
ProgressBar      progress
Spinner          spinner
VideoView          vv
CheckBox          cb
ListView          lv
GridView          grid
Layout              lt
</code></pre><p>###其他规范</p>
<ul>
<li>Gradle引入第三方库时comment加上库地址。</li>
<li>编译相关的常量写入编译脚本。</li>
</ul>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之一年一总结/" itemprop="url">
                  进阶系列一年一总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:27:12+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之一年一总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之一年一总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础总结篇"><a href="#基础总结篇" class="headerlink" title="基础总结篇"></a>基础总结篇</h1><p>##Android公共技术：</p>
<p><a href="http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Android%20%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80" target="_blank" rel="external">公共技术点之 Android 动画基础</a></p>
<p><a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">公共技术点之 Java 动态代理</a></p>
<p><a href="http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="external">公共技术点之依赖注入</a></p>
<p><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">公共技术点之 View 事件传递</a></p>
<p><a href="http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B" target="_blank" rel="external">公共技术点之 View 绘制流程</a></p>
<h3 id="1-Android的Framework和Android-apk的打包过程"><a href="#1-Android的Framework和Android-apk的打包过程" class="headerlink" title="1.Android的Framework和Android apk的打包过程"></a>1.Android的Framework和Android apk的打包过程</h3><p>底层的Binder驱动，IPC的核心，SGL 2D绘图，OpenGL 3D绘图</p>
<p>###2.多线程</p>
<p><a href="http://blog.csdn.net/goodlixueyong/article/details/45895997" target="_blank" rel="external">AsyncTask的缺陷和问题</a></p>
<p>关于线程池：asynctask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是asynctask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0后默认串行执行，不会出现这个问题)。针对这种情况，可以尝试自定义线程池，配合asynctask使用。</p>
<p>关于默认线程池：核心线程池中最多有CPU_COUNT+1个，最多有CPU_COUNT*2+1个，线程等待队列的最大等待数为128，但是可以自定义线程池。线程池是由AsyncTask来管理的，线程池允许tasks并行运行，xuyao注意的是并发情况下数据的一致性问题，新数据可能会被老数据覆盖掉，类似volatile变量。所以希望tasks能够串行运行的话，使用SERIAL_EXECUTOR。</p>
<p>自定义线程池：executeOnExecutor(Executor exec,Params… params) 自定义Executor</p>
<p>execute(Params… params){return executeOnExecutor(sDefaultExecutor,params);}</p>
<p>AsyncTask在不同的SDK版本中的区别：</p>
<p><a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案</a></p>
<p>通过查阅官方文档发现，AsyncTask首次引入时，异步任务是在一个独立的线程中顺序的执行，也就是说一次只能执行一个任务，不能并行的执行，从1.6开始，AsyncTask引入了线程池，支持同时执行5个异步任务，也就是说同时只能有5个线程运行，超过的线程只能等待，等待前面的线程某个执行完了才被调度和运行。换句话说，如果一个进程中的AsyncTask实例个数超过5个，那么假如前5个都运行很长时间的话，那么第6个只能等待机会了。这是AsyncTask的一个限制，而且对于2.3以前的版本无法解决。如果你的应用需要大量的后台线程去执行任务，那么你只能放弃使用AsyncTask，自己创建线程池来管理Thread，或者干脆不用线程池直接使用Thread也无妨。不得不说，虽然AsyncTask较Thread使用起来方便，但是它最多只能同时运行5个线程，这也大大局限了它的实力，你必须要小心设计你的应用，错开使用AsyncTask的时间，尽力做到分时，或者保证数量不会大于5个，否则就会遇到上次提到的问题。可能是Google意识到了AsyncTask的局限性了，从Android3.0开始对AsyncTask的API作出了一些调整：每次只启动一个线程执行一个任务，完成之后再执行第二个任务，也就是相当于只有一个后台线程在执行所提交的任务。</p>
<p>#####1、生命周期</p>
<p>很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsyncTask会一直执行，直到doInBackground()方法执行完毕。然后，如果cancel(boolean)被调用,那么onCancelled(Result result)方法会被执行；否则，执行onPostExecute(Result result)方法。如果我们的Activity销毁之前，没有取消AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确的取消。</p>
<p>#####2、内存泄漏</p>
<p>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄漏。</p>
<p>#####3、结果丢失</p>
<p>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。</p>
<p>#####4、并行还是串行</p>
<p>在Android1.6之前的版本，AsyncTask是串行的，在1.6至2.3的版本，改成了并行的。在2.3之后的版本又做了 修改，可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要执行executeOnExecutor(Executor)。</p>
<p>###3.Android机制</p>
<p>#####(1)Linux Sandbox 沙箱机制：<br>Android将数据分为system和data两个区。其中system是只读的，dada用来存放应用自己的数据，这保证了系统数据不会被随意改写。</p>
<pre><code>应用之间的数据相互独立，每个应用都会有一个user id和group id，只有相同的user id并且来自同一个作者，才能访问它们的数据。
作者通过对apk签名来标识自己，签名和uid构成了双重的保证。
</code></pre><p>#####(2)用户权限机制：<br>文件权限，UID,GID</p>
<p>#####(3)用户权限机制：<br>android permission机制限制应用访问特定的资源，例如照相机、网络、外部存储等api</p>
<pre><code>如何让两个app运行在同一个进程里？
    1. 两个app要用相同的private key来签名
    2. 两个app的Manifest文件中要添加一样的属性 android:sharedUserId(设置成相同的UID)
</code></pre><p>###4.Binder机制</p>
<p>跨进程间通信(IPC):四大组件之间通过Intent互相跳转，Android实现IPC的方式是binder机制。</p>
<p><a href="http://blog.csdn.net/notice520/article/details/8135600" target="_blank" rel="external">android中的跨进程通信的实现（一）——远程调用过程和aidl</a></p>
<p><a href="http://www.linuxidc.com/Linux/2012-07/66195.htm" target="_blank" rel="external">Android中的Binder机制的简要理解</a></p>
<p><a href="http://blog.csdn.net/sunxingzhesunjinbiao/article/details/42195043" target="_blank" rel="external">Android中的Binder机制的简要理解二</a></p>
<p>In the Android platform, the binder is used for nearly everything that happens accross in the core plateform.</p>
<p>最底层的是Android的ashmen（Anonymous shared memoryy）机制，它负责辅助实现内存的分配，以及跨进程间通信所需要的内存共享。AIDL(Android Interface Definition Language)对BInder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。</p>
<p>从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户区间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动了，ServiceManager提供了辅助管理的功能，Client和Server正是在Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信。</p>
<p><img src="http://img.blog.csdn.net/20160329110351922" alt="BINDER" title="binder"></p>
<pre><code>1. Client、Server和ServiceManager实现在用户空间中，Binder驱动程序实现在内核空间中
2. Binder驱动程序和ServiceManager在Android平台已经实现，开发者只需要在用户空间实现自己的Client和Server
3. Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信
4. Client和Server之间的进程间通信通过Binder驱动程序间接实现
5. Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力
</code></pre><p>服务器端：一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用语接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。</p>
<p>Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会相应的创建一个mRemote对象，该对象的类型也是也是Binder类。客户就可以借助这个mRemote对象来访问远程服务。</p>
<p>客户端：客户想要访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。</p>
<p>在这里，我们可以看到，客户端是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，然后相应的在Binder驱动中创建一个Binder对象，接着客户端通过获取Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind（粘连）在一起，实现通信。</p>
<p>mmap将一个文件或者其他对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。munmap执行相反的操作，删除特定地址区域的对象映射。</p>
<p>当使用mmap映射文件到进程后，就可以直接操作这段虚拟内存进行文件的读写等操作，不必再调用read，write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保存共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>aidl主要就是帮助我们完成了包装数据和解包的过程，并调用了transact过程，而用来传递的数据包我们就称为parcel</p>
<p>AIDL: xxx.aidl-&gt;xxx.java,注册service</p>
<pre><code>1. 用aidl定义需要被调用方法接口
2. 实现这些方法
3. 调用这些方法
</code></pre><p>###5.NDK</p>
<p>Dalvik虚拟机在调用一个成员函数的时候，如果发现该成员函数是一个JNI方法，那么就会直接跳到它的地址去执行。也就是说，JNI方法是直接在本地操作系统执行的，而不是Dalvik虚拟机解释器执行。由此也可以看出，JNI方法是Android应用程序与本地操作系统直接进行通信的一个手段。</p>
<p>JNI原理：</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="external">Dalvik虚拟机JNI方法的注册过程分析</a></p>
<p>例子：当libnanosleep.so文件被加载的时候，函数JNI_OnLoad就会被调用。在函数JNI_OnLoad中，参数vm描述的是当前线程中的Dalvik虚拟机，通过调用它的成员函数GetEnv就可以获得一个JNIEnv对象。有了这个JNIEnv对象之后，我们就可以调用另外一个函数jniRegisterNativeMethods来向当前进程的Dalvik虚拟机注册一个JNI方法。</p>
<p>###6.Android系统启动过程，App启动过程</p>
<p>App启动过程：</p>
<p><a href="http://blog.csdn.net/stonecao/article/details/6591847" target="_blank" rel="external">Activity启动过程详解</a></p>
<p>从桌面点击到activity启动的过程</p>
<p>1、Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely,进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。</p>
<p>2、Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity。</p>
<p>3、调用ActivityManagerService的startActivity方法，这里做了进程切换（具体过程请查看源码）。</p>
<p>4、开启Activity，调用onCreate方法</p>
<p>###7.Activity,Fragment,Service生命周期</p>
<p>常见的例子：程序正运行着来电话了，这个程序咋办呢？中止了呗，如果中止的时候新出的一个Activity是全屏的onPause-&gt;onStop，恢复的时候onStart-&gt;onResume,如果打断这个应用程序的是一个Theme为Translucent或者Dialog的Activity那么只是onPause,恢复的时候onResume。</p>
<ul>
<li>onPause:恢复的时候onResume</li>
<li>onCreate:在这里创建界面，做一些数据的初始化工作</li>
<li>onStart:到这一步变成用户可见不可交互的</li>
<li>onPause:到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情，应该在这里保存你的一些 数据，因为这个时候你的程序的优先级降低，有可能被 系统回收。在这里保存的数据，应该在onResume里读出来。注意：这个方法里做的事情时间要短，因为下一个Activity不会等到这个方法完成才启动。</li>
<li>onStop:变得不可见，被下一个Activity覆盖了(onPause和onStop的区别是否可见)</li>
<li>onDestroy:这是Activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有一个ProgressDialog在线程中转动，请在onDestroy里把它cancel掉，不然等线程结束的时候，调用Dialog的cancel会抛出异常的。</li>
</ul>
<p>onPause,onstop,onDestroy，三种状态下，Activity都有可能被系统干掉。</p>
<p>启动另一个Activity然后finish，先调用旧Activity的onPause方法，然后调用新的Activity和onCreate-&gt;onStart-&gt;onResume方法，然后调用旧Activity的onStop-&gt;onDestroy方法。</p>
<p>如果没有调用finish那么onDestroy方法不会被调用，而且在onStop之前还会调用onSavedInstanceState方法</p>
<p>onRestart方法执行完了之后还会调用onStart方法</p>
<p>fragment:[SupportFragmentManager,childFragment]</p>
<p>service:</p>
<p><a href="http://www.cnblogs.com/mengdd/archive/2013/03/24/2979944.html" target="_blank" rel="external">Android Service的生命周期</a></p>
<p><a href="http://www.cnblogs.com/perfy/p/3820502.html" target="_blank" rel="external">android-Service和Thread的区别</a></p>
<p>Service和Intent Service:没啥区别，只是IntentService在onCreate方法中开启新的HandlerThread去执行。</p>
<p>Service运行的进程和线程：当它运行的时候如果是LocalService，那么对应的Service是运行在主进程的main线程上的。如onCreate,onStart这些函数都是在系统调用的时候在主进程的main线程上运行的。如果是RemoteSevice，那么对应的Service则是运行在独立的main线程上。</p>
<pre><code>1. 服务不是单一的进程，服务没有自己的进程，应用程序可以不同，服务运行在相同的进程中
2. 服务不是线程，可以在线程中工作
3. 在应用中，如果是长时间的在后台运行，而且不需要交互的情况下，使用服务
4. 同样是在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下使用线程
5. 如果任务占用CPU时间多，资源大的情况下，要使用线程
</code></pre><p>Thread的运行是独立于Activity的，也就是说当一个Activity被finish之后，如果你没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread就会一直执行。</p>
<p><img src="http://img.blog.csdn.net/20160329110448313" alt="THREAD_VS_SERVICE"></p>
<p>###8.View绘画机制</p>
<p>View的绘制主要涉及三个方法：onMeasure()、onLayout()、onDraw()</p>
<pre><code>1. onMeasure主要用于计算view的大小，onLayout主要用于确定view在ContentView中的位置，onDraw主要是绘制View。
2. 在执行onMeasure()、onLayout()方法时都会通过相应的标志位或者对应的坐标点来判断是否需要执行对应的函数，
   如我们经常调用的invalidate方法就只会执行onDraw方法，因为此时的视图大小和位置均未发生变化，
    除非调用requestLayout方法完整强制进行view的绘制，从而执行上面三个方法。
</code></pre><p>进度条组件：</p>
<p><a href="https://github.com/hujiaweibujidao/ProgressView" target="_blank" rel="external">ProgressView</a></p>
<p><a href="https://github.com/hujiaweibujidao/AnnotationView" target="_blank" rel="external">AnnotationView</a></p>
<p>###9.事件传递机制</p>
<p>android 事件处理机制总结，ScrollView ViewPager ListView GridView嵌套小结</p>
<p>当手指触摸到屏幕时，系统就会调用相应View的onTouchEvent，并传入一系列的action。</p>
<p>dispatchTouchEvent的执行顺序为：</p>
<pre><code>首先触发ACTIVITY的dispatchTouchEvent,然后触发ACTIVITY的onUserInteraction

然后触发LAYOUT的dispatchTouchEvent，然后触发LAYOUT的onInterceptTouchEvent
</code></pre><p>这就解释了重写ViewGroup时必须调用super.dispatchTouchEvent();</p>
<p>#####(1)dispatchTouchEvent:</p>
<p>此方法一般用于初步处理事件，因为动作是由此分发，所以通常会调用super.dispatchTouchEvent。这样就会继续调用onInterceptTouchEvent，再由onInterceptTouchEvent决定事件流向。</p>
<p>#####(2)onInterceptTouchEvent:</p>
<p>若返回值为true事件会传递到自己的onTouchEvent();若返回值为false传递到下一个View的dispatchTouchEvent();</p>
<p>#####(3)onTouchEvent():</p>
<p>若返回值为true，事件由自己消耗，后续动作让其处理；若返回值为false，自己不消耗事件了，向上返回让其他的父View的onTouchEvent接受处理</p>
<p>三大方法关系的伪代码：如果当前View拦截事件，就交给自己的onTouchEvent去处理，否则就丢给子View继续走相同的流程。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev)
{
       boolean consume = false;
    if(onInterceptTouchEvent(ev))
    {
           consume = onTouchEvent(ev);
    } else {
        consume = child.dispatchTouchEvent(ev);
    }
    return consume;
}
</code></pre><ul>
<li>onTouchEvent的传递：</li>
</ul>
<p>当有多个层级的View时，在父层级允许的情况下，这个action会一直传递直到遇到最深层的View。所以touch事件最先调用的是最底层View的onTouchEvent，如果View的onTouchEvent接收到某个touch action并做了相应处理，最后有两种返回方式return true和return false；return true会告诉系统当前的View需要处理这次的touch事件，以后的系统发出的ACTION_MOVE,ACTION_UP还是需要继续监听并接收的，并且这次的action已经被处理掉了，父层的View是不可能触发onTouchEvent的了。所以每一个action最多只能有一个onTouchEvent接口返回true。如果返回false，便会通知系统，当前View不关心这一次的touch事件，此时这个action会传向父级，调用父级View的onTouchEvent。但是这一次的touch事件之后发出任何action，该View都不在接受，onTouchEvent在这一次的touch事件中再也不会触发，也就是说一旦View返回false，那么之后的ACTION_MOVE,ACTION_UP等ACTION就不会在传入这个View,但是下一次touch事件的action还是会传进来的。</p>
<ul>
<li>父层的onInterceptTouchEvent</li>
</ul>
<p>前面说了底层的View能够接收到这次的事件有一个前提条件：在父层允许的情况下。假设不改变父层级的dispatch方法，在系统调用底层onTouchEvent之前会调用父View的onInterceptTouchEvent方法判断，父层View是否要截获本次touch事件之后的action。如果onInterceptTouchEvent返回了true，那么本次touch事件之后的所有action都不会向深层的View传递，统统都会传给父层View的onTouchEvent，就是说父层已经截获了这次touch事件，之后的action也不必询问onInterceptTouchEvent，在这次的touch事件之后发出的action时onInterceptTouchEvent不会再被调用，直到下一次touch事件的来临。如果onInterceptTouchEvent返回false，那么本次action将发送给更深层的View，并且之后的每一次action都会询问父层的onInterceptTouchEvent需不需要截获本次touch事件。只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，touch能够传到这里已经是最后一站了，肯定会调用View的onTouchEvent()。</p>
<ul>
<li>底层View的getParent().requestDisallowInterceptTouchEvent(true)</li>
</ul>
<p>对于底层的View来说，有一种方法可以阻止父层的View获取touch事件，就是调用getParent().requestDisallowInterceptTouchEvent(true)方法。一旦底层View收到touch的action后调用这个方法那么父层View就不会再调用onInterceptTouchEvent了，也无法截获以后的action（如果父层ViewGroup和最底层View需要截获不同焦点，或不同手势的touch，不能使用这个写死）。</p>
<p>曾经开发过程中遇到的两个示例：左边是处理ViewPager和ListView的冲突，纪录水平和垂直方向的偏移量，如果水平方向的偏移更多的话就让ViewPager处理pager滑动</p>
<p>右边处理的ViewPager和ImageBanner的滑动冲突，同样是纪录偏移量，如果发生在ImageBanner上的水平偏移量大于垂直偏移量的话就让banner滚动</p>
<p>想想为什么右边是重写dispatchTouchEvent方法而不是onInterceptTouchEvent方法？</p>
<p>FixedViewPager</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev)
{
    switch(ev.getAction() &amp; MotionEvent.ACTION_MASK)
    {
        case MotionEvent.ACTION_DOWN:
            mX = ev.getX();
            mY = ev.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            float x = ev.getX();
            float y = ev.getY();
            float dX = x - mX;
            float dY = y - mY;
            float tmp = Math.abs(dX) / Math.abs(dY);
            mX = x;
            mY = y;
            if(tmp &gt; 1)
            {
                return true;
            }
            else
            {
                return super.omInterceptTouchEvent(ev);
            }
    }
}
</code></pre><p>FixedImageLoadBanner</p>
<pre><code>@override
public boolean dispatchTouchEvent(MotionEvent ev)
{
    if(mX != 0 || mY != 0)
    {
        float dY = ev.getRawY() - mY;
        float dX = ev.getRawX() - mX;
        if(Math.abs(dY) &gt; Math.abs(dX))
        {
            requestDisallowInterceptTouchEvent(false);
        }
        else
        {
            requestDisallowInterceptTouchEvent(true);
        }
    }
    mX = ev.getRawX();
    mY = ev.getRawY();
    return super.dispatchTouchEvent(ev);
}
</code></pre><p>###10.ART和Dalvik区别</p>
<p>art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。</p>
<p>ART: Ahead of Time Dalvik: Just in Time</p>
<ul>
<li>什么是Dalvik：</li>
</ul>
<p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p>
<ul>
<li>什么是ART:</li>
</ul>
<p>Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p>
<p>ART优点：</p>
<pre><code>1. 系统性能的显著提升
2. 应用启动更快、运行更快、体验更流畅、触感反馈更及时。
3. 更长的电池续航能力
4. 支持更低的硬件
</code></pre><p>ART缺点：</p>
<pre><code>1. 更大的存储空间占用，可能会增加10%-20%
2. 更长的应用安装时间
</code></pre><p>###11.Scroller原理</p>
<p>Scroller执行流程里面的三个核心方法</p>
<pre><code>1. mScroller.startScroll()
2. mScroller.computeScrollOffset()
3. view.computeScroll()
</code></pre><p>1、在mScroller.startScroll()中为滑动做了一些初始化准备，比如：起始坐标，滑动的距离和方向以及持续时间(有默认值)，动画开始时间等。</p>
<p>2、mScroller.computeScrollOffset()方法主要是根据当前已经消逝的时间来计算当前的坐标点。因为在mScroller.startScroll()中设置了动画时间，那么在computeScrollOffset()方法中依据已经消逝的时间就很容易得到当前时刻应该所处的位置并将其保存在变量mCurrX和mCurrY中。除此之外该方法还可判断动画是否已经结束。</p>
<p><img src="http://img.blog.csdn.net/20160329110551127" alt="SCROLLER"></p>
<p>###12.Activity Manager Service, ActivityThread</p>
<p>###13.Android几种进程</p>
<pre><code>1. 前台进程： 即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的
2. 可见线程： 可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互
3. 服务进程： 其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关系的，
             例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等，当系统要用空间运行前两者进程时才会被终止
4. 后台进程： 其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ,这样的进程系统一旦没有内存就首先被杀死。
5. 空进程：   不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的。
</code></pre><p>如何避免后台进程被杀死？</p>
<pre><code>1. 调用startForegound,让你的Service所在的进程成为前台进程
2. Service的onStartCommand返回START_STICKY或START_REDELIVER_INTENT
3. Service的onDestroy里面重新启动自己
</code></pre><p>###14.Activity启动模式</p>
<ul>
<li>standard:</li>
</ul>
<p>Activity的默认加载方式，该方法会通过跳转到一个新的Activity，同时将该实例压入到栈中(不管该Activity是否已经存在在Task栈中，都是采用new操作，生命周期从onCreate()开始)。例如：栈中顺序是A B C D,此时D通过Intent跳转到A，那么栈中结构就变成A B C D A,点击返回按钮的显示顺序是D C B A，依次摧毁。</p>
<ul>
<li>singleTop:</li>
</ul>
<p>singleTop模式下，当前Activity D位于栈顶的时候，如果通过Intent跳转到它本身的Activity(D)，那么不会重新创建一个新的D实例(走onNewIntent()),所以栈中的结构依次为A B C D,如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个Activity，这肯定用singletop</p>
<ul>
<li>singleTask:</li>
</ul>
<p>singleTask模式下，Task栈中只能有一个对应的Activity实例。例如：Task栈1中结构为：A B C D。此时D通过Intent跳转到B（走onNewIntent()）,则栈的结构变成了:A,B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。通常应用于首页，首页肯定在栈底部，也只能在栈底部。</p>
<ul>
<li>singleInstance:</li>
</ul>
<p>singleInstance模式下，会将打开的Activity压入一个新的任务栈中。例如：Task栈1中结构为：A B C,C通过Intent跳转到了D（D的模式为singleInstance），那么则会新建一个Task，栈1中结构依旧为A B C,栈2中结构为D。此时屏幕显示D，之后D通过Intent跳转到D，栈2不会压入新的D，所以两个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的launchMode在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C ,此时点击返回按钮，还是在C，栈1的结构变为A B C,而不会回到D。</p>
<p>##</p>
<p>launchMode为singleTask的时候，通过Intent启动到一个Activity，如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而不是调用onNewIntent方法。</p>
<p>onSavedInstanceState的调用遵循一个重要原则，即当系统”未经你许可”时销毁了你的Activity，则onSavedInstanceState会被系统调用，这时系统的责任，因为它必须要提供一个机会让你保存你的数据，至于onRestoreInstanceState方法，需要注意的是，onSavedInstanceState方法和onRestoreInstanceState方法”不一定”是成对调用的。</p>
<p>onRestoreInstanceState被调用的前提是，Activity A确实被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示Activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到Activity A,这种情况下Activity A一般不会因为内存的原因被销毁，故Activity的onRestoreInstanceState方法不会被执行。</p>
<p>另外，onRestoreInstanceStated的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。</p>
<p>onSavedInstanceState(Bundle bundle)通常和onRestoreInstanceState(Bundle bundle)不会成对出现，onRestoreInstanceState这玩意不太好触发，给大家提个好办法，横竖屏切换的时候100%会触发。然后保存在onRestoreInstanceState bundle里面的数据，就是onCreate的那个参数bundle啦，要怎么恢复就看开发者了。</p>
<p>##</p>
<p>###15.TMImageView图片库的设计</p>
<p>Feature机制</p>
<p>###16.ListView优化</p>
<pre><code>1. 首先，虽然大家都知道，还是提一下，利用好convertView来重用View，切忌每次getView都新建。ListView的核心原理就是重用View。
   ListView有一个回收器，Item滑出界面的时候view就会回收这里，需要显示新的Item的时候，就尽量重用回收器里面的View。

2. 利用好ViewType，例如你的ListView中有几个类型的Item，需要给每个类型创建不同的View，这样有利于ListView的回收，当然类型不能太多

3. 尽量让ItemView的Layout层次结构简单，这时所有Layout都必须遵守的

4. 善用自定义View，自定义View可以有效的减小Layout的层级，而且对绘制过程可以很好的控制

5. 尽量保证Adapter的hasStableIds()返回true，这样在notifyDataSetChanged()的时候，如果id不变，listView将不会重新绘制这个View，达到优化的目的。

6. 每个item不能太高，特别是不要超出屏幕的高度，可以参考Facebook的优化方法，把特别复杂的Item分解为若干个小的Item.

7. 为了保证ListView滑动的流畅性，getView()中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载。

8.使用RecyclerView代替。ListView每次更新数据都要notifyDataSetChanged(),有些太暴力了。RecyclerView在性能和可定制性上都有很大的改善，推荐使用。

9.有时需要从根本上考虑，是否真的要使用listView来实现你的需求，或者是否有其他选择？
</code></pre><p>###17.webView</p>
<p>如何使用webview在js中调用java方法？</p>
<pre><code>webView.addJavaScriptInterface(new Object(){xxx}, &quot;xxx&quot;);
</code></pre><p>答案：可以使用WebView控件执行JavaScript脚本，并且可以在JavaScript中执行Java代码。要想让WebView控件执行JavaScript，需要调用WebSettings.setJavaScriptEnabled方法，代码如下：</p>
<pre><code>WebView webView = (WebView)findViewById(R.id.webview);
WebSettings webSettings = webView.getSettings();
//设置WebView支持JavaScript
webSettings.setJavaScriptEnabled(true);
webView.setWebChromeClient(new WebChromeClient());
</code></pre><p>JavaScript调用Java方法需要使用WebView.addJavascriptInterface方法设置JavaScript调用的Java方法，代码如下：</p>
<pre><code>webView.addJavascriptInterface(new Object()
{
    //JavaScript调用的方法
    public String process(String value)
    {
        //处理代码
        return result;
    }
}, &quot;demo&quot;);       //demo是Java对象映射到JavaScript中的对象名
</code></pre><p>可以使用下面的JavaScript代码调用process方法，代码如下：</p>
<pre><code>&lt;script language=&quot;javascript&quot;&gt;
function search()
{
    //调用searchWord方法
    result.innerHTML = &quot;&lt;font color=&apos;red&apos;&gt;&quot; + window.demo.process(&apos;data&apos;) + &quot;&lt;/font&gt;&quot;;
}
</code></pre><p>###18.SurfaceView和View的最本质的区别</p>
<p>SurfaceView是在一个新起的单独线程中可以重新绘制画面，而view必须在UI的主线程中更新画面。</p>
<p>在UI的主线程中更新画面可能会引发问题，比如你更新的时间过长，那么你的主UI线程就会被你正在画的函数阻塞。那么将无法响应按键、触屏等消息。当使用SurfaceView由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要SurfaceView中thread处理，一般就需要有一个event queue的设计来保存touchevent，这会稍稍复杂一点，因为涉及到线程安全。</p>
<p>###19.标签</p>
<p> <a href="http://www.cnblogs.com/chrisfang6/articles/2217711.html" target="_blank" rel="external">merge和include</a></p>
<p> <a href="http://www.open-open.com/lib/view/open1395456763025.html" target="_blank" rel="external">Android ViewStub的基本使用</a></p>
<p>简言之，都是用来解决重复布局的问题，但是标签能够在布局重用的时候减少UI层级结构。<br>viewStub标签是用来给其他的View事先占据好位置，当需要的时候用inflater()或者是setVisible()方法显示这些View。</p>
<p>###20.ANR排错</p>
<p>1、ANR排错一般有三种类型</p>
<pre><code>1. KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应
2. BroadcastTimeout(10 secends) –BroadcastReceiver在特定时间内无法处理完成
3. ServiceTimeout(20 secends) –小概率事件 Service在特定的时间内无法处理完成
</code></pre><p>2、如何避免</p>
<pre><code>1. UI线程尽量只做跟UI相关的工作
2. 耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理
3. 尽量用Handler来处理UIthread和别的thread之间的交互
</code></pre><p>3、如何排查</p>
<pre><code>1. 首先分析log
2. 从trace.txt文件查看调用stack，adb pull data/anr/traces.txt ./mytraces.txt
3. 看代码
4. 仔细查看ANR的成因(iowait?block?memoryleak?)
</code></pre><p>4、监测ANR的Watchdog</p>
<p>###21.fragment生命周期</p>
<p><img src="http://img.blog.csdn.net/20160329110747255" alt="FRAGMENT"></p>
<p>==============================================  常见面试问题  ====================================================</p>
<p>####1、横竖屏切换时候Activity的生命周期</p>
<pre><code>1. 不设置Activityd饿android:configChanges时，切屏会重新掉哟过各个生命周期，切横屏时会执行一次，切竖屏时会执行两次
2. 设置Activity的android:configChanges=”orientation”时，切屏还是会调用各个生命周期，切换横竖屏只会执行一次
3. 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
</code></pre><p>####2、OOM(图片相关的)怎么处理?</p>
<p><a href="http://mzh3344258.blog.51cto.com/1823534/804237" target="_blank" rel="external">Android 内存溢出解决方案（OOM） 整理总结</a></p>
<pre><code>1. 在内存引用上做些处理，常用的有软引用、弱引用
2. 在内存中加载图片时直接在内存中作处理，如：边界压缩
3. 动态回收内存
4. 优化Dalvik虚拟机的堆内存分配
5. 自定义堆内存大小
</code></pre><p>####3、界面优化</p>
<p><a href="http://www.mobile-open.com/2015/38640.html" target="_blank" rel="external">Android开发——性能优化之如何防止过度绘制</a></p>
<ul>
<li>太多重叠的背景(overdraw)</li>
</ul>
<p>这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。</p>
<ul>
<li>太多重叠的View</li>
</ul>
<p>第一个建议是 ：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认是不可见的视图，可以动态的加载一个布局，只要你用到这个重叠着的View的时候才加载，推迟加载的时间。</p>
<p>第二个建议是：如果使用了类似Viewpager＋Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态的Inflation view，它的性能要比SetVisibility好。</p>
<ul>
<li>复杂的Layout层级</li>
</ul>
<p>这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。第二个建议是：用标签来合并布局。第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。</p>
<p>####4、移动端获取网络数据优化的几个点</p>
<pre><code>1. 连接复用：节省连接建立时间，如开启 keep-alive。
   对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，
   具体可见：Android HttpURLConnection及HttpClient选择

2. 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。

3. 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 2.0)。

4. 返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。
  （也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了）

5. 根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之图片缓存技术/" itemprop="url">
                  进阶系列图片缓存技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:26:30+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之图片缓存技术/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之图片缓存技术/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Android 三大图片缓存原理、特性对比</p>
<p>这是我在 MDCC 上分享的内容(略微改动)，也是源码解析第一期发布时介绍的源码解析后续会慢慢做的事。</p>
<p>从总体设计和原理上对几个图片缓存进行对比，没用到他们的朋友也可以了解他们在某些特性上的实现。</p>
<p>上篇关于选择开源项目的好处及如何选择开源项目可见：开源项目使用及选型。</p>
<h2 id="一-四大图片缓存基本信息"><a href="#一-四大图片缓存基本信息" class="headerlink" title="一. 四大图片缓存基本信息"></a>一. 四大图片缓存基本信息</h2><p>###Universal ImageLoader<br>是很早开源的图片缓存，在早期被很多应用使用。</p>
<p>###Picasso<br>是 Square 开源的项目，且他的主导者是 JakeWharton，所以广为人知。</p>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>是 Google 员工的开源项目，被一些 Google App 使用，在去年的 Google I/O 上被推荐，不过目前国内资料不多。</p>
<p>###Fresco<br>是 Facebook 在今年上半年开源的图片缓存，主要特点包括：</p>
<pre><code>(1) 两个内存缓存加上 Native 缓存构成了三级缓存

(2) 支持流式，可以类似网页上模糊渐进式显示图片

(3) 对多帧动画图片支持更好，如 Gif、WebP
</code></pre><p>鉴于 Fresco 还没发布正式的 1.0 版本，同时一直没太多时间熟悉 Fresco 源码，后面对比不包括 Fresco，以后有时间再加入对比。</p>
<p>更多图片缓存库可见：<a href="http://p.codekk.com/?s=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98" target="_blank" rel="external">Android 图片缓存库</a></p>
<p>##二、基本概念</p>
<p>在正式对比前，先了解几个图片缓存通用的概念：</p>
<p>(1) RequestManager：请求生成和管理模块</p>
<p>(2) Engine：引擎部分，负责创建任务(获取数据)，并调度执行</p>
<p>(3) GetDataInterface：数据获取接口，负责从各个数据源获取数据。<br>比如 MemoryCache 从内存缓存获取数据、DiskCache 从本地缓存获取数据，下载器从网络获取数据等。</p>
<p>(4) Displayer：资源(图片)显示器，用于显示或操作资源。<br>比如 ImageView，这几个图片缓存都不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。</p>
<p>(5) Processor 资源(图片)处理器<br>负责处理资源，比如旋转、压缩、截取等。</p>
<p>以上概念的称呼在不同图片缓存中可能不同，比如 Displayer 在 ImageLoader 中叫做 ImageAware，在 Picasso 和 Glide 中叫做 Target。</p>
<p>##三、共同优点</p>
<ol>
<li><p>使用简单<br>都可以通过一句代码可实现图片获取和显示。</p>
</li>
<li><p>可配置度高，自适应程度高<br>图片缓存的下载器(重试机制)、解码器、显示器、处理器、内存缓存、本地缓存、线程池、缓存算法等大都可轻松配置。<br>自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。<br>比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。</p>
</li>
<li><p>多级缓存<br>都至少有两级缓存、提高图片加载速度。</p>
</li>
<li><p>支持多种数据源<br>支持多种数据源，网络、本地、资源、Assets 等</p>
</li>
</ol>
<ol>
<li>支持多种 Displayer<br>不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。</li>
</ol>
<p>其他小的共同点包括支持动画、支持 transform 处理、获取 EXIF 信息等。</p>
<p>##四、ImageLoader 设计及优点</p>
<p>###1. 总体设计及流程</p>
<p>上面是 ImageLoader 的总体设计图。整个库分为 ImageLoaderEngine，Cache 及 ImageDownloader，ImageDecoder，BitmapDisplayer，BitmapProcessor 五大模块，其中 Cache 分为 MemoryCache 和 DiskCache 两部分。</p>
<p>简单的讲就是 ImageLoader 收到加载及显示图片的任务，并将它交给 ImageLoaderEngine，ImageLoaderEngine 分发任务到具体线程池去执行，任务通过 Cache 及 ImageDownloader 获取图片，中间可能经过 BitmapProcessor 和 ImageDecoder 处理，最终转换为Bitmap 交给 BitmapDisplayer 在 ImageAware 中显示。</p>
<p>###2. ImageLoader 优点</p>
<p>#####(1) 支持下载进度监听</p>
<p>#####(2) 可以在 View 滚动中暂停图片加载<br>通过 PauseOnScrollListener 接口可以在 View 滚动中暂停图片加载。</p>
<p>#####(3) 默认实现多种内存缓存算法<br>这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。</p>
<p>#####(4) 支持本地缓存文件名规则定义</p>
<p>##五、Picasso 设计及优点</p>
<p>###1. 总体设计及流程</p>
<p>上面是 Picasso 的总体设计图。整个库分为 Dispatcher，RequestHandler 及 Downloader，PicassoDrawable 等模块。</p>
<p>Dispatcher 负责分发和处理 Action，包括提交、暂停、继续、取消、网络状态变化、重试等等。</p>
<p>简单的讲就是 Picasso 收到加载及显示图片的任务，创建 Request 并将它交给 Dispatcher，Dispatcher 分发任务到具体 RequestHandler，任务通过 MemoryCache 及 Handler(数据获取接口) 获取图片，图片获取成功后通过 PicassoDrawable 显示到 Target 中。</p>
<p>需要注意的是上面 Data 的 File system 部分，Picasso 没有自定义本地缓存的接口，默认使用 http 的本地缓存，API 9 以上使用 okhttp，以下使用 Urlconnection，所以如果需要自定义本地缓存就需要重定义 Downloader。</p>
<p>###2. Picasso 优点</p>
<p>#####(1) 自带统计监控功能<br>支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。</p>
<p>#####(2) 支持优先级处理<br>每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。</p>
<p>#####(3) 支持延迟到图片尺寸计算完成加载</p>
<p>#####(4) 支持飞行模式、并发线程数根据网络类型而变<br>手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4， 4g 为 3，3g 为 2。<br>这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。</p>
<p>#####(5) “无”本地缓存<br>无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。</p>
<p>##六、Glide 设计及优点</p>
<p>###1. 总体设计及流程</p>
<p>上面是 Glide 的总体设计图。整个库分为 RequestManager(请求管理器)，Engine(数据获取引擎)、 Fetcher(数据获取器)、MemoryCache(内存缓存)、DiskLRUCache、Transformation(图片处理)、Encoder(本地缓存存储)、Registry(图片类型及解析器配置)、Target(目标) 等模块。</p>
<p>简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后 Transformation 处理后交给 Target。</p>
<p>Glide 依赖于 DiskLRUCache、GifDecoder 等开源库去完成本地缓存和 Gif 图片解码工作。</p>
<p>###2. Glide 优点</p>
<p>#####(1) 图片缓存-&gt;媒体缓存<br>Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。</p>
<p>#####(2) 支持优先级处理</p>
<p>#####(3) 与 Activity/Fragment 生命周期一致，支持 trimMemory<br>Glide 对每个 context 都保持一个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致，并且有对应的 trimMemory 接口实现可供调用。</p>
<p>#####(4) 支持 okhttp、Volley<br>Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。</p>
<p>#####(5) 内存友好</p>
<p>① Glide 的内存缓存有个 active 的设计<br>从内存缓存中取数据时，不像一般的实现用 get，而是用 remove，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。</p>
<p>② 内存缓存更小图片<br>Glide 以 url、view_width、view_height、屏幕的分辨率等做为联合 key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小</p>
<p>③ 与 Activity/Fragment 生命周期一致，支持 trimMemory</p>
<p>④ 图片默认使用默认 RGB_565 而不是 ARGB_888<br>虽然清晰度差些，但图片更小，也可配置到 ARGB_888。</p>
<p>其他：Glide 可以通过 signature 或不使用本地缓存支持 url 过期</p>
<p>##七、汇总</p>
<p>三者总体上来说，ImageLoader 的功能以及代理容易理解长度都一般。</p>
<p>Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰，一两个小时就能叫深入的了解完。</p>
<p>Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决。</p>
<p>更多图片缓存库可见：<a href="http://p.codekk.com/?s=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98" target="_blank" rel="external">Android 图片缓存库</a></p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之MVP架构/" itemprop="url">
                  进阶系列MVP架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:25:51+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之MVP架构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之MVP架构/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MVP-Model-View-Presenter"><a href="#MVP-Model-View-Presenter" class="headerlink" title="MVP(Model-View-Presenter)"></a>MVP(Model-View-Presenter)</h3><p>该软件设计架构在Android开发过程中能够分离出项目的业务逻辑代码和视图展现代码，达到解耦模块化的效果。</p>
<p>###MVP如何工作：<br>      在项目开发时，将系统分为数据模型（Model），视图（View），和Presenter（预处理层）三个部分。<br>其中</p>
<p>Presenter    作为中间层，从Model层获取数据,进行处理之后,交给View层进行展示.</p>
<p>View          只需要展示数据</p>
<p>Model         完成数据的请求处理</p>
<p>###各模块具体职责:</p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/13/进阶系列之设计模式/" itemprop="url">
                  进阶系列设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-13T16:24:43+08:00" content="2016-08-13">
              2016-08-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/13/进阶系列之设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/13/进阶系列之设计模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HeadFirst设计模式"><a href="#HeadFirst设计模式" class="headerlink" title="HeadFirst设计模式"></a>HeadFirst设计模式</h2><h3 id="一、-设计原则"><a href="#一、-设计原则" class="headerlink" title="一、 设计原则"></a>一、 设计原则</h3><p>1） 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p>
<p>2） 针对接口编程，而不是针对实现编程。</p>
<p>3） 多用组合，少用继承。</p>
<p>4） 为了交互对象之间的松耦合设计而努力。</p>
<h3 id="二、-设计模式"><a href="#二、-设计模式" class="headerlink" title="二、 设计模式"></a>二、 设计模式</h3><h4 id="『策略模式』"><a href="#『策略模式』" class="headerlink" title="『策略模式』"></a>『策略模式』</h4><pre><code>定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
</code></pre><h4 id="『观察者模式』"><a href="#『观察者模式』" class="headerlink" title="『观察者模式』"></a>『观察者模式』</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/优秀第三方SDK分析-Fresco/" itemprop="url">
                  优秀第三方SDK分析-Fresco
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-20T23:09:23+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/20/优秀第三方SDK分析-Fresco/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/20/优秀第三方SDK分析-Fresco/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/Android优化交互-协调布局详解/" itemprop="url">
                  Android优化交互-协调布局详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-20T22:59:11+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/20/Android优化交互-协调布局详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/20/Android优化交互-协调布局详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/Android优化交互-嵌套机制详解/" itemprop="url">
                  Android优化交互-嵌套机制详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-20T22:57:42+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/20/Android优化交互-嵌套机制详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/20/Android优化交互-嵌套机制详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/AndroidStudio之Plugins/" itemprop="url">
                  AndroidStudio之Plugins
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T21:10:00+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/14/AndroidStudio之Plugins/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/AndroidStudio之Plugins/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/07/AndroidStudio之Gradle/" itemprop="url">
                  AndroidStudio之Gradle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T19:31:22+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Gradle/" itemprop="url" rel="index">
                    <span itemprop="name">Gradle</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/07/AndroidStudio之Gradle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/AndroidStudio之Gradle/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="Gradle-概述"><a href="#Gradle-概述" class="headerlink" title="Gradle 概述"></a>Gradle 概述</h3><p>是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – <a href="https://en.wikipedia.org/wiki/Groovy_(programming_language">Groovy</a>) 编写而成，再加上<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL（领域特定语言）</a>组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/07/AndroidStudio之Gradle/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/07/Android部落格之RxJava框架/" itemprop="url">
                  Android部落格之RxJava框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T09:14:57+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/07/Android部落格之RxJava框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/Android部落格之RxJava框架/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM</p>
<p>一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/07/Android部落格之RxJava框架/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/Android部落格之Retrofit框架/" itemprop="url">
                  Android部落格之Retrofit框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T09:23:58+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/02/Android部落格之Retrofit框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/02/Android部落格之Retrofit框架/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/Android部落格之OkHttp框架/" itemprop="url">
                  Android部落格之OkHttp框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-01T10:20:47+08:00" content="2016-06-01">
              2016-06-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HTTP-Client/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP Client</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/01/Android部落格之OkHttp框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/01/Android部落格之OkHttp框架/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>来自<a href="http://square.github.io/okhttp/#examples">OkHttp官方网站</a></p>
<p><a href="http://blog.piasy.com/img/201607/okhttp_full_process.png">整体流程图-参考</a></p>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><blockquote>
<p>官网概述：Android和Java应用程序的HTTP&amp;HTTP/2的客户端</p>
</blockquote>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/01/Android部落格之OkHttp框架/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/十里平湖霜满天/" itemprop="url">
                  十里平湖霜满天
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-31T17:27:09+08:00" content="2016-05-31">
              2016-05-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/31/十里平湖霜满天/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/31/十里平湖霜满天/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://img.wdjimg.com/mms/icon/v1/9/9c/de366a247aeddb5809193003fa9c99c9_256_256.png"
               alt="LeoCheung" />
          <p class="site-author-name" itemprop="name">LeoCheung</p>
          <p class="site-description motion-element" itemprop="description">做人如果没有梦想,那和咸鱼有什么分别</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeoCheung</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"LeoCheung"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  
  
</body>
</html>
