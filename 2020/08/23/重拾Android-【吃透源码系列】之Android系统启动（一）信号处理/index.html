<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>重拾Android-【吃透源码系列】之Android系统启动（一）信号处理 | ONE·PIECE</title><meta name="description" content="重拾Android-【吃透源码系列】之Android系统启动（一）信号处理"><meta name="keywords" content="framework源码"><meta name="author" content="Leo·Cheung,leocheung4ever@gmail.com"><meta name="copyright" content="Leo·Cheung"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="DOzi6zRsQ2GdSxTA0T1-9Ul8fB_XbMM43baLPg1CuOo"><meta name="baidu-site-verification" content="S7HPSRHOBw"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="重拾Android-【吃透源码系列】之Android系统启动（一）信号处理"><meta name="twitter:description" content="重拾Android-【吃透源码系列】之Android系统启动（一）信号处理"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286990.jpg"><meta property="og:type" content="article"><meta property="og:title" content="重拾Android-【吃透源码系列】之Android系统启动（一）信号处理"><meta property="og:url" content="http://tufusi.com/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%90%83%E9%80%8F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BAndroid%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"><meta property="og:site_name" content="ONE·PIECE"><meta property="og:description" content="重拾Android-【吃透源码系列】之Android系统启动（一）信号处理"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286990.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v4.7.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://tufusi.com/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%90%83%E9%80%8F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8BAndroid%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"><link rel="prev" title="重拾Android-【吃透源码系列】之四大组件的工作过程" href="http://tufusi.com/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%90%83%E9%80%8F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"><link rel="next" title="重拾Android-【实战系列】MVVM之基于Artifactory和Jetpack高级架构" href="http://tufusi.com/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E3%80%91MVVM%E4%B9%8B%E5%9F%BA%E4%BA%8EArtifactory%E5%92%8CJetpack%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RG8HX7QXWX","apiKey":"a183cbbffa921b0dddc2872cfd1abd86","indexName":"WEBSITE001","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://tufusi.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ONE·PIECE</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="http://tufusi.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">209</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">70</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Android-整体系统框架"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Android 整体系统框架</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Linux-Kernel"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Linux Kernel</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#HAL-Hardware-Abstract-Layer"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">HAL(Hardware Abstract Layer)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Android-Runtime"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Android Runtime</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Native-C-C-库"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">Native C/C++ 库</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java-framework"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">Java framework</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Application"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">Application</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小结"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#“万物生”-init-函数"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">“万物生” - init 函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#init-概述"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">init 概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#init-分析"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">init 分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号处理"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">信号处理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#小结-1"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">小结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#附上-init-main-函数源码"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">附上 init main 函数源码</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-整体系统框架"><span class="toc-number">1.</span> <span class="toc-text">Android 整体系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-Kernel"><span class="toc-number">1.1.</span> <span class="toc-text">Linux Kernel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAL-Hardware-Abstract-Layer"><span class="toc-number">1.2.</span> <span class="toc-text">HAL(Hardware Abstract Layer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Runtime"><span class="toc-number">1.3.</span> <span class="toc-text">Android Runtime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-C-C-库"><span class="toc-number">1.4.</span> <span class="toc-text">Native C/C++ 库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-framework"><span class="toc-number">1.5.</span> <span class="toc-text">Java framework</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Application"><span class="toc-number">1.6.</span> <span class="toc-text">Application</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">1.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#“万物生”-init-函数"><span class="toc-number">2.</span> <span class="toc-text">“万物生” - init 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#init-概述"><span class="toc-number">2.1.</span> <span class="toc-text">init 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-分析"><span class="toc-number">2.2.</span> <span class="toc-text">init 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号处理"><span class="toc-number">2.2.1.</span> <span class="toc-text">信号处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-1"><span class="toc-number">2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附上-init-main-函数源码"><span class="toc-number">3.</span> <span class="toc-text">附上 init main 函数源码</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286990.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">重拾Android-【吃透源码系列】之Android系统启动（一）信号处理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-23<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 17 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在了解整个 Android 系统启动前，我们应先熟悉 Android 系统的整个架构，否则，针对某一层去进行深入理解找不到方向，容易产生“厌码症”。</p>
<a id="more"></a>
<p>这里指出文中查看源码均是基于Android 9版本，所用工具是 SourceInsight</p>
<h1 id="Android-整体系统框架"><a href="#Android-整体系统框架" class="headerlink" title="Android 整体系统框架"></a>Android 整体系统框架</h1><p><img alt="Android源码架构.png" data-src="https://i.loli.net/2020/08/29/9YTzClQimEDN8ap.png" class="lazyload"></p>
<h2 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h2><p>Android 平台的基础是 Linux 内核。这一层包含 Linux 内核以及一些驱动模块（比如 USB 驱动，Camera 驱动 等等）。</p>
<h2 id="HAL-Hardware-Abstract-Layer"><a href="#HAL-Hardware-Abstract-Layer" class="headerlink" title="HAL(Hardware Abstract Layer)"></a>HAL(Hardware Abstract Layer)</h2><p>硬件抽象层提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个模块，其中每个模块均由特定类型的硬件组件实现界面，例如 BlueTeath、Camera等等。当框架 API 要求访问设备硬件时，Android 系统降为该硬件组件加载对应模块。</p>
<h2 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h2><p>对于运行 Android 5.0 （API LEVEL = 21）或更高设备，每个应用都在其自己的进程中运行，并且有它们各自的Android Runtime（ART）示例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种转为 Android 设计的字节码格式文件，经过 optimize，使用的内存更少。编译工具链（例如 <a href="https://blog.csdn.net/wang_hufeng/article/details/80774712" target="_blank" rel="noopener">Jack</a>）将 Java 源代码编译成 Android dex 字节码。替换之前的 Android 工具链，即由 <code>javac</code>, <code>proGrard</code>, <code>javajar</code> 和 <code>dx</code> 多个工具组成的集合，使其可在 Android 平台上运行。</p>
<p><strong>ART的部分主要功能有：</strong></p>
<ul>
<li><p>预先（AOT）和即时（JIT）编译</p>
</li>
<li><p>优化的垃圾回收（GC）机制</p>
</li>
<li><p>更好的调试支持，包括：专用采样分析器、详细的诊断异常和奔溃报告，并且能够设置监视点以及监控特定字段。</p>
</li>
</ul>
<p>但是在 API21之前，Android 系统采用的是 Dalvik 虚拟机来作为 Android runtime的。</p>
<h2 id="Native-C-C-库"><a href="#Native-C-C-库" class="headerlink" title="Native C/C++ 库"></a>Native C/C++ 库</h2><p>Android 大部分核心系统组件和服务（比如 ART 、HAL）均是由其原生代码构建的，所以也就需要 C/C++ 编写的原生库。Android 平台提供 Java 框架 API，以此向应用层提供可使用的部分原生库功能。例如：可以通过 Android 框架的 Java OpenGL API 访问 <a href="https://www.jianshu.com/p/99daa25b4573" target="_blank" rel="noopener">OpenGL ES</a>，以支持在应用中绘制和操作 2D 和 3D 图形。</p>
<h2 id="Java-framework"><a href="#Java-framework" class="headerlink" title="Java framework"></a>Java framework</h2><p>我们可以通过 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 构成了 Android 应用所需的各种构件模块，他们可以简化核心模块化系统组件和服务的重复使用。</p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>系统附带的一些常用的核心应用，比如：电子邮件、短信、日历、浏览器、联系人等等。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>介绍完系统架构，接下来就要先从 Native 层开始看起了，这里面涉及到很多核心的 Android 系统组件和服务，源码下载可以选择<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">AOSP</a>，这里附上清华大学镜像网站以供下载学习。</p>
<p><strong>官方源码文档有这么一句话</strong></p>
<blockquote>
<center><font size="4px">init.rc is the primary .rc file and is loaded by the init executable at the beginning of its execution. </font></center>

<center><font size="4px">It is responsible for the initial set up of the system.</font></center>

</blockquote>
<p> 既然 init 函数负责系统的初始化，那么就从这个入口开始吃透 Android 系统启动流程。</p>
<h1 id="“万物生”-init-函数"><a href="#“万物生”-init-函数" class="headerlink" title="“万物生” - init 函数"></a>“万物生” - init 函数</h1><h2 id="init-概述"><a href="#init-概述" class="headerlink" title="init 概述"></a>init 概述</h2><p>init 作为 Linux 系统（也是 Android 系统）中用户空间的第一个进程，其进程号是为1，作为第一号进程，它被赋予了很多极其重要的工作责任，其中之一就是<strong>负责创建系统中的关键进程</strong>，尤其是 zygote。它是 Java 维度世界的缔造者。那么接下来就开始介绍 init 如何创建 zygote。会很长，慢慢来…</p>
<h2 id="init-分析"><a href="#init-分析" class="headerlink" title="init 分析"></a>init 分析</h2><p>由于源码 main 函数略长，这里先详述 main 方法中的4大核心知识点之一：信号处理，后面会分篇章去介绍：rc文件语法、启动服务 以及 属性服务。</p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p><strong>sigchld_handler_init();</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init sigchld_handler.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为 SIGCHLD 创建一个信令机制。</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socketpair() 创建一对未命名、相互连接的 UNIX 域套接字</span></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>, s) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"socketpair failed in sigchld_handler_init"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal_write_fd = s[<span class="number">0</span>];</span><br><span class="line">    signal_read_fd = s[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果捕获 SIGHLD 信号，就将其写入 signal_write_fd 文件句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号处理函数句柄，当有信号产生时，会向上面创建的 socket 写入数据，</span></span><br><span class="line">    <span class="comment">// 当 epoll 监控到该socketpair中的fd可读时，就会调用注册的函数取处理该事件</span></span><br><span class="line">    act.sa_handler = SIGCHLD_handler; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// SA_NOCLDSTOP 使 init 进程只有在其子进程终止时才会收到 SIGCHLD 信号</span></span><br><span class="line">    act.sa_flags = SA_NOCLDSTOP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SIGCHLD 信号处理方式</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理这之前退出的子进程：调用 waitpid() 等待子进程退出，waitpid() 会拿到一个 siginfo，这个 siginfo 中有退出的子进程的 pid</span></span><br><span class="line">    ReapAnyOutstandingChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 epoll 机制</span></span><br><span class="line">    register_epoll_handler(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后通过 epoll_ctl() 向 epoll_fd 注册本地 socket，监听其是否可读；然后注册了 epoll 事件的处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void register_epoll_handler(int fd, void (*fn)()) &#123; </span><br><span class="line">    epoll_event ev; </span><br><span class="line"></span><br><span class="line">    //对文件描述符可读 </span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">    //保存指定的函数指针，用于后续的事件处理 </span><br><span class="line">    ev.data.ptr = reinterpret_cast&lt;void*&gt;(fn);</span><br><span class="line"></span><br><span class="line">    //向 epoll_fd 添加要监听的fd，比如property、keychord和signal事件监听</span><br><span class="line">    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == -1) &#123; </span><br><span class="line">        ERROR(&quot;epoll_ctl failed: %s\n&quot;, strerror(errno)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说明一下，每个进程在处理其他进程发送的 signal 信号时都需要先注册，当进程的运行状态改变或者终止时，会产生某个 signal，init 进程是所有用户空间进程的父进程，当其子进程终止时产生信号，传递参数给 sigaction 结构体，便完成信号处理的过程。</p>
<p>这里在看一下 <strong>信号写入与读取</strong> 两个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signal 读取</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear outstanding requests.</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">read</span>(signal_read_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    ReapAnyOutstandingChildren();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal 写入</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SIGCHLD_handler</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(<span class="built_in">write</span>(signal_write_fd, <span class="string">"1"</span>, <span class="number">1</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"write(signal_write_fd) failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 <strong>ReapAnyOutstandingChildren()</strong> 函数，这又是很长的…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapAnyOutstandingChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ReapOneProcess()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ReapOneProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 这里会返回一个僵尸进程（僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。） </span></span><br><span class="line">    <span class="comment">// 或者通知我们已经没有僵尸进程遗留</span></span><br><span class="line">    <span class="comment">// 这里不接收进程，如下所示</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class="number">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"waitid failed"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pid = siginfo.si_pid;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时我们知道我们有一个僵尸进程, 所以在此之前无论何时返回我们都使用 scopeguard 来回收这个进程</span></span><br><span class="line">    <span class="comment">// 我们不想要过早的回收僵尸进程 as in Service::Reap(), we kill(-pid, ...) </span></span><br><span class="line">    <span class="comment">// 并且我们希望进程在整个使用过程中（以及将来的使用过程中）仍然保持有效</span></span><br><span class="line">    <span class="keyword">auto</span> reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, <span class="literal">nullptr</span>, WNOHANG)); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wait_string;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PropertyChildReap(pid)) &#123;</span><br><span class="line">        name = <span class="string">"Async property child"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class="line">        name = <span class="string">"Subcontext"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid); <span class="comment">// ------------------------------------- （1）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service) &#123;</span><br><span class="line">            name = StringPrintf(<span class="string">"Service '%s' (pid %d)"</span>, service-&gt;name().c_str(), pid);</span><br><span class="line">            <span class="keyword">if</span> (service-&gt;flags() &amp; SVC_EXEC) &#123;</span><br><span class="line">                <span class="keyword">auto</span> exec_duration = boot_clock::now() - service-&gt;time_started();</span><br><span class="line">                <span class="keyword">auto</span> exec_duration_ms =</span><br><span class="line">                    <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(exec_duration).count();</span><br><span class="line">                wait_string = StringPrintf(<span class="string">" waiting took %f seconds"</span>, exec_duration_ms / <span class="number">1000.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = StringPrintf(<span class="string">"Untracked pid %d"</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siginfo.si_code == CLD_EXITED) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; name &lt;&lt; <span class="string">" exited with status "</span> &lt;&lt; siginfo.si_status &lt;&lt; wait_string;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; name &lt;&lt; <span class="string">" received signal "</span> &lt;&lt; siginfo.si_status &lt;&lt; wait_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!service) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    service-&gt;Reap(siginfo); <span class="comment">// ------------------------------------- （2）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service-&gt;flags() &amp; SVC_TEMPORARY) &#123;</span><br><span class="line">        ServiceList::GetInstance().RemoveService(*service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）这之后会根据这个 pid 从 ServiceList 中找到这个退出的子进程的 Service 对象；</p>
<p>（2）然后调用这个 Service 对象的 Reap()函数；</p>
<p>再看 Reap 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init Service.cpp</span></span><br><span class="line"><span class="keyword">void</span> Service::Reap(<span class="keyword">const</span> <span class="keyword">siginfo_t</span>&amp; siginfo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        KillProcessGroup(SIGKILL); <span class="comment">// -------------------------------- （1）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any descriptor resources we may have created.</span></span><br><span class="line">    <span class="built_in">std</span>::for_each(descriptors_.<span class="built_in">begin</span>(), descriptors_.<span class="built_in">end</span>(),</span><br><span class="line">                  <span class="built_in">std</span>::bind(&amp;DescriptorInfo::Clean, <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : reap_callbacks_) &#123;</span><br><span class="line">        f(siginfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_EXEC) UnSetExec(); <span class="comment">// -------------------------------- （2）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_TEMPORARY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pid_ = <span class="number">0</span>;</span><br><span class="line">    flags_ &amp;= (~SVC_RUNNING); <span class="comment">// -------------------------------- （3）</span></span><br><span class="line">    start_order_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Oneshot processes go into the disabled state on exit,</span></span><br><span class="line">    <span class="comment">// except when manually restarted.</span></span><br><span class="line">    <span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we crash &gt; 4 times in 4 minutes, reboot into recovery.</span></span><br><span class="line">    boot_clock::time_point now = boot_clock::now();</span><br><span class="line">    <span class="keyword">if</span> ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; time_crashed_ + <span class="number">4</span><span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++crash_count_ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                LOG(FATAL) &lt;&lt; <span class="string">"critical process '"</span> &lt;&lt; name_ &lt;&lt; <span class="string">"' exited 4 times in 4 minutes"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time_crashed_ = now;</span><br><span class="line">            crash_count_ = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">    flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line">    onrestart_.ExecuteAllCommands(); <span class="comment">// -------------------------------- （4）</span></span><br><span class="line"></span><br><span class="line">    NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）首先调用 KillProcessGroup(SIGKILL)，这个函数会调用 processgroup.cpp 中的 KillProcessGroup()：目的是kill掉退出的子进程的所有子进程。</p>
<p>（2）调用 UnsetExec() 将 is_exec_service_running_ 设置为false并将 SVC_EXEC flag清掉；</p>
<p>（3）将 flags_ 中的SVC_RESTARTING flag 赋值</p>
<p>（4）调用 onrestart_.ExecuteAllCommands()：执行此服务的所有 onrestart 命令。</p>
<p>在 init  main函数死循环中，会不断调用 Service::is_exec_service_running() 函数，这个函数是直接 return Service 对象的 is_exec_service_running_ 静态布尔变量。因为上面第（2）步有将 is_exec_service_running_ 设置为false，所以这个if条件不命中，就会调用 RestartProcessed() 函数。在这个函数中，会从 ServiceList 中取出每一个 Service 对象，然后判断其 flags_ 遍历中是否有 SVC_RESTARTING flag，如果有，最终会调到这个 service 的 Start() 去再次启动这个service。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>综上，大致可以捋清楚 <strong>Android Init进程对信号的处理流程</strong>：</p>
<p>在 Android 中，当一个进程 exit() 退出时，会向它的父进程发送一个 SIGCHLD 信号。父进程收到该信号后，会释放分配给该子进程的系统资源；并且父进程需要调用 wait() 或者 waitpid() 等待子进程结束。如果父进程没有做这种处理，且父进程初始化时也没有调用 signal(SIGCHLD, SIG_IGN) 来忽略对 SIGCHLD 的处理，那么子进程将一直保持当前的退出状态，不会完成退出。但是这样的子进程不会被调度，所表现出的只是在进程列表中占据一个位置，保存了该进程的一些 siginfo，比如：进程的PID、终止状态、CPU调度使用时间等信息；类似于对于这种进程又称之为 “Zoombie”进程。</p>
<p>在 Linux 中，设置僵尸进程的目的是维护子进程的一些信息，以供父进程后续查询获取该进程之用。特殊的，如果一个父进程终止，那么它的所有僵尸子进程的父进程就会被设置为 Init进程（PID为1），并由 Init 进程负责回收这些僵尸进程（Init进程将 wait() / waitpid() 这些进程，并清除它们在进程列表中的信息）。</p>
<p>由于僵尸进程仍然会占据进程列表中的位置，而 Linux 所支持的最大进程数量是有限的，超过这个阈值，系统就无法创建进程。所以，是很有必要清除那些僵尸进程的，以保证系统的正常操作，而这也是 native 层 Init进程 在对信号处理上所赋予的权力所在。</p>
<h1 id="附上-init-main-函数源码"><a href="#附上-init-main-函数源码" class="headerlink" title="附上 init main 函数源码"></a>附上 init main 函数源码</h1><p>最后附上源码注解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sigchld_handler.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ueventd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"watchdogd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system/core/init Init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line">        <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">        <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上四个条件返回均在声明文件里才能找到相关命中条件操作，跟旧版本有差，具体查找见 #include 并查看相应的cpp文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入第一阶段</span></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (getenv(<span class="string">"INIT_SECOND_STAGE"</span>) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clear the umask. --  Linux umask命令指定在建立文件时预设的权限掩码 */</span></span><br><span class="line">        umask(<span class="number">0</span>); <span class="comment">// 设置创建新文件时的权限遮罩</span></span><br><span class="line"></span><br><span class="line">        clearenv(); <span class="comment">// 清除所有的环境变量</span></span><br><span class="line">        setenv(<span class="string">"PATH"</span>, _PATH_DEFPATH, <span class="number">1</span>); <span class="comment">// 设置环境变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line"><span class="comment">         * on / and then we'll let the rc file figure out the rest. -- 创建文件系统</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">        mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">        mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</span><br><span class="line"></span><br><span class="line">        chmod(<span class="string">"/proc/cmdline"</span>, <span class="number">0440</span>); <span class="comment">// 禁止将原始命令行暴露给非特权进程。</span></span><br><span class="line">        <span class="keyword">gid_t</span> groups[] = &#123; AID_READPROC &#125;;</span><br><span class="line">        setgroups(arraysize(groups), groups);</span><br><span class="line">        mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mount(<span class="string">"selinuxfs"</span>, <span class="string">"/sys/fs/selinux"</span>, <span class="string">"selinuxfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        mknod(<span class="string">"/dev/kmsg"</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class="line">            mknod(<span class="string">"/dev/kmsg_debug"</span>, S_IFCHR | <span class="number">0622</span>, makedev(<span class="number">1</span>, <span class="number">11</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mknod(<span class="string">"/dev/random"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        mknod(<span class="string">"/dev/urandom"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/mnt"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">              <span class="string">"mode=0755,uid=0,gid=1000"</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/mnt/vendor"</span>, <span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tmpfs已安装在/dev上，并且有了/dev/kmsg，这样就可以和外面的世界“交流”起来啦……</span></span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ☆☆☆☆☆☆☆☆☆☆☆ 以上是一些挂载文件操作 ☆☆☆☆☆☆☆☆☆☆☆</span></span><br><span class="line">        <span class="comment">// 在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 </span></span><br><span class="line">        <span class="comment">// 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。</span></span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"init first stage started!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetInitAvbVersionInRecovery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果全局启动项通过则启用 securecomputing mode（一种沙箱安全机制）</span></span><br><span class="line">        <span class="comment">// 否则没通过就交给 zygote 启用</span></span><br><span class="line">        <span class="comment">// 在Linux系统里，大量的系统调用（systemcall）直接暴露给用户态程序。</span></span><br><span class="line">        <span class="comment">// 但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。</span></span><br><span class="line">        <span class="comment">// 通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。</span></span><br><span class="line">        global_seccomp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 安装 SELinux, 加载SELinux策略：指定进程可以访问那些文件</span></span><br><span class="line">        SelinuxSetupKernelLogging();</span><br><span class="line">        SelinuxInitialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the kernel domain, so re-exec init to transition to the init domain now</span></span><br><span class="line">        <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">        <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">"/init"</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(FATAL) &lt;&lt; <span class="string">"restorecon failed of /init failed"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setenv(<span class="string">"INIT_SECOND_STAGE"</span>, <span class="string">"true"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kNanosecondsPerMillisecond = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">uint64_t</span> start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;</span><br><span class="line">        setenv(<span class="string">"INIT_STARTED_AT"</span>, <span class="built_in">std</span>::to_string(start_ms).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        execv(path, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">        <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时处于init的第二阶段：属性服务相关是Android系统中另一个比较重要的模块，会在另一篇中详述</span></span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置所有进程都可以访问的会话密匙环。它将保存FBE加密密钥之类的东西。任何进程都不应覆盖其会话密钥环。</span></span><br><span class="line">    keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指示正在引导到后台fw加载器，等等。</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">open</span>(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    <span class="comment">// 初始化属性服务</span></span><br><span class="line">    property_init(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果参数同时在命令行和DT中传递，DT中设置的属性总是优先于命令行属性。</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内核变量传播到内部变量，用于init以及当前所需的属性。</span></span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init 的启动时间提供给 bootstat 进行日志记录</span></span><br><span class="line">    property_set(<span class="string">"ro.boottime.init"</span>, getenv(<span class="string">"INIT_STARTED_AT"</span>));</span><br><span class="line">    property_set(<span class="string">"ro.boottime.init.selinux"</span>, getenv(<span class="string">"INIT_SELINUX_TOOK"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 libavb 匹配第三代构建版本 Framework-only OTA（over the air）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* avb_version = getenv(<span class="string">"INIT_AVB_VERSION"</span>);</span><br><span class="line">    <span class="keyword">if</span> (avb_version) property_set(<span class="string">"ro.boot.avb_version"</span>, avb_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除我们的环境变量</span></span><br><span class="line">    unsetenv(<span class="string">"INIT_SECOND_STAGE"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_STARTED_AT"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_SELINUX_TOOK"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_AVB_VERSION"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在为第二阶段：设置 SELinux</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelabelInitialize();</span><br><span class="line">    SelinuxRestoreContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 文件句柄</span></span><br><span class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"epoll_create1 failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理 </span></span><br><span class="line">    sigchld_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsRebootCapable()) &#123;</span><br><span class="line">        <span class="comment">// 如果 init 没有 CAP_SYS_BOOT 功能, 那么它就会在容器中运行.</span></span><br><span class="line">        <span class="comment">// 在这种情况下, 接收 SIGTERM 将导致系统关闭。</span></span><br><span class="line">        InstallSigtermHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基操：加载属性服务默认启动设置、导入oem锁状态 etc.</span></span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    start_property_service();</span><br><span class="line">    set_usb_controller();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line">    subcontexts = InitializeSubcontexts();</span><br><span class="line"></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开这个选项并丢弃信息日志记录将增加0.2秒 -- 为了节省0.2秒，this is 细节啊！</span></span><br><span class="line">    <span class="comment">// Nexus 9启动时间，因此默认禁用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) DumpState();</span><br><span class="line"></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个等待冷启动完成的操作队列，这样我们就能知道 ueventd 已经设置了所有的/dev…</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    <span class="comment">// ... 这样我们就可以开始对需要来自/dev的内容的操作进行排队。</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class="string">"SetMmapRndBits"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class="string">"SetKptrRestrict"</span>);</span><br><span class="line">    am.QueueBuiltinAction(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">    am.QueueBuiltinAction(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发所有的启动操作，让我们开始吧</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要在充电器模式下安装文件系统或启动核心系统服务。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据属性的运行状态运行所有的属性触发器</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认情况下，一直休眠状态，知道触发某些事情</span></span><br><span class="line">        <span class="keyword">int</span> epoll_timeout_ms = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;</span><br><span class="line">            do_shutdown = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;</span><br><span class="line">                shutting_down = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环遍历事件队列，直到有操作服务需要执行</span></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!shutting_down) &#123;</span><br><span class="line">                <span class="keyword">auto</span> next_process_restart_time = RestartProcesses();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果有某个过程需要重新启动，及时停止休眠状态</span></span><br><span class="line">                <span class="keyword">if</span> (next_process_restart_time) &#123;</span><br><span class="line">                    epoll_timeout_ms = <span class="built_in">std</span>::chrono::<span class="built_in">ceil</span>&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(</span><br><span class="line">                                           *next_process_restart_time - boot_clock::now())</span><br><span class="line">                                           .count();</span><br><span class="line">                    <span class="keyword">if</span> (epoll_timeout_ms &lt; <span class="number">0</span>) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果还有其他的工作需要做, 立马再次醒来</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="comment">// 循环等待事件发生</span></span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, epoll_timeout_ms));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"epoll_wait failed"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/framework%E6%BA%90%E7%A0%81/">framework源码    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286990.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%90%83%E9%80%8F%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E3%80%91%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/海边风景/794.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>重拾Android-【吃透源码系列】之四大组件的工作过程</span></div></a></div><div class="next-post pull_right"><a href="/2020/08/23/%E9%87%8D%E6%8B%BEAndroid-%E3%80%90%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E3%80%91MVVM%E4%B9%8B%E5%9F%BA%E4%BA%8EArtifactory%E5%92%8CJetpack%E9%AB%98%E7%BA%A7%E6%9E%B6%E6%9E%84/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/280301.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>重拾Android-【实战系列】MVVM之基于Artifactory和Jetpack高级架构</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/23/重拾Android-【吃透源码系列】之WMS/" title="重拾Android-【吃透源码系列】之WMS"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286980.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之WMS</div></a></div><div class="relatedPosts_item"><a href="/2020/08/31/重拾Android-【吃透源码系列】之Activity/" title="重拾Android-【吃透源码系列】之Activity"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/300.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之Activity</div></a></div><div class="relatedPosts_item"><a href="/2020/08/29/重拾Android-【吃透源码系列】之Android系统启动（三）启动服务/" title="重拾Android-【吃透源码系列】之Android系统启动（三）启动服务"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/302.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之Android系统启动（三）启动服务</div></a></div><div class="relatedPosts_item"><a href="/2020/08/25/重拾Android-【吃透源码系列】之Binder/" title="重拾Android-【吃透源码系列】之Binder"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286986.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之Binder</div></a></div><div class="relatedPosts_item"><a href="/2020/08/24/重拾Android-【吃透源码系列】之PKMS/" title="重拾Android-【吃透源码系列】之PKMS"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/503.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之PKMS</div></a></div><div class="relatedPosts_item"><a href="/2020/08/29/重拾Android-【吃透源码系列】之Android系统启动（四）属性服务/" title="重拾Android-【吃透源码系列】之Android系统启动（四）属性服务"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/303.jpg"><div class="relatedPosts_title">重拾Android-【吃透源码系列】之Android系统启动（四）属性服务</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzU5OC8yNDA5OA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/286990.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2020 By Leo·Cheung</div><div class="footer_custom_text">Some of life, you have to go to the great challanges. - By Kobe Bryant</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>浙ICP备19024714号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.js"></script><div class="aplayer" id="player"><script>$(function() {
    $.ajax({
        url: "https://api.i-meto.com/meting/api?server=netease&type=playlist&id=416198729",
        success: function(e) {
            var aplayerList = new APlayer({
            element: document.getElementById('player'),
            narrow: false,
            autoplay: true,
            showlrc: false,
            mutex: true,
            theme: '#FFF0',
            mode: 'random',
            preload: 'metadata',
            fixed:true,
            listmaxheight: '200px',
            music:JSON.parse(e)
            });
            window.aplayers || (window.aplayers = []),
            window.aplayers.push(aplayerList)
        }
    })
    //change aplayer style
    var aplayer  = document.getElementById('player');
    aplayer.style.boxShadow = 'none';
    aplayer.style.marginTop = '10px';
    $('.aplayer-list-light').css('background','#d8e2eb69');
})</script></div></body></html>