<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>重拾Android-UI进阶之触摸事件分发机制 | ONE·PIECE</title><meta name="description" content="重拾Android-UI进阶之触摸事件分发机制"><meta name="keywords" content="高级UI,事件分发"><meta name="author" content="Leo·Cheung,leocheung4ever@gmail.com"><meta name="copyright" content="Leo·Cheung"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="DOzi6zRsQ2GdSxTA0T1-9Ul8fB_XbMM43baLPg1CuOo"><meta name="baidu-site-verification" content="S7HPSRHOBw"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="重拾Android-UI进阶之触摸事件分发机制"><meta name="twitter:description" content="重拾Android-UI进阶之触摸事件分发机制"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="重拾Android-UI进阶之触摸事件分发机制"><meta property="og:url" content="http://tufusi.com/2020/08/12/%E9%87%8D%E6%8B%BEAndroid-UI%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="ONE·PIECE"><meta property="og:description" content="重拾Android-UI进阶之触摸事件分发机制"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v4.7.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://tufusi.com/2020/08/12/%E9%87%8D%E6%8B%BEAndroid-UI%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"><link rel="prev" title="重拾Android-UI进阶之View渲染机制" href="http://tufusi.com/2020/08/12/%E9%87%8D%E6%8B%BEAndroid-UI%E8%BF%9B%E9%98%B6%E4%B9%8BView%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"><link rel="next" title="机器学习框架篇-Pytorch" href="http://tufusi.com/2020/08/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E7%AF%87-Pytorch/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RG8HX7QXWX","apiKey":"a183cbbffa921b0dddc2872cfd1abd86","indexName":"WEBSITE001","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://tufusi.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ONE·PIECE</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="http://tufusi.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">209</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">70</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#简介"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#思路分析"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">思路分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#分发对象"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">分发对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#分发事件的组件"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">分发事件的组件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ViewGroup"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">ViewGroup</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#View"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">View</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#分发的核心方法"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">分发的核心方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#事件分发过程"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">事件分发过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#小结"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">小结</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#思路分析"><span class="toc-number">2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分发对象"><span class="toc-number">3.</span> <span class="toc-text">分发对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分发事件的组件"><span class="toc-number">4.</span> <span class="toc-text">分发事件的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewGroup"><span class="toc-number">4.1.</span> <span class="toc-text">ViewGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View"><span class="toc-number">4.2.</span> <span class="toc-text">View</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分发的核心方法"><span class="toc-number">5.</span> <span class="toc-text">分发的核心方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件分发过程"><span class="toc-number">6.</span> <span class="toc-text">事件分发过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">重拾Android-UI进阶之触摸事件分发机制</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-08-12<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-13</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 11 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇主要对事件分发中的基本概念做一下简单介绍，同时也介绍一下参与事件分发的主要方法。从这些方法的核心逻辑中结合源码，总结事件分发的原理。</p>
<blockquote>
<p>注意：不同版本间的代码会有区别，本文是基于Android-28的源码进行分析</p>
</blockquote>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ul>
<li><code>touch</code> 事件是如何从驱动层传递给 <code>Framework</code> 层的 <code>InputManagerService</code>;</li>
<li><code>WMS</code> 是如何通过 <code>ViewRootImpl</code> 将事件传递到目标窗口；</li>
<li><code>touch</code> 事件到达 <code>DecorView</code> 后， 又是如何一步步传递到内部的子View中的。</li>
</ul>
<p>接下来针对上述思路进行知识整理。</p>
<h1 id="分发对象"><a href="#分发对象" class="headerlink" title="分发对象"></a>分发对象</h1><p>首先了解被分发的对象到底是哪些？这些被分发的对象就是用户触摸屏幕而产生的的点击事件，事件主要包括：按下、滑动、抬起、取消。这些事件被封装成<code>MotionEvent</code>对象。该对象的主要事件如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">触发场景</th>
<th style="text-align:center">单次事件流中触发的次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MotionEvent.ACTION_DOWN</td>
<td style="text-align:center">在屏幕按下时</td>
<td style="text-align:center">1次</td>
</tr>
<tr>
<td style="text-align:center">MotionEvent.ACTION_MOVE</td>
<td style="text-align:center">在屏幕滑动时</td>
<td style="text-align:center">0次或多次</td>
</tr>
<tr>
<td style="text-align:center">MotionEvent.ACTION_UP</td>
<td style="text-align:center">在屏幕抬起时</td>
<td style="text-align:center">0次或1次</td>
</tr>
<tr>
<td style="text-align:center">MotionEvent.ACTION_CANCEL</td>
<td style="text-align:center">滑动超出控件边界时</td>
<td style="text-align:center">0次或1次</td>
</tr>
</tbody>
</table>
</div>
<p>按下、滑动、抬起、取消这几种事件组成了一个事件流。事件流以按下为开始，中间可能有若干次滑动，以抬起或者取消作为结束。</p>
<p>在Android对事件分发的处理过程中，主要是对按下事件做分发，进而找到能够处理按下事件的控件。对于事件流中后续的事件（如滑动、抬起等），则直接分发给能够处理按下事件的组件。</p>
<h1 id="分发事件的组件"><a href="#分发事件的组件" class="headerlink" title="分发事件的组件"></a>分发事件的组件</h1><p>分发事件的组件，也称为分发事件者，这些包括<strong>Activity</strong>、<strong>View</strong>、<strong>ViewGroup</strong>，三者的一般结构为：</p>
<p><img alt="分发事件组件关系图.png" data-src="https://i.loli.net/2020/08/12/Cx54cLQd8BtqUPa.png" class="lazyload"></p>
<p>从图上可看出，Activity包括了<code>ViewGroup</code>，<code>ViewGroup</code>又可以包含多个<code>View</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Activity</td>
<td style="text-align:center">Android视图类</td>
<td style="text-align:center">如MainActivity</td>
</tr>
<tr>
<td style="text-align:center">ViewGroup</td>
<td style="text-align:center">View的容器，可以包含若干个View</td>
<td style="text-align:center">各种布局类</td>
</tr>
<tr>
<td style="text-align:center">View</td>
<td style="text-align:center">UI类组件的基类</td>
<td style="text-align:center">如按钮、文本框</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>ViewGroup 是一组View的组合，在其内部有可能包含多个子View，当手指触摸屏幕时，手指所在区域既能在ViewGroup显示范围内，也可能在其内部View控件上。</p>
<p>因此该组件内部的事件分发是处理当前 Group 和子 View 之间的逻辑关系：</p>
<pre><code>1. 当前 Group 是否需要拦截 touch 事件

2. 是否需要将 touch 事件继续分发给子View

3. 如何将 touch 事件 分发给 子View
</code></pre><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>View 是页面上能呈现的最小组件单元，不可再细分，内部也不会存在子 View，所以该组件的事件分发重点在于当前 View 如何去处理 touch 事件，并根据相应的手势逻辑进行一系列的效果展示（比如滑动、放大、点击、长按等）。</p>
<p>所以这里面需要处理一些逻辑关系是：</p>
<pre><code>1. 是否存在 TouchListener;

2. 是否自己接收处理 touch 事件（主要逻辑在 onTouchEvent 方法中）。
</code></pre><h1 id="分发的核心方法"><a href="#分发的核心方法" class="headerlink" title="分发的核心方法"></a>分发的核心方法</h1><p>负责对事件进行分发的方法主要有三个，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dispatchTouchEvent()</span><br><span class="line"></span><br><span class="line">onTouchEvent()</span><br><span class="line"></span><br><span class="line">onInterceptTouchEvent()</span><br></pre></td></tr></table></figure>
<p>它们并不是全都存在于所负责分发的组件中，具体情况分析如下表中：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">组件</th>
<th style="text-align:center">dispatchTouchEvent</th>
<th style="text-align:center">onTouchEvent</th>
<th style="text-align:center">onInterceptTouchEvent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Activity</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">不存在</td>
</tr>
<tr>
<td style="text-align:center">ViewGroup</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
</tr>
<tr>
<td style="text-align:center">View</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">不存在</td>
</tr>
</tbody>
</table>
</div>
<p>从表中可看出，<code>dispatchTouchEvent</code> 和 <code>onTouchEvent</code> 方法存在于上述三个组件中，而 <code>onInterceptTouchEvent</code> 单独为<code>ViewGroup</code>所拥有。</p>
<p><code>ViewGroup</code>类中，实际上是没有 <code>onTouchEvent</code> 方法，但是由于其继承自<code>View</code>，而后者是拥有<code>onTouchEvent</code>方法，因此<code>ViewGroup</code>也是可以调用<code>onTouchEvent</code> 方法的。</p>
<h1 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h1><p>这一章节是本文的核心，具体流程介绍如下。</p>
<p><img alt="Android分发事件U型图.png" data-src="https://i.loli.net/2020/08/13/v4tCiaVHp8PczTo.png" class="lazyload"></p>
<p><strong>分发方法：<code>dispatchTouchEvent</code></strong><br>从方法名可看出该方法的主功能就是负责分发，这是Android事件分发过程中的核心。事件是如何传递的，主要是看该方法，理解此方法，也就吃透了Android事件分发机制。</p>
<p>在了解该方法的核心机制之前，需要知道这样一个结论：</p>
<blockquote>
<p>如果某个组件的该方法返回 <code>TRUE</code>，则表示该组件已对该事件进行了处理，即不会继续调用其他组件的事件分发方法，也就停止了分发。</p>
<p>如果某个组件的该方法返回 <code>FALSE</code>，则表示该组件不能对该事件进行处理，需要按照规则继续分发事件，在不覆写该方法的情况下，除了一些特殊组件（系统已做过处理组件），其余组件默认都是返回<code>false</code>。</p>
</blockquote>
<p>结合源码分析核心逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Activity 的 dispatchTouchEvent 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子 View 消费了该事件,则返回 TRUE，让调用者知道该事件已被消费</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子 View 没有消费该事件，则调用自身的 onTouchEvent 尝试处理。</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Activity</code> 并没有通过自身来判断是否有子View消费分发事件，而是交给它依附的Window对象来处理，但是在Window对象里，该方法是一个抽象方法，实际上它交给了它的具体对象 <code>PhoneWindow</code>处理的；</p>
<p>PhoneWindow核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交给DecorView分发处理</span></span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最终还是调用了ViewGroup里的分发逻辑代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也很好理解，<code>DecorView</code>就是一个<code>ViewGroup</code>，因此，整个流程串通起来即可看出，当事件传递给<code>Activity</code>后，它先将事件分发给子View处理。</p>
<blockquote>
<p>如果经过子View层层传递或者处理后，该事件被消费了（即返回 <code>TRUE</code>），则Activity的分发方法也返回 <code>TRUE</code>，同样也表示该事件已经被消费了。</p>
<p>如果经过子View层层传递或者处理后，该事件没有被消费（即返回 <code>FALSE</code>），则Activity的分发方法就会返回 <code>FALSE</code>，接着调用自身的 <code>onTouchEvent</code> 去处理。</p>
<p>如果 <code>onTouchEvent</code> 消费了该事件，那依然能返回 <code>TRUE</code> （表示已消费该事件），这个 <code>TRUE</code> 作为 <code>dispatchTouchEvent</code> 的返回值，让调用它的对象知道该 <code>Activity</code> 已经消费了事件。</p>
<p>如果 <code>onTouchEvent</code> 没有消费该事件，则会返回 <code>FALSE</code> （表示未消费该事件），这个 <code>FALSE</code> 作为 <code>dispatchTouchEvent</code> 的返回值，让调用它的对象知道该 <code>Activity</code> 并没有消费事件，需要继续处理。</p>
</blockquote>
<p>接下来看ViewGroup 关于 <code>dispatchTouchEvent</code> 方法的核心逻辑代码（去掉非重点代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 步骤1：检查当前的ViewGroup是否需要拦截事件</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">// 如果事件为 DOWN 事件，则调用 onInterceptTouchEvent 进行拦截判断</span></span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// mFirstTouchTarget 不为空，代表已经有子 View 捕获了这个事件，子 View 的dispatchTouchEvent 返回true 就是代表捕获 touch 事件</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否不允许拦截 这个是由子View传递过来的控制标记</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果子View告诉父View：你可以拦截  则交给父View拦截处理</span></span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// 恢复操作，以防更改</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则不允许父View拦截</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有触控目标，此动作不是初始的按下操作</span></span><br><span class="line">            <span class="comment">// 拥有此标记，则这个View Group 可以继续拦截触摸事件。</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 步骤2：将事件分发给子View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">// 表明事件主动分发的前提条件是事件为 DOWN 事件</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                ... ...</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    ... ...</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 遍历所有子 View</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        ... ...</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断事件坐标是否在子 View 坐标范围内，并且子 View 并没有处在动画状态</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ... ...</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将事件分发给子 View，如果子 View 捕获事件成功，则将 mFirstTouchTarget 赋值给子 View</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line"></span><br><span class="line">                            ... ...</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ... ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 步骤3：根据mFirstTouchTarget，再次分发事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果 mFirstTouchTarget 为null，说明在上述的事件分发中并没有子 View 对事件进行捕获操作。</span></span><br><span class="line">        <span class="comment">// 这种条件下，直接调用 dispatchTransformedTouchEvent 方法，并传入 child 为null，最终会调用 super.dispatchTouchEvent 方法</span></span><br><span class="line">        <span class="comment">// 实际上最终是调用自身的 onTouchEvent 方法，进行处理 touch 事件</span></span><br><span class="line">        <span class="comment">// 也就是说：如果没有子 View 捕获处理 touch 事件，ViewGroup 会通过自身的 onTouchEvent 方法进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="comment">// mFirstTouchTarget 不为null，说明步骤2中有子 View 对 touch 事件进行了捕获，</span></span><br><span class="line">                    <span class="comment">// 则直接将当前以及后续的事件交给 mFirstTouchTarget 指向的 View 进行处理。</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    ... ...</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch主要分为3大步骤：</p>
<ul>
<li><p>步骤1：判断当前 ViewGroup 是否需要拦截此 touch 事件，如果拦截则此次 touch 事件不再传递给子 View（<strong>或者以 CANCEL 的方式通知子 View</strong>）。</p>
</li>
<li><p>步骤2：如果没有拦截，则将事件分发给子 View 继续处理，如果子 View 将此次事件捕获，则将 <code>mFirstTouchTarget</code> 赋值给捕获 touch 事件的 View。</p>
</li>
<li><p>步骤3：根据 <code>mFirstTouchTarget</code> 重新分发事件。</p>
</li>
</ul>
<p>如果步骤1中，当前 ViewGroup 并没有对事件进行拦截，则执行步骤2</p>
<p><strong>事件分发流程<a href="https://github.com/LeoCheung0221/CaptureTouchRepo" target="_blank" rel="noopener">demo</a>演示</strong> </p>
<p><img alt="图片.png" data-src="https://i.loli.net/2020/08/13/HAcXMv3JleNgnjm.png" class="lazyload"></p>
<p>上图 DOWN 事件中，<code>DownInterceptGroup</code> 的 <code>onInterceptTouchEvent</code> 被触发一次；</p>
<p>然后在子 View <code>CaptureTouchView</code> 的 <code>dispatchTouchEvent</code> 中返回 true，代表它消费了这个 DOWN 事件。</p>
<p>这样 <code>CaptureTouchView</code> 会被添加到父视图（<code>DownInterceptGroup</code>）中的 <code>mFirstTouchTarget</code> 中。</p>
<p>因此后续的 MOVE 和 UP 事件都会经过 <code>DownInterceptGroup</code> 的 <code>onInterceptTouchEvent</code> 进行拦截判断</p>
<p><strong>为什么 DOWN 事件特殊</strong></p>
<p>所有 touch 事件都是从 DOWN 事件开始的，这是 DOWN 事件比较特殊的原因之一。另一个原因是 DOWN 事件的处理结果会直接影响后续 MOVE、UP 事件的逻辑。</p>
<p>在步骤2中，只有 DOWN 事件会传递给子 View 进行捕获判断，一旦子 View 捕获成功，后续的 MOVE 和 UP 事件是通过遍历 <code>mFirstTouchTarget</code> 链表，查找之前接受 ACTION_DOWN 的子 View，并将触摸事件分配给这些子 View。<font color="#EA3323">也就是说后续的 MOVE、UP 等事件的分发交给谁，取决于他们的起始事件 DOWN 是由谁捕获的</font>。</p>
<p><strong>mFirstTouchTarget的作用</strong></p>
<p><code>mFirstTouchTarget</code> 的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RECYCLED = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sRecycleLock = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TouchTarget sRecycleBin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sRecycledCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALL_POINTER_IDS = -<span class="number">1</span>; <span class="comment">// all ones</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TouchTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 <code>mFirstTouchTarget</code> 是一个 <strong>链表</strong> 结构 <code>TouchTarget</code> 类型的对象。这个对象的作用就是用来记录捕获了 DOWN 事件的 View，具体是保存在它的成员变量 child 变量中。</p>
<p>至于为什么是链表类型结构，是因为Android设备支持多指操作，每一个手指的 DOWN 事件都可以当做一个 <code>TouchTarget</code> 保存起来。在步骤3中判断 <code>mFirstTouchTarget</code> 不为null，则再次将事件分发给响应的 <code>TouchTarget</code>。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要分析 <code>dispatchTouchEvent</code> 的事件流程机制，这一过程主要分3部分：</p>
<ul>
<li><p>判断是否需要拦截 ——&gt; 主要根据 <code>onInterceptTouchEvent</code> 方法的返回值来决定是否拦截；</p>
</li>
<li><p>在 DOWN 事件中将 touch 事件分发给子 View ——&gt; 这一过程如果有子 View 捕获消费了 touch 事件，则会对 <code>mFirstTouchTarget</code> 进行赋值</p>
</li>
<li><p>最后，DOWN、MOVE、UP 事件都会根据 <code>mFirstTouchTarget</code> 是否为null，决定是自己处理 touch 事件，还是再次分发给子 View。</p>
</li>
</ul>
<p>还有整个事件分发中一些特殊的注意点：</p>
<ul>
<li><p>DOWN 事件的特殊：事件的起点；决定后续事件由谁来消费处理；</p>
</li>
<li><p><code>mFirstTouchTarget</code> 作用：记录捕获消费 touch 事件的 View，是一个链表结构；</p>
</li>
<li><p>CANCEL 事件的触发场景：当父视图先不拦截，然后再 MOVE 事件中重新拦截，此时子 View 会接收到一个 CANCEL 事件。</p>
</li>
</ul>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AB%98%E7%BA%A7UI/">高级UI    </a><a class="post-meta__tags" href="/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/">事件分发    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/12/%E9%87%8D%E6%8B%BEAndroid-UI%E8%BF%9B%E9%98%B6%E4%B9%8BView%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>重拾Android-UI进阶之View渲染机制</span></div></a></div><div class="next-post pull_right"><a href="/2020/08/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E7%AF%87-Pytorch/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/cover/tatiana-khomenko-CdYal9M_Uvk-unsplash.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>机器学习框架篇-Pytorch</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/15/重拾Android-UI进阶之摸清WAV关系/" title="重拾Android-UI进阶之摸清WAV关系"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><div class="relatedPosts_title">重拾Android-UI进阶之摸清WAV关系</div></a></div><div class="relatedPosts_item"><a href="/2020/08/12/重拾Android-UI进阶之自定义View/" title="重拾Android-UI进阶之自定义View"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><div class="relatedPosts_title">重拾Android-UI进阶之自定义View</div></a></div><div class="relatedPosts_item"><a href="/2020/08/12/重拾Android-UI进阶之常用View/" title="重拾Android-UI进阶之常用View"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><div class="relatedPosts_title">重拾Android-UI进阶之常用View</div></a></div><div class="relatedPosts_item"><a href="/2020/08/12/重拾Android-UI进阶之View渲染机制/" title="重拾Android-UI进阶之View渲染机制"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg"><div class="relatedPosts_title">重拾Android-UI进阶之View渲染机制</div></a></div><div class="relatedPosts_item"><a href="/2020/07/01/重拾Android-UI进阶之属性动画/" title="重拾Android-UI进阶之属性动画"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/382.jpg"><div class="relatedPosts_title">重拾Android-UI进阶之属性动画</div></a></div><div class="relatedPosts_item"><a href="/2020/07/01/重拾Android-UI进阶之Paint Canvas高级绘制/" title="重拾Android-UI进阶之Paint Canvas高级绘制"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/自然风景/381.jpg"><div class="relatedPosts_title">重拾Android-UI进阶之Paint Canvas高级绘制</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzU5OC8yNDA5OA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta26.com.jpeg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2020 By Leo·Cheung</div><div class="footer_custom_text">Some of life, you have to go to the great challanges. - By Kobe Bryant</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>浙ICP备19024714号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.js"></script><div class="aplayer" id="player"><script>$(function() {
    $.ajax({
        url: "https://api.i-meto.com/meting/api?server=netease&type=playlist&id=416198729",
        success: function(e) {
            var aplayerList = new APlayer({
            element: document.getElementById('player'),
            narrow: false,
            autoplay: true,
            showlrc: false,
            mutex: true,
            theme: '#FFF0',
            mode: 'random',
            preload: 'metadata',
            fixed:true,
            listmaxheight: '200px',
            music:JSON.parse(e)
            });
            window.aplayers || (window.aplayers = []),
            window.aplayers.push(aplayerList)
        }
    })
    //change aplayer style
    var aplayer  = document.getElementById('player');
    aplayer.style.boxShadow = 'none';
    aplayer.style.marginTop = '10px';
    $('.aplayer-list-light').css('background','#d8e2eb69');
})</script></div></body></html>