<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>重拾Android-Java进阶之多线程与Android性能优化 | ONE·PIECE</title><meta name="description" content="重拾Android-Java进阶之多线程与Android性能优化"><meta name="keywords" content="Java进阶"><meta name="author" content="Leo·Cheung,leocheung4ever@gmail.com"><meta name="copyright" content="Leo·Cheung"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="DOzi6zRsQ2GdSxTA0T1-9Ul8fB_XbMM43baLPg1CuOo"><meta name="baidu-site-verification" content="S7HPSRHOBw"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="重拾Android-Java进阶之多线程与Android性能优化"><meta name="twitter:description" content="重拾Android-Java进阶之多线程与Android性能优化"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="重拾Android-Java进阶之多线程与Android性能优化"><meta property="og:url" content="http://tufusi.com/2020/05/25/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="ONE·PIECE"><meta property="og:description" content="重拾Android-Java进阶之多线程与Android性能优化"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v4.7.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://tufusi.com/2020/05/25/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><link rel="prev" title="重拾Android-Java进阶之线程池原理与AsyncTask" href="http://tufusi.com/2020/05/26/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8EAsyncTask/"><link rel="next" title="重拾Android-Java进阶之反射" href="http://tufusi.com/2020/05/24/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8F%8D%E5%B0%84/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RG8HX7QXWX","apiKey":"a183cbbffa921b0dddc2872cfd1abd86","indexName":"WEBSITE001","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://tufusi.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ONE·PIECE</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="http://tufusi.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">209</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">70</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#基础概念"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">基础概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CPU核心数和线程数的关系"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">CPU核心数和线程数的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CPU时间片轮转机制"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">CPU时间片轮转机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程和线程"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">进程和线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#并行和并发"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">并行和并发</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#高并发编程的意义"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">高并发编程的意义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#多线程优势"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">多线程优势</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#多线程开发注意事项"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">多线程开发注意事项</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#认识Java线程"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">认识Java线程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java里的程序天生就是多线程的"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">Java里的程序天生就是多线程的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程的启动与中止"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">线程的启动与中止</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#启动"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">启动</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中止"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">中止</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对Java里的线程再多一点点认识"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">对Java里的线程再多一点点认识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#深入理解run-和-start"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">深入理解run() 和 start()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#其他的线程方法"><span class="toc_mobile_items-number">3.3.2.</span> <span class="toc_mobile_items-text">其他的线程方法</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#进阶Java线程"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">进阶Java线程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程的状态"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">线程的状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#死锁"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">死锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#概念"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁定义"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">死锁定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁的危害"><span class="toc_mobile_items-number">4.2.3.</span> <span class="toc_mobile_items-text">死锁的危害</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#死锁的解决"><span class="toc_mobile_items-number">4.2.4.</span> <span class="toc_mobile_items-text">死锁的解决</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#其他线程安全问题"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">其他线程安全问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#活锁"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">活锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程饥饿"><span class="toc_mobile_items-number">4.3.2.</span> <span class="toc_mobile_items-text">线程饥饿</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ThreadLocal解析"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">ThreadLocal解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#与Synchronized的比较"><span class="toc_mobile_items-number">4.4.1.</span> <span class="toc_mobile_items-text">与Synchronized的比较</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Threadlocal使用"><span class="toc_mobile_items-number">4.4.2.</span> <span class="toc_mobile_items-text">Threadlocal使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实例解析"><span class="toc_mobile_items-number">4.4.3.</span> <span class="toc_mobile_items-text">实例解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CAS基本原理"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">CAS基本原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是原子操作？如何实现原子操作？"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">什么是原子操作？如何实现原子操作？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CAS实现原子操作的三个问题"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">CAS实现原子操作的三个问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#ABA问题"><span class="toc_mobile_items-number">4.5.2.1.</span> <span class="toc_mobile_items-text">ABA问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#循环时间长开销问题"><span class="toc_mobile_items-number">4.5.2.2.</span> <span class="toc_mobile_items-text">循环时间长开销问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#只能保证一个共享变量的原子操作"><span class="toc_mobile_items-number">4.5.2.3.</span> <span class="toc_mobile_items-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JDK中相关原子操作类的使用"><span class="toc_mobile_items-number">4.5.3.</span> <span class="toc_mobile_items-text">JDK中相关原子操作类的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#AtomicInteger"><span class="toc_mobile_items-number">4.5.3.1.</span> <span class="toc_mobile_items-text">AtomicInteger</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#AtomicIntegerArray"><span class="toc_mobile_items-number">4.5.3.2.</span> <span class="toc_mobile_items-text">AtomicIntegerArray</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#更新引用类型"><span class="toc_mobile_items-number">4.5.3.3.</span> <span class="toc_mobile_items-text">更新引用类型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#AtomicReference"><span class="toc_mobile_items-number">4.5.3.3.1.</span> <span class="toc_mobile_items-text">AtomicReference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#AtomicStampedReference"><span class="toc_mobile_items-number">4.5.3.3.2.</span> <span class="toc_mobile_items-text">AtomicStampedReference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#AtomicMarkableReference"><span class="toc_mobile_items-number">4.5.3.3.3.</span> <span class="toc_mobile_items-text">AtomicMarkableReference</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础概念"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU核心数和线程数的关系"><span class="toc-number">1.1.</span> <span class="toc-text">CPU核心数和线程数的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU时间片轮转机制"><span class="toc-number">1.2.</span> <span class="toc-text">CPU时间片轮转机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-number">1.3.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行和并发"><span class="toc-number">1.4.</span> <span class="toc-text">并行和并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高并发编程的意义"><span class="toc-number">2.</span> <span class="toc-text">高并发编程的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程优势"><span class="toc-number">2.1.</span> <span class="toc-text">多线程优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程开发注意事项"><span class="toc-number">2.2.</span> <span class="toc-text">多线程开发注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#认识Java线程"><span class="toc-number">3.</span> <span class="toc-text">认识Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java里的程序天生就是多线程的"><span class="toc-number">3.1.</span> <span class="toc-text">Java里的程序天生就是多线程的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的启动与中止"><span class="toc-number">3.2.</span> <span class="toc-text">线程的启动与中止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动"><span class="toc-number">3.2.1.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中止"><span class="toc-number">3.2.2.</span> <span class="toc-text">中止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对Java里的线程再多一点点认识"><span class="toc-number">3.3.</span> <span class="toc-text">对Java里的线程再多一点点认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#深入理解run-和-start"><span class="toc-number">3.3.1.</span> <span class="toc-text">深入理解run() 和 start()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他的线程方法"><span class="toc-number">3.3.2.</span> <span class="toc-text">其他的线程方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进阶Java线程"><span class="toc-number">4.</span> <span class="toc-text">进阶Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的状态"><span class="toc-number">4.1.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-number">4.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">4.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁定义"><span class="toc-number">4.2.2.</span> <span class="toc-text">死锁定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的危害"><span class="toc-number">4.2.3.</span> <span class="toc-text">死锁的危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的解决"><span class="toc-number">4.2.4.</span> <span class="toc-text">死锁的解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他线程安全问题"><span class="toc-number">4.3.</span> <span class="toc-text">其他线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#活锁"><span class="toc-number">4.3.1.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程饥饿"><span class="toc-number">4.3.2.</span> <span class="toc-text">线程饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal解析"><span class="toc-number">4.4.</span> <span class="toc-text">ThreadLocal解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与Synchronized的比较"><span class="toc-number">4.4.1.</span> <span class="toc-text">与Synchronized的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Threadlocal使用"><span class="toc-number">4.4.2.</span> <span class="toc-text">Threadlocal使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例解析"><span class="toc-number">4.4.3.</span> <span class="toc-text">实例解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS基本原理"><span class="toc-number">4.5.</span> <span class="toc-text">CAS基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是原子操作？如何实现原子操作？"><span class="toc-number">4.5.1.</span> <span class="toc-text">什么是原子操作？如何实现原子操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS实现原子操作的三个问题"><span class="toc-number">4.5.2.</span> <span class="toc-text">CAS实现原子操作的三个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA问题"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环时间长开销问题"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">循环时间长开销问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只能保证一个共享变量的原子操作"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK中相关原子操作类的使用"><span class="toc-number">4.5.3.</span> <span class="toc-text">JDK中相关原子操作类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerArray"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">AtomicIntegerArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新引用类型"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">更新引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicReference"><span class="toc-number">4.5.3.3.1.</span> <span class="toc-text">AtomicReference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">4.5.3.3.2.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicMarkableReference"><span class="toc-number">4.5.3.3.3.</span> <span class="toc-text">AtomicMarkableReference</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">重拾Android-Java进阶之多线程与Android性能优化</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-26</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">8.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 25 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>  <strong><center><font size="5px">第三天  多线程 （MultiThread）</font></center></strong></p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="CPU核心数和线程数的关系"><a href="#CPU核心数和线程数的关系" class="headerlink" title="CPU核心数和线程数的关系"></a>CPU核心数和线程数的关系</h2><p>  <strong>多核心：</strong> 也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理。</p>
<p>  <strong>多线程：</strong> Simultaneous Multithreading. 简称SMT.SMT可通过复制处理器上的结构状态,让同一个处理器上的多个线程同步执行并共享处理器的执行资源可最大限度地实现宽发射、乱序的超标量处理,提高处理器运算部件的利用率,缓和由于数据相关或 Cache未命中带来的访问内存延时。</p>
<p>  <strong>核心数、线程数：</strong> 目前主流CPU有双核、三核和四核，六核也在2010年发布。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系。</p>
<h2 id="CPU时间片轮转机制"><a href="#CPU时间片轮转机制" class="headerlink" title="CPU时间片轮转机制"></a>CPU时间片轮转机制</h2><p>  我们平时在开发的时候，并没有感受到CPU核心数限制带来的影响，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为CPU提供了一种CPU时间片轮转机制。</p>
<p>  时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法，又称 RR 调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p>
<p>百度百科对CPU时间片轮转机制原理解释如下：</p>
<blockquote>
<p>&emsp;&emsp;<br>如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，即被移到队列的末尾。<br>&emsp;&emsp;</p>
</blockquote>
<p>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的，包括保存和装入寄存器值及内存映像，更新各种表格和队列等。假如进程切（process switch），有时称之为上下文切换（context switch），需要5ms，再假设时间片设为20ms，则在做完20ms有用的工作之后，CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。</p>
<p>为了提高CPU效率，我们可以将时间片设为5000ms，这时浪费的时间只有0.1%。但考虑到在一个分时系统中，如果有10个交互用户几乎同时按下回车键，将发生什么情况？假设所有其他进程都用足他们的时间片的话，最后一个不幸的进程不得不等待5s才获得运行机会，多数用户无法忍受一条简短命令要5s才做出响应，同样的问题在一台支持多道程序的个人计算机上也会发生。</p>
<p><strong>结论可以归结如下：</strong> 时间片设的太短会导致过多的进程切换，降低了CPU效率；而设的太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折中。</p>
<p>在CPU死机的情况下，其实不难发现，当运行一个程序的时候，把CPUCPU给弄到了100%在不重启电脑的情况下，其实我们还是还是有机会把它Kill掉。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>进程是程序运行资源分配的最小单位</strong><br>进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是程序在计算机上的一会次执行活动，当你运行一个程序，也就你启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由用户启动的进程。</p>
<p><strong>线程是CPU调度的最小单位，且必须依赖于进程而存在</strong><br>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>线程无处不在</strong><br>任何一个程序都必须要创建线程，特别是Java，不管任何程序都必须启动一个main函数的主线程；Java Web开发里面的定时任务、定时器、JSP和Servlet、异步消息处理机制、远程访问接口 RM 等，任何一个监听事件，onClick的触发事件等都离不开线程和并发的知识。</p>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>举个例子</p>
<p>如果有条高速公路A上面并排有8条车道，那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候，车辆就可以并行运行。CPU也是这个原理，一个CPU相当于一个高速公路A，核心数或者线程数就相当于并排可以通行的车道；而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。</p>
<p>当谈论并发的时候一定要加个单位时间，也就是说单位时间内并发量是多少？离开了单位时间其实是没有意义的。</p>
<p>俗话说，一心不能二用，这对计算机也一样，原则上一个CPU只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个CPU，也就是说只有一颗心，要让它一心多用同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”。</p>
<p><strong>总结如下</strong></p>
<ul>
<li><p>并发： 指应用能够交替执行不同的任务，比如单CPU核心下执行多线程并非是同时执行多个任务，如果开启两个线程执行，其实就是在以我们几乎毫无察觉到的速度不断去切换这两个任务，以达到“同时执行效果”。</p>
</li>
<li><p>并行： 指应用能够同时执行不同的任务，比如，吃饭的时候可以边吃饭边打电话看电视，这几件事都可以同时进行。</p>
</li>
</ul>
<p>两者区别：一个是交替执行，一个是同时执行。</p>
<h1 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h1><p>由于多核多线程的CPU的诞生，多线程、高并发的编程越来越重要，多线程可以给程序性能处理带来质的提升：</p>
<h2 id="多线程优势"><a href="#多线程优势" class="headerlink" title="多线程优势"></a>多线程优势</h2><ul>
<li>充分利用CPU的资源</li>
</ul>
<blockquote>
<p>从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。</p>
</blockquote>
<ul>
<li>加快响应用户的时间</li>
</ul>
<blockquote>
<p>比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。<br>我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。</p>
</blockquote>
<ul>
<li>可以使代码模块化、异步化、简单化</li>
</ul>
<blockquote>
<p>例如我们在做 Android程序开发的时候,主线程的UI展示部分是一块主代码程序部分,但是UI上的按钮用相应事件的处理程序就可以做个单独的模块程序拿出来。这样既增加了异步的操,又使程序模块化,清晰化和简单化。<br>时下最流行的异步程序处理机制,正是多线程、并发程序最好的应用例子。</p>
</blockquote>
<h2 id="多线程开发注意事项"><a href="#多线程开发注意事项" class="headerlink" title="多线程开发注意事项"></a>多线程开发注意事项</h2><ul>
<li>线程之间的安全性</li>
</ul>
<blockquote>
<p>在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p>
</blockquote>
<ul>
<li>线程之间的死循环</li>
</ul>
<blockquote>
<p>为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。<br>假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生.</p>
</blockquote>
<ul>
<li>过多线程导致耗尽服务器资源从而引起死机当机问题 </li>
</ul>
<blockquote>
<p>线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,</p>
</blockquote>
<p>那么我们该如何解决这类问题呢?</p>
<p>某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。</p>
<h1 id="认识Java线程"><a href="#认识Java线程" class="headerlink" title="认识Java线程"></a>认识Java线程</h1><h2 id="Java里的程序天生就是多线程的"><a href="#Java里的程序天生就是多线程的" class="headerlink" title="Java里的程序天生就是多线程的"></a>Java里的程序天生就是多线程的</h2><p>一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上，Java程序天生就是多线程程序，因为执行Main()方法的是一个名称为 main 的线程。</p>
<p>【1】main //main 线程，用户程序入口</p>
<p>【2】Reference Handler  //清除 Reference 线程</p>
<p>【3】Finalizer  //调用对象的 finalizer 方法的线程</p>
<p>【4】Signal Dispatcher  //分发处理发送给 JVM 信号的线程</p>
<p>【5】Attach Listener  //内存dump，线程dump，类信息统计，获取系统属性等</p>
<p>【6】Monitor Ctrl-Break   //监控Ctrl-Break中断信号</p>
<h2 id="线程的启动与中止"><a href="#线程的启动与中止" class="headerlink" title="线程的启动与中止"></a>线程的启动与中止</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动线程的方式有（但其实真正意义上只有前面两种）：<br>1、X extends Thread;，然后X.run<br>2、X implements  Runnable；然后交给Thread运行<br>3、X implements  Callable；然后交给Thread运行</p>
<p>Callable、Future和FutureTask</p>
<p><strong>Runnable</strong>是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p><strong>Callable</strong>位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p>
<p><strong>Future</strong>就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p><img alt="图片1.png" data-src="https://i.loli.net/2020/06/18/9wshSKzRfFTQE1u.png" class="lazyload"></p>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p>
<p><img alt="图片2.png" data-src="https://i.loli.net/2020/06/18/nSZxybOlJhd7kYN.png" class="lazyload"></p>
<p><img alt="图片3.png" data-src="https://i.loli.net/2020/06/18/Ev5emyt8rSLWNVK.png" class="lazyload"></p>
<p>FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。</p>
<p>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>事实上，FutureTask是Future接口的一个唯一实现类。</p>
<p>要new一个FutureTask的实例，有两种方法</p>
<p><img alt="图片4.png" data-src="https://i.loli.net/2020/06/18/VbBwqSTtXYHFAgD.png" class="lazyload"></p>
<h3 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h3><p>线程自然中止，要么是run执行完成，要么是抛出未处理的异常导致线程提前结束。</p>
<p><strong>手动中止</strong><br>暂停、恢复和停止操作对应在线程 Thread 的 API 就是 suspend()、resume() 和 stop()。但是这些API是过期的，也就是不建议使用的。</p>
<p><font color="#A55858">不建议使用的原因</font>有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样非常容易引发死锁。同样，stop()方法在终结一个线程时不会保证线程的资源被释放，通常是没有给予线程完成资源释放的工作机会，因此会导致程序可能工作在不确定的状态下。正因为 suspend()、resume() 和 stop() 方法带来的副作用，所以这些方法才会被标注不建议使用的过期方法。</p>
<p>安全的中止则是其他线程通过调用某个线程A的 <strong>interrupt()</strong> 方法对其进行中断操作，中断好比其他线程对该线程打了个招呼，“A，你要中断了”，但这并不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为Java里的线程是协作式的，不是抢占式的。线程通过检查自身中断标志位是否被置为true来进行响应，线程通过方法 <strong>isInterrupted()</strong> 来进行判断是否被中断，也可以调用静态方法 Thread.interrupted() 来进行判断当前线程是否被中断，不过 Thread.interrupted() 会同时将中断标识位改写成false。</p>
<p>如果一个线程处于<strong>阻塞</strong>状态（线程通过调用 thread.sleep、thread.join、thread.wait …），则在线程在检查自己的中断标识位为true时，则会在这些阻塞方法调用处抛 InterruptedException 异常，并且在抛出异常后会立即将线程的中断标识位清除，即重新设置为false。</p>
<p>同时，<strong><font color="#A55858">不建议自定义一个取消标识位来中止线程的运行</font></strong>，因为 run() 方法里有阻塞调用时，是不会立刻检测到取消标识的，线程必须从阻塞调用返回后，才会检查这个取消标识。这种情况下，使用中断会更好。因为：<br>一、一般的阻塞方法，如 sleep 等本身就支持中断的检查；<br>二、检查中断位的状态和检查取消标识位的状态没什么区别，用中断位的状态还可以避免声明取消标识位，减少资源的消耗。</p>
<p><strong><font color="#EA3323">注意：处于死锁状态的线程无法被中断</font></strong></p>
<h2 id="对Java里的线程再多一点点认识"><a href="#对Java里的线程再多一点点认识" class="headerlink" title="对Java里的线程再多一点点认识"></a>对Java里的线程再多一点点认识</h2><h3 id="深入理解run-和-start"><a href="#深入理解run-和-start" class="headerlink" title="深入理解run() 和 start()"></a>深入理解run() 和 start()</h3><p><strong>Thread</strong>类是Java里面对线程概念的抽象，可以这样理解：我们通过 new Thread() 其实只是 new 出一个 Thread 的实例，还没有和操作系统中真正意义上的线程挂起钩来，只有执行了 start() 方法后，才实现了真正意义上的启动线程。</p>
<p><strong>start()</strong> 方法让一个线程进入就绪队列等待分配CPU，分到CPU后才调用实现的 run() 方法，start() 方法不能重复调用。</p>
<p>而 <strong>run()</strong> 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。</p>
<h3 id="其他的线程方法"><a href="#其他的线程方法" class="headerlink" title="其他的线程方法"></a>其他的线程方法</h3><p><strong>yield()</strong> 方法：使当前线程让出CPU占有权，但让出的时间是不可设定的，也不会释放资源，所有执行 yield() 的线程有可能在进行可执行状态后马上又被执行了。</p>
<p><strong>join()</strong> 方法：把指定的线程加入到当前的线程，可以将两个交替执行的线程合并为顺序执行的线程，比如在线程B中调用了线程A的 join() 方法，则直到线程A执行完毕后，才会继续执行线程B。</p>
<p><strong>wait()</strong> 方法：</p>
<p><strong>notify()</strong> 方法：</p>
<p><strong>notifyAll()</strong> 方法：</p>
<h1 id="进阶Java线程"><a href="#进阶Java线程" class="headerlink" title="进阶Java线程"></a>进阶Java线程</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java中线程的状态分为6种：</p>
<p>1、<strong>初始(NEW)</strong>：新创建一个线程对象，但还没有调用 start() 方法。</p>
<p>2、<strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态统称为“运行”。</p>
<p>线程对象创建后，其他线程（比如main线程）调用了该对象的 start() 方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）</p>
<p>3、<strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁</p>
<p>4、<strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些动作（通知或中断）</p>
<p>5、<strong>超时等待(TIMED_WAITING)</strong>：该状态不同于 WAITING，它可以在指定的事件后自行返回线程队列</p>
<p>6、<strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕</p>
<p>状态之间的变迁借鉴享学老师绘制的流程概念图：</p>
<p><img alt="图片1.png" data-src="https://i.loli.net/2020/06/18/7F6pRqVNgsYoASu.png" class="lazyload"></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成一种阻塞线程，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或者系统产生了死锁。

举个例子：A和B去按摩洗脚，都想在洗脚的时候，同时顺便做个头部按摩，18号技师擅长足底按摩，38号技师擅长头部按摩。
这个时候A先抢到38，B先抢到18，两个人都想同时洗脚和头部按摩，于是就互不相让，扬言说死也不相让，这样的话，A抢到38要18，B抢到18要38，在这种情况下，A和B就产生了死锁，那么怎么解决这个问题呢？

第一种：假如这个时候，来个10号，刚好也是擅长头部按摩的，A有了38，自然就归B所有，这个时候死锁就被打破了，不存在了。
第二种：C出场了，用霸道总裁的手段强迫A和B，必须先洗脚，再头部按摩，这种情况下，A和B谁先抢到18，谁就可以进行下去，另外一个没抢到的，就只等干等着，这种情形下，也不会产生死锁。

总结：死锁是必然发生在多操作者（M&gt;=2）情况下，争夺多个资源（N&gt;=2个，且N&lt;=M）才会发生这种情况。很明显，单线程自然不会有死锁，同时，死锁还有几个要求：1、争夺资源的顺序不对，如果争夺资源的顺序是一样的，也不会产生死锁；2、争夺者拿到资源不肯释放。
</code></pre><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>死锁的发生必须具备以下四个必要条件：</p>
<ul>
<li><strong>互斥条件：</strong> 指进程对所分配到的资源进行排他性使用，即在某一段时间内某资源只由一个进程占用，如果此时还有其他进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放；</li>
<li><strong>请求和保持条件：</strong> 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放；</li>
<li><strong>不剥夺条件：</strong> 指进程已获得资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件：</strong> 指在发生死锁时，必然存在一个进程 - 资源的环形链，即进程集合 {$P_0$, $P_1$, $P_2$, … ,$P_n$}中的 $P_0$ 正在等待一个 $P_1$ 占用的资源； $P_1$ 正在等待 $P_2$ 占用的资源；…</li>
</ul>
<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能的避免、预防和解除死锁。<br>因此，只需打破这个四个必要条件之一，就可以有效预防死锁的发生：</p>
<ul>
<li><strong>打破互斥条件：</strong> 改造独占性资源为虚拟资源，大部分资源已无法改造；</li>
<li><strong>打破不可抢占条件：</strong> 当一进程占有一独占性资源后又申请一独占性资源而无法满足，则推出原占有的资源；</li>
<li><strong>打破占有且申请条件：</strong> 采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请；</li>
<li><strong>打破循环等待条件：</strong> 实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
</ul>
<p>避免死锁的常见算法有：<strong>有序资源分配法</strong>、<strong>银行家算法</strong></p>
<h3 id="死锁的危害"><a href="#死锁的危害" class="headerlink" title="死锁的危害"></a>死锁的危害</h3><p>1、线程不工作了，但是整个程序还是活着的<br>2、没有任何的异常信息可供检查<br>3、一旦程序发生了死锁，是没有任何办法恢复的，除非重启应用程序，对正式发布的程序来说，这很致命。</p>
<h3 id="死锁的解决"><a href="#死锁的解决" class="headerlink" title="死锁的解决"></a>死锁的解决</h3><p>关键是保证拿锁的顺序一致</p>
<p>两种解决方式：<br>1、内部通过顺序比较，确定拿锁的顺序；<br>2、采用尝试拿锁的机制。</p>
<h2 id="其他线程安全问题"><a href="#其他线程安全问题" class="headerlink" title="其他线程安全问题"></a>其他线程安全问题</h2><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。</p>
<p>解决办法：每个线程休眠随机数，错开拿锁的时间。</p>
<h3 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h3><p>低优先级的线程，总是拿不到执行时间。</p>
<h2 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h2><h3 id="与Synchronized的比较"><a href="#与Synchronized的比较" class="headerlink" title="与Synchronized的比较"></a>与Synchronized的比较</h3><blockquote>
<p>ThreadLocal 和 Synchronized 都用于解决多线程并发访问。可是 ThreadLocal 与 Synchronized 有本质的差别。<br>Synchronized 是利用锁的机制，使变量或代码块在某一时刻仅仅能被一个线程访问。<br>而 ThreadLocal 为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并非同一个对象，这样就更隔离了多个线程对数据的数据共享。</p>
</blockquote>
<h3 id="Threadlocal使用"><a href="#Threadlocal使用" class="headerlink" title="Threadlocal使用"></a>Threadlocal使用</h3><p>ThreadLocal类接口提供4个方法，分别是：</p>
<ul>
<li><p><strong>void set(Object value)</strong><br>设置当前线程的线程局部变量值</p>
</li>
<li><p><strong>public Object get()</strong><br>该方法返回当前线程所对应的线程局部变量</p>
</li>
<li><p><strong>public void remove()</strong><br>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法，需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显示调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存的回收速度。</p>
</li>
<li><p><strong>protected Object initialValue()</strong><br>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用的方法，在线程第一次调用get()或set(Object)时才执行，并且仅执行一次，ThreadLocal中的缺省实现直接返回一个null。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; RESOURCE = <span class="keyword">new</span> ThreadLocal&lt;String&gt;;</span><br><span class="line"><span class="comment">//RESOURCE 代表一个能够存放String类型的 ThreadLocal对象，此时不论什么的一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</span></span><br></pre></td></tr></table></figure>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p><img alt="图片7.png" data-src="https://i.loli.net/2020/06/19/xFHjQ2itGWdhVRO.png" class="lazyload"></p>
<p><img alt="图片8.png" data-src="https://i.loli.net/2020/06/19/sBivDQqd9EYl8Wz.png" class="lazyload"></p>
<p><img alt="图片9.png" data-src="https://i.loli.net/2020/06/19/kafWln4vpFXqeAY.png" class="lazyload"></p>
<p><img alt="图片10.png" data-src="https://i.loli.net/2020/06/19/TOm56uDtGJYFyg7.png" class="lazyload"></p>
<p><img alt="图片11.png" data-src="https://i.loli.net/2020/06/19/dJWYFZHNCjcsMt2.png" class="lazyload"></p>
<p>上面先取到当前线程，然后调用 getMap() 方法对应的 ThreadLocalMap，ThreadLocalMap 是 ThreadLocal 的静态内部类，然后 Thread 类中有一个这样的类型成员，所以 getMap 是直接返回 Thread 的成员。</p>
<p>看一下 ThreadLocal 的内部类 ThreadLocalMap 源码：</p>
<p><img alt="图片12.png" data-src="https://i.loli.net/2020/06/19/euGUTX7w4OySsJK.png" class="lazyload"></p>
<p>可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry()则是获取某个ThreadLocal对应的值，set方法就是更新或者赋值相应的ThreadLocal对应的值。</p>
<p><img alt="图片13.png" data-src="https://i.loli.net/2020/06/19/dzX76A4bFuxTsnh.png" class="lazyload"></p>
<p><img alt="图片1.png" data-src="https://i.loli.net/2020/06/27/V1DvO7PsFep5NMU.png" class="lazyload"></p>
<p>回顾我们的get方法，其实就是拿到<font color="#ea3323">每个线程独有的 ThreadLocalMap</font><br>然后再用 ThreadLocal 的当前实例，拿到Map 中的相应的 Entry，然后就可以拿到相应的值返回回来。当然，如果Map为空，还会先进行map的创建，初始化等工作。</p>
<h2 id="CAS基本原理"><a href="#CAS基本原理" class="headerlink" title="CAS基本原理"></a>CAS基本原理</h2><h3 id="什么是原子操作？如何实现原子操作？"><a href="#什么是原子操作？如何实现原子操作？" class="headerlink" title="什么是原子操作？如何实现原子操作？"></a>什么是原子操作？如何实现原子操作？</h3><p>假定有两个操作 A 和 B（A和B可能都很复杂），如果从执行A的线程来看，当另一个线程执行B时，要么B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p>
<p>实现原子操作可以使用锁，锁机制，满足基本的需求是没问题的，但是有时我们需求并非那么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其他线程需要等待，直到该线程释放锁。</p>
<p>这里会有问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一致不释放锁怎么办？（这种情况是很糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那么CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况。最后，其实锁机制是一种比较粗糙、粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p>
<p>实现原子操作还可以使用当前的处理器都支持的CAS（Compare and Swap）的指令，只不过每个厂家实现的算法不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A，和一个新值BB，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事，但是要返回原值多少。循环CAS就是在一个循环里，不断的做cas操作，直到成功为止。</p>
<p><img alt="图片2.png" data-src="https://i.loli.net/2020/06/27/bWf8lNnZyUXFdHx.png" class="lazyload"></p>
<h3 id="CAS实现原子操作的三个问题"><a href="#CAS实现原子操作的三个问题" class="headerlink" title="CAS实现原子操作的三个问题"></a>CAS实现原子操作的三个问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上是变化了。</p>
<p>ABA问题的解决思路就是使用版本号，在变量前面追加版本号，每次变量更新的时候把版本号加上1，那么A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A.</p>
<p>举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。</p>
<p>如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。</p>
<h4 id="循环时间长开销问题"><a href="#循环时间长开销问题" class="headerlink" title="循环时间长开销问题"></a>循环时间长开销问题</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以考虑使用<strong>锁</strong>。</p>
<p>当然还有一个取巧的方法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作ij，从Java 1.5开始，JDK提供了 AtomicReferecnce类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<h3 id="JDK中相关原子操作类的使用"><a href="#JDK中相关原子操作类的使用" class="headerlink" title="JDK中相关原子操作类的使用"></a>JDK中相关原子操作类的使用</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><ul>
<li><p><strong>int addAndGet(int delta)</strong>：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</p>
</li>
<li><p><strong>boolean compareAndSet（int expect，int update）</strong>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p>
</li>
<li><p><strong>int getAndIncrement()</strong>：以原子方式将当前值加1，注意，这里返回的是自增前的值。</p>
</li>
<li><p><strong>int getAndSet（int newValue）</strong>：以原子方式设置为newValue的值，并返回旧值。</p>
</li>
</ul>
<h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>主要是提供原子的方式更新数组里的整型。其常用方法如下：</p>
<ul>
<li><p><strong>int addAndGet（int i，int delta）</strong>：以原子方式将输入值与数组中索引i的元素相加。</p>
</li>
<li><p><strong>boolean compareAndSet（int i，int expect，int update）</strong>：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</p>
</li>
</ul>
<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h4 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h4><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果需要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p>
<h5 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h5><p>原子更新引用类型</p>
<h5 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h5><p>利用版本戳的形式记录了每次改变后的版本，这样的话就不会存在ABA问题了。</p>
<p>这就是AtomicStampedReference的解决方案：AtomicMarkableReference 跟 AtomicStampedReference 差不多，AtomicStampedReference 是使用pair的int stamp作为计数器使用，AtomicMarkableReference 的pair 使用的是boolean mark。</p>
<p>还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。</p>
<h5 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h5><p>原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%BF%9B%E9%98%B6/">Java进阶    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/26/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8EAsyncTask/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>重拾Android-Java进阶之线程池原理与AsyncTask</span></div></a></div><div class="next-post pull_right"><a href="/2020/05/24/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8F%8D%E5%B0%84/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta.com.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>重拾Android-Java进阶之反射</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/01/重拾Android-Java进阶之RxJava编程原理/" title="重拾Android-Java进阶之RxJava编程原理"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/图片20.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之RxJava编程原理</div></a></div><div class="relatedPosts_item"><a href="/2020/05/31/重拾Android-Java进阶之深入理解IO/" title="重拾Android-Java进阶之深入理解IO"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/benjamin-elliott-LYdXESrw4dY-unsplash.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解IO</div></a></div><div class="relatedPosts_item"><a href="/2020/05/30/重拾Android-Java进阶之序列化/" title="重拾Android-Java进阶之序列化"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/cover/sean-lim-NPlv2pkYoUA-unsplash.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之序列化</div></a></div><div class="relatedPosts_item"><a href="/2020/05/29/重拾Android-Java进阶之深入理解ClassLoader类加载/" title="重拾Android-Java进阶之深入理解ClassLoader类加载"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta2.com.jpeg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解ClassLoader类加载</div></a></div><div class="relatedPosts_item"><a href="/2020/05/28/重拾Android-Java进阶之深入理解JVM/" title="重拾Android-Java进阶之深入理解JVM"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/photo-1589371709918-9dfa8c55338e.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解JVM</div></a></div><div class="relatedPosts_item"><a href="/2020/05/27/重拾Android-Java进阶之深入理解GC机制/" title="重拾Android-Java进阶之深入理解GC机制"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta3.com.jpeg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解GC机制</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzU5OC8yNDA5OA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2020 By Leo·Cheung</div><div class="footer_custom_text">Some of life, you have to go to the great challanges. - By Kobe Bryant</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>浙ICP备19024714号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.js"></script><div class="aplayer" id="player"><script>$(function() {
    $.ajax({
        url: "https://api.i-meto.com/meting/api?server=netease&type=playlist&id=416198729",
        success: function(e) {
            var aplayerList = new APlayer({
            element: document.getElementById('player'),
            narrow: false,
            autoplay: true,
            showlrc: false,
            mutex: true,
            theme: '#FFF0',
            mode: 'random',
            preload: 'metadata',
            fixed:true,
            listmaxheight: '200px',
            music:JSON.parse(e)
            });
            window.aplayers || (window.aplayers = []),
            window.aplayers.push(aplayerList)
        }
    })
    //change aplayer style
    var aplayer  = document.getElementById('player');
    aplayer.style.boxShadow = 'none';
    aplayer.style.marginTop = '10px';
    $('.aplayer-list-light').css('background','#d8e2eb69');
})</script></div></body></html>