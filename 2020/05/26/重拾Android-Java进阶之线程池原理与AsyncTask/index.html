<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>重拾Android-Java进阶之线程池原理与AsyncTask | ONE·PIECE</title><meta name="description" content="重拾Android-Java进阶之线程池原理与AsyncTask"><meta name="keywords" content="Java进阶"><meta name="author" content="Leo·Cheung,leocheung4ever@gmail.com"><meta name="copyright" content="Leo·Cheung"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="google-site-verification" content="DOzi6zRsQ2GdSxTA0T1-9Ul8fB_XbMM43baLPg1CuOo"><meta name="baidu-site-verification" content="S7HPSRHOBw"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="重拾Android-Java进阶之线程池原理与AsyncTask"><meta name="twitter:description" content="重拾Android-Java进阶之线程池原理与AsyncTask"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg"><meta property="og:type" content="article"><meta property="og:title" content="重拾Android-Java进阶之线程池原理与AsyncTask"><meta property="og:url" content="http://tufusi.com/2020/05/26/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8EAsyncTask/"><meta property="og:site_name" content="ONE·PIECE"><meta property="og:description" content="重拾Android-Java进阶之线程池原理与AsyncTask"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v4.7.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://tufusi.com/2020/05/26/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8EAsyncTask/"><link rel="prev" title="重拾Android-Java进阶之深入理解GC机制" href="http://tufusi.com/2020/05/27/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GC%E6%9C%BA%E5%88%B6/"><link rel="next" title="重拾Android-Java进阶之多线程与Android性能优化" href="http://tufusi.com/2020/05/25/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"RG8HX7QXWX","apiKey":"a183cbbffa921b0dddc2872cfd1abd86","indexName":"WEBSITE001","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://tufusi.com/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: 'true',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">ONE·PIECE</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="http://tufusi.com/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">209</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">70</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/android/"><i class="fa-fw fa fa-android"></i><span> 重拾Android</span></a></div><div class="menus_item"><a class="site-page" href="/leetcode/"><i class="fa-fw fa fa-diamond"></i><span> LeetCode</span></a></div><div class="menus_item"><a class="site-page" href="/news/"><i class="fa-fw fa fa-newspaper-o"></i><span> AI头条</span></a></div><div class="menus_item"><a class="site-page" href="/papers/"><i class="fa-fw fa fa-paper-plane-o"></i><span> 论文推荐</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-battery-half" aria-hidden="true"></i><span> 充电驿站</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/e-books/"><i class="fa-fw fa fa-book"></i><span> 小书屋</span></a></li><li><a class="site-page" href="/e-movies/"><i class="fa-fw fa fa-film"></i><span> 大影单</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#阻塞队列和线程池原理"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">阻塞队列和线程池原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#阻塞队列"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">阻塞队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#队列"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是阻塞队列？"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">什么是阻塞队列？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#常用阻塞队列"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">常用阻塞队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#有界无界"><span class="toc_mobile_items-number">1.1.3.1.</span> <span class="toc_mobile_items-text">有界无界</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#ArrayBlockingQueue"><span class="toc_mobile_items-number">1.1.3.2.</span> <span class="toc_mobile_items-text">ArrayBlockingQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#LinkedBlockingQueue"><span class="toc_mobile_items-number">1.1.3.3.</span> <span class="toc_mobile_items-text">LinkedBlockingQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Array实现和Linked实现的区别"><span class="toc_mobile_items-number">1.1.3.4.</span> <span class="toc_mobile_items-text">Array实现和Linked实现的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#PriorityBlockingQueue"><span class="toc_mobile_items-number">1.1.3.5.</span> <span class="toc_mobile_items-text">PriorityBlockingQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#DelayQueue"><span class="toc_mobile_items-number">1.1.3.6.</span> <span class="toc_mobile_items-text">DelayQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#SynchronousQueue"><span class="toc_mobile_items-number">1.1.3.7.</span> <span class="toc_mobile_items-text">SynchronousQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#LinkedTransferQueue"><span class="toc_mobile_items-number">1.1.3.8.</span> <span class="toc_mobile_items-text">LinkedTransferQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#LinkedBlockingDeque"><span class="toc_mobile_items-number">1.1.3.9.</span> <span class="toc_mobile_items-text">LinkedBlockingDeque</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程池"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">线程池</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么要用线程池"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">为什么要用线程池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ThreadPoolExecutor-的类关系"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">ThreadPoolExecutor 的类关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程池的创建"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">线程池的创建</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#corePoolSize"><span class="toc_mobile_items-number">1.2.3.1.</span> <span class="toc_mobile_items-text">corePoolSize</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#maximumPoolSize"><span class="toc_mobile_items-number">1.2.3.2.</span> <span class="toc_mobile_items-text">maximumPoolSize</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#keepAliveTime"><span class="toc_mobile_items-number">1.2.3.3.</span> <span class="toc_mobile_items-text">keepAliveTime</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#TimeUnit"><span class="toc_mobile_items-number">1.2.3.4.</span> <span class="toc_mobile_items-text">TimeUnit</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#workQueue"><span class="toc_mobile_items-number">1.2.3.5.</span> <span class="toc_mobile_items-text">workQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#threadFactory"><span class="toc_mobile_items-number">1.2.3.6.</span> <span class="toc_mobile_items-text">threadFactory</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#RejectedExecutionHandler"><span class="toc_mobile_items-number">1.2.3.7.</span> <span class="toc_mobile_items-text">RejectedExecutionHandler</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程池的工作机制"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">线程池的工作机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#提交任务"><span class="toc_mobile_items-number">1.2.5.</span> <span class="toc_mobile_items-text">提交任务</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#关闭线程池"><span class="toc_mobile_items-number">1.2.6.</span> <span class="toc_mobile_items-text">关闭线程池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#合理化线程池配置"><span class="toc_mobile_items-number">1.2.7.</span> <span class="toc_mobile_items-text">合理化线程池配置</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AbstractQueuedSynchronizer"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">AbstractQueuedSynchronizer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#学习AQS的必要性"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">学习AQS的必要性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AQS使用方式和其中的设计模式"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">AQS使用方式和其中的设计模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#模板方法模式"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">模板方法模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AQS中的方法"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">AQS中的方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#模板方法"><span class="toc_mobile_items-number">1.3.3.1.</span> <span class="toc_mobile_items-text">模板方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#可重写的方法"><span class="toc_mobile_items-number">1.3.3.2.</span> <span class="toc_mobile_items-text">可重写的方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#访问或修改同步状态的方法"><span class="toc_mobile_items-number">1.3.3.3.</span> <span class="toc_mobile_items-text">访问或修改同步状态的方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CLH队列锁"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">CLH队列锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ReentrantLock-的实现"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">ReentrantLock 的实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#锁的可重入"><span class="toc_mobile_items-number">1.3.5.1.</span> <span class="toc_mobile_items-text">锁的可重入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#公平和非公平锁"><span class="toc_mobile_items-number">1.3.5.2.</span> <span class="toc_mobile_items-text">公平和非公平锁</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#深入理解并发编程"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">深入理解并发编程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JMM基础-计算机原理"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">JMM基础-计算机原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java内存模型（JMM）"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Java内存模型（JMM）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可见性"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">可见性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原子性"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">原子性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#volatile详解"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">volatile详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile特性"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text">volatile特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#volatile的实现原理"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text">volatile的实现原理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#synchronized-的实现原理"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">synchronized 的实现原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#了解各种锁"><span class="toc_mobile_items-number">2.4.1.</span> <span class="toc_mobile_items-text">了解各种锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#自旋锁"><span class="toc_mobile_items-number">2.4.1.1.</span> <span class="toc_mobile_items-text">自旋锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#原理"><span class="toc_mobile_items-number">2.4.1.1.1.</span> <span class="toc_mobile_items-text">原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#自旋锁的优缺点"><span class="toc_mobile_items-number">2.4.1.1.2.</span> <span class="toc_mobile_items-text">自旋锁的优缺点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#自旋锁的时间阈值"><span class="toc_mobile_items-number">2.4.1.1.3.</span> <span class="toc_mobile_items-text">自旋锁的时间阈值</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁的状态"><span class="toc_mobile_items-number">2.4.2.</span> <span class="toc_mobile_items-text">锁的状态</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#偏向锁"><span class="toc_mobile_items-number">2.4.2.1.</span> <span class="toc_mobile_items-text">偏向锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#轻量级锁"><span class="toc_mobile_items-number">2.4.2.2.</span> <span class="toc_mobile_items-text">轻量级锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#不同锁的比较"><span class="toc_mobile_items-number">2.4.2.3.</span> <span class="toc_mobile_items-text">不同锁的比较</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#阻塞队列和线程池原理"><span class="toc-number">1.</span> <span class="toc-text">阻塞队列和线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列"><span class="toc-number">1.1.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">1.1.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是阻塞队列？"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是阻塞队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用阻塞队列"><span class="toc-number">1.1.3.</span> <span class="toc-text">常用阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#有界无界"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">有界无界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array实现和Linked实现的区别"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">Array实现和Linked实现的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayQueue"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">SynchronousQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedTransferQueue"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">LinkedTransferQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingDeque"><span class="toc-number">1.1.3.9.</span> <span class="toc-text">LinkedBlockingDeque</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-number">1.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用线程池"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么要用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor-的类关系"><span class="toc-number">1.2.2.</span> <span class="toc-text">ThreadPoolExecutor 的类关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的创建"><span class="toc-number">1.2.3.</span> <span class="toc-text">线程池的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#corePoolSize"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">corePoolSize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#maximumPoolSize"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">maximumPoolSize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keepAliveTime"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">keepAliveTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TimeUnit"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">TimeUnit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#workQueue"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">workQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threadFactory"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">threadFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RejectedExecutionHandler"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">RejectedExecutionHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的工作机制"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程池的工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提交任务"><span class="toc-number">1.2.5.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭线程池"><span class="toc-number">1.2.6.</span> <span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合理化线程池配置"><span class="toc-number">1.2.7.</span> <span class="toc-text">合理化线程池配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractQueuedSynchronizer"><span class="toc-number">1.3.</span> <span class="toc-text">AbstractQueuedSynchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#学习AQS的必要性"><span class="toc-number">1.3.1.</span> <span class="toc-text">学习AQS的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS使用方式和其中的设计模式"><span class="toc-number">1.3.2.</span> <span class="toc-text">AQS使用方式和其中的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模板方法模式"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">模板方法模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS中的方法"><span class="toc-number">1.3.3.</span> <span class="toc-text">AQS中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模板方法"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重写的方法"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">可重写的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问或修改同步状态的方法"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">访问或修改同步状态的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLH队列锁"><span class="toc-number">1.3.4.</span> <span class="toc-text">CLH队列锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-的实现"><span class="toc-number">1.3.5.</span> <span class="toc-text">ReentrantLock 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#锁的可重入"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">锁的可重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平和非公平锁"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">公平和非公平锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深入理解并发编程"><span class="toc-number">2.</span> <span class="toc-text">深入理解并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM基础-计算机原理"><span class="toc-number">2.1.</span> <span class="toc-text">JMM基础-计算机原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型（JMM）"><span class="toc-number">2.2.</span> <span class="toc-text">Java内存模型（JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性"><span class="toc-number">2.2.1.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">2.2.2.</span> <span class="toc-text">原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile详解"><span class="toc-number">2.3.</span> <span class="toc-text">volatile详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile特性"><span class="toc-number">2.3.1.</span> <span class="toc-text">volatile特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的实现原理"><span class="toc-number">2.3.2.</span> <span class="toc-text">volatile的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-的实现原理"><span class="toc-number">2.4.</span> <span class="toc-text">synchronized 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#了解各种锁"><span class="toc-number">2.4.1.</span> <span class="toc-text">了解各种锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#原理"><span class="toc-number">2.4.1.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自旋锁的优缺点"><span class="toc-number">2.4.1.1.2.</span> <span class="toc-text">自旋锁的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自旋锁的时间阈值"><span class="toc-number">2.4.1.1.3.</span> <span class="toc-text">自旋锁的时间阈值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的状态"><span class="toc-number">2.4.2.</span> <span class="toc-text">锁的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#偏向锁"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轻量级锁"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不同锁的比较"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">不同锁的比较</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">重拾Android-Java进阶之线程池原理与AsyncTask</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-26</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">11.5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 35 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong><center><font size="5px">第四天  深挖线程池原理 </font></center></strong></p>
<h1 id="阻塞队列和线程池原理"><a href="#阻塞队列和线程池原理" class="headerlink" title="阻塞队列和线程池原理"></a>阻塞队列和线程池原理</h1><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><img alt="图片3.png" data-src="https://i.loli.net/2020/06/27/vKtqfh9U81WBzSD.png" class="lazyload"></p>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—First In First Out）线性表。</p>
<h3 id="什么是阻塞队列？"><a href="#什么是阻塞队列？" class="headerlink" title="什么是阻塞队列？"></a>什么是阻塞队列？</h3><p>1） 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>2） 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
<p>在并发编程中使用<strong>生产者和消费者模式</strong>能够解决绝大部分并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</p>
<p>为了解决这种生产消费能力的不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信。所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<p><img alt="图片4.png" data-src="https://i.loli.net/2020/06/27/vyoiY8RmshH3fpC.png" class="lazyload"></p>
<h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><ul>
<li><p><strong>ArrayBlockingQueue</strong>：一个由数组结构组成的有界阻塞队列</p>
</li>
<li><p><strong>LinkedBlockingQueue</strong>：一个由链表结构组成的有界阻塞队列</p>
</li>
<li><p><strong>PriorityBlockingQueue</strong>：一个支持优先级排序的无界阻塞队列</p>
</li>
<li><p><strong>DelayQueue</strong>：一个使用优先级队列实现的无界阻塞队列</p>
</li>
<li><p><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列</p>
</li>
<li><p><strong>LinkedTransferQueue</strong>：一个由链表结构组成的无界阻塞队列</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong>：一个由链表结构组成的双向阻塞队列</p>
</li>
</ul>
<p>以上的阻塞队列均实现了<strong>BlockingQueue</strong>接口，也都是线程安全的。</p>
<h4 id="有界无界"><a href="#有界无界" class="headerlink" title="有界无界"></a>有界无界</h4><p>有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。</p>
<p>无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>
<h4 id="Array实现和Linked实现的区别"><a href="#Array实现和Linked实现的区别" class="headerlink" title="Array实现和Linked实现的区别"></a>Array实现和Linked实现的区别</h4><ol>
<li><p><strong>队列中锁的实现不同</strong><br>ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；<br>LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock。</p>
</li>
<li><p><strong>在生产或消费时操作不同</strong><br>ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；<br>LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<e>进行插入或移除，会影响性能。</e></p>
</li>
<li><p><strong>队列大小初始化方式不同</strong><br>ArrayBlockingQueue实现的队列中必须指定队列的大小；<br>LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE。</p>
</li>
</ol>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
<p>DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</p>
<p><font color="#ea3323">缓存系统的设计</font>：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。</p>
<h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>多了tryTransfer和transfer方法：</p>
<p>l’如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p>
<p>（2）tryTransfer方法<br>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
<p>多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理的使用线程池能够带来3个好处：</p>
<p>1）<strong>降低资源消耗</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>2）<strong>提高响应速度</strong> 当任务到达时，任务可以不需要等到线程创建就立即执行。</p>
<p>假设一个服务器完成一项任务所需时间为：T1创建线程时间，T2在线程中执行任务的时间，T3销毁线程时间。</p>
<p>如果T1+T3远大于T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1、T3时间的技术，从而提高服务器程序性能的。它把T1 和 T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1 和 T3的开销了。</p>
<p>3）<strong>提高线程的可管理性</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h3 id="ThreadPoolExecutor-的类关系"><a href="#ThreadPoolExecutor-的类关系" class="headerlink" title="ThreadPoolExecutor 的类关系"></a>ThreadPoolExecutor 的类关系</h3><p><strong>Executor</strong>是一个接口，它是Executor框架的基础，它将任务的提交和任务的执行分离开来。</p>
<p><strong>ExecutorService</strong>接口继承了<strong>Executor</strong>，在此之上做了一些shutdown() 和 submit()的扩展，可以说是真正的线程池接口。</p>
<p><strong>AbstractExecutorService</strong>抽象类实现了<strong>ExecutorService</strong>接口中的大部分方法。</p>
<p><strong>ThreadPoolExecutor</strong>是线程池的核心实现类，用来执行被提交的任务。</p>
<p><strong>ScheduledExecutorService</strong>接口继承了<strong>ExecutorService</strong>接口，提供了带“周期执行”功能的ExecutorService。</p>
<p><strong>ScheduledThreadPoolExecutor</strong>是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。</p>
<h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, </span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit  unit, BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize。</p>
<p>如果当前线程数改为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行。</p>
<p>如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且仍在继续提交任务，则创建新的线程执行任务，前提是当前线程数少于maximumPoolSize。</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用。</p>
<h4 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h4><p>keepAliveTime的时间单位。</p>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>workQueue必须是BlockingQueue类型的阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列，进行阻塞等待。通过workQueue，线程池实现了阻塞功能。</p>
<p>1）当线程池中的线程数达到了corePoolSize后，新任务将在无界队列中等待，因此线程中的线程数不会超过corePoolSize。</p>
<p>2）由于1的原因，使用无界队列时maximumPoolSize将是一个无效的参数。</p>
<p>3）由于1和2，使用无界队列时，keepAliveTime将是一个无效的参数。</p>
<p>4）更重要的是，使用无界队列可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</p>
<h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。</p>
<p>Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p>
<h4 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<p>（1）<strong>AbortPolicy</strong>：直接抛出异常，默认策略</p>
<p>（2）<strong>CallerRunsPolicy</strong>：用调用者所在线程执行该任务</p>
<p>（3）<strong>DiscardOldestPolicy</strong>：丢弃阻塞队列中最靠前的任务，并执行当前任务</p>
<p>（4）<strong>DiscardPolicy</strong>：直接丢弃任务</p>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h3 id="线程池的工作机制"><a href="#线程池的工作机制" class="headerlink" title="线程池的工作机制"></a>线程池的工作机制</h3><p>（1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务（<font color="#ea3323">注意，执行这一步骤需要获取全剧锁</font>）</p>
<p>（2）如果运行的线程等于或多于corePoolSize，则将任务加入到BlockingQueue。</p>
<p>（3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</p>
<p>（4）如果创建新线程将使当前的运行线程数超过maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejetedExecution()方法。</p>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>executor()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p>
<p>submit()用于提交需要返回值的任务，线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候又可能任务没有执行完。</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown()或shutdownNow()方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 <strong>interrupt()</strong> 方法来中断线程，所以无法响应中断任务的线程可能永远无法停止，但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成 <strong>STOP</strong>，然后尝试<strong>停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</strong>；而shutdown只是将线程池的状态设置为 <strong>SHUTDOWN</strong> 状态，然后<strong>中断所有没有正在执行任务</strong>的线程。</p>
<p>只要调用了这两个关闭方法中的任意一个，<strong>isShutDown()</strong> 方法就会返回 <strong>true</strong>，当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 <strong>isTerminaled()</strong> 方法则会返回 <strong>true</strong>。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池任务特性来决定的，通常调用 shutdown 方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow() 方法。</p>
<h3 id="合理化线程池配置"><a href="#合理化线程池配置" class="headerlink" title="合理化线程池配置"></a>合理化线程池配置</h3><p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度老看：</p>
<ul>
<li><p><strong>任务的性质</strong>：CPU密集型任务、IO密集型任务和混合型任务</p>
</li>
<li><p><strong>任务的优先级</strong>：高、中和低</p>
</li>
<li><p><strong>任务的执行时间</strong>：长、中和短</p>
</li>
<li><p><strong>任务的依赖性</strong>：是否依赖其他的系统资源，如数据库连接</p>
</li>
</ul>
<p>性质不同的任务可以使用不同规模的线程池分开处理</p>
<p><strong>CPU密集型任务</strong>：应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</p>
<p><strong>IO密集型任务</strong>：因为该任务并不一定是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu</p>
<p><strong>混合型的任务</strong>：如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量，如果这两个任务执行时间相差过大，则没必要进行分解。<font color="#a34e22">可以通过Runtime.getRuntime().availableProcessors()方法获得当前CPU个数</font>。</p>
<p><strong>优先级不同的任务</strong>：可以使用优先级队列 PriorityBlockingQueue来处理，它可以让优先级高的任务先执行。</p>
<p><strong>执行时间不同的任务</strong>：可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
<p><strong>建议</strong>：建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设置大一点，比如几千；如果我们设置成无界队列，那么线程池的队列会越来越多，有可能会撑爆内存，导致整个系统不可用，这是致命的。</p>
<h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><h3 id="学习AQS的必要性"><a href="#学习AQS的必要性" class="headerlink" title="学习AQS的必要性"></a>学习AQS的必要性</h3><p>队列同步器 AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<h3 id="AQS使用方式和其中的设计模式"><a href="#AQS使用方式和其中的设计模式" class="headerlink" title="AQS使用方式和其中的设计模式"></a>AQS使用方式和其中的设计模式</h3><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int类型的state来代表这个状态，在抽象方法的实现过程当中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState) 和 compareAndSetState(int expect, int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<p>在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步的接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式的获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock 和 CountDownLatch等）。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：</p>
<p>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</p>
<p>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<p>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，我们最常见的就是Spring框架中的Template。</p>
<p><strong>举例说明</strong><br>假设，我们开了个蛋糕店，蛋糕店不能只卖一种蛋糕，于是我们决定先卖奶油蛋糕、芝士蛋糕和慕斯蛋糕，三种蛋糕在制作方式上一致，都包括造型、烘培和涂抹蛋糕，所以可以定义一个抽象蛋糕类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**模板方法**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shape();</span><br><span class="line">        <span class="keyword">this</span>.apply();</span><br><span class="line">        <span class="keyword">this</span>.brake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以批量生产三种蛋糕了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheeseCake</span> <span class="keyword">extends</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"芝士蛋糕造型"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"芝士蛋糕涂抹"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"芝士蛋糕烘培"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreamCake</span> <span class="keyword">extends</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"奶油蛋糕造型"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"奶油蛋糕涂抹"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"奶油蛋糕烘培"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuseCake</span> <span class="keyword">extends</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"慕斯蛋糕造型"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"慕斯蛋糕涂抹"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"慕斯蛋糕烘培"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractCake cake = <span class="keyword">new</span> CheeseCake();</span><br><span class="line"><span class="comment">//AbstractCake cake = new CreamCake();</span></span><br><span class="line"><span class="comment">//AbstractCake cake = new MuseCake();</span></span><br><span class="line">cake.run();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这样一来，不但可以批量生产三种蛋糕，而且如果日后有扩展，只需要继承抽象蛋糕方法就可以了，十分方便，我们天天生意做得越来越赚钱。突然有一天，我们发现市面有一种最简单的小蛋糕销量很好，这种蛋糕就是简单烘烤成型就可以卖，并不需要涂抹什么食材，由于制作简单销售量大，这个品种也很赚钱，于是我们也想要生产这种蛋糕。但是我们发现了一个问题，抽象蛋糕是定义了抽象的涂抹方法的，也就是说扩展的这种蛋糕是必须要实现涂抹方法，这就很鸡儿蛋疼了。怎么办？我们可以将原来的模板修改为带钩子的模板。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**模板方法**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shape();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isShouldApply())&#123;&#125;</span><br><span class="line">            <span class="keyword">this</span>.apply();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.brake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做小蛋糕的时候通过flag来控制是否涂抹，其余已有的蛋糕制作不需要任何修改可以照常进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCake</span> <span class="keyword">extends</span> <span class="title">AbstractCake</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> shouldApply)</span></span>&#123;</span><br><span class="line">        flag = shouldApply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">shouldApply</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"精致小蛋糕造型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"精致小蛋糕涂抹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"精致小蛋糕烘培"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS中的方法"><a href="#AQS中的方法" class="headerlink" title="AQS中的方法"></a>AQS中的方法</h3><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>实现自定义同步组件时，将会调用同步器提供的模板方法：</p>
<p><img alt="图片5.png" data-src="https://i.loli.net/2020/06/28/1roAM65ywNJumzV.png" class="lazyload"></p>
<p>这些模板方法同步器提供的模板方法基本上分为3类：<strong>独占式获取与释放同步状态</strong>、<strong>共享式获取与释放</strong>、<strong>同步状态和查询同步队列中的等待线程情况</strong></p>
<h4 id="可重写的方法"><a href="#可重写的方法" class="headerlink" title="可重写的方法"></a>可重写的方法</h4><p><img alt="图片6.png" data-src="https://i.loli.net/2020/06/28/EbHPvSCr3KUOxwJ.png" class="lazyload"></p>
<p><img alt="图片7.png" data-src="https://i.loli.net/2020/06/28/CoXg3REKizBmc7e.png" class="lazyload"></p>
<h4 id="访问或修改同步状态的方法"><a href="#访问或修改同步状态的方法" class="headerlink" title="访问或修改同步状态的方法"></a>访问或修改同步状态的方法</h4><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p>
<ul>
<li>getState()：获取当前同步状态。</li>
<li>setState(int newState)：设置当前同步状态。</li>
<li>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</li>
</ul>
<h3 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h3><p>CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p>
<p>CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地的变量上自旋，它不断轮训前驱的状态，假设发现了前驱释放了锁就结束自旋，当一个线程需要获取锁时：</p>
<p>1、创建一个QNode，将其中的locked设置为true，表示需要获取锁，myPred表示对其前驱结点的引用。</p>
<p><img alt="图片8.png" data-src="https://i.loli.net/2020/06/29/i4QTYpN9tuevcor.png" class="lazyload"></p>
<p>2、线程A对tail域调用getAndSet()方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred。</p>
<p><img alt="图片9.png" data-src="https://i.loli.net/2020/06/29/Si3xkeFUdvrlqa8.png" class="lazyload"></p>
<p>线程B需要获得锁，同样的流程再来一遍</p>
<p><img alt="图片10.png" data-src="https://i.loli.net/2020/06/29/7OsJ9VxRj1DLcE8.png" class="lazyload"></p>
<p>3、线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁（前驱结点的锁值 locked==false）</p>
<p>4、当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点</p>
<p><img alt="图片11.png" data-src="https://i.loli.net/2020/06/29/MRPazUEy7LCABIi.png" class="lazyload"></p>
<p>如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。</p>
<p><strong>CLH队列锁的优点</strong></p>
<p>空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O(L+n)，n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。</p>
<p>Java中的AQS是CLH队列锁的一种变体实现。</p>
<h3 id="ReentrantLock-的实现"><a href="#ReentrantLock-的实现" class="headerlink" title="ReentrantLock 的实现"></a>ReentrantLock 的实现</h3><h4 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h4><p>重进入是指任意线程在获取到锁之后，能够再次获取该锁而不会被锁阻塞，该特性的实现需要解决以下两个问题：</p>
<p>1）线程再次获取锁，锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取；</p>
<p>2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放了锁，其他线程能够获取到该锁，锁的最终释放要求锁对于获取进行进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p><strong>nonfairTryAcquire()</strong> 方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功，同步状态表示锁被一个线程重复获取的次数。</p>
<p>如果该锁被获取了n次，那么前（n-1）次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true，可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h4 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h4><p>ReentrantLock的构造函数中，默认的无参构造函数会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时，会把Sync对象创建为“公平锁”FairSync。</p>
<p>nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。</p>
<p>tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<h1 id="深入理解并发编程"><a href="#深入理解并发编程" class="headerlink" title="深入理解并发编程"></a>深入理解并发编程</h1><h2 id="JMM基础-计算机原理"><a href="#JMM基础-计算机原理" class="headerlink" title="JMM基础-计算机原理"></a>JMM基础-计算机原理</h2><p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。JMM遇到的问题与现代计算机中遇到的问题是差不多的。</p>
<p>物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>
<p>根据《Jeff Dean在Google全体工程大会的报告》我们可以看到</p>
<p><img alt="图片12.png" data-src="https://i.loli.net/2020/06/29/aVEP83D7tWQAOrT.png" class="lazyload"></p>
<p>计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。<br>（以下案例仅做说明，并不代表真实情况。）</p>
<p>如果从内存中读取1M的int型数据由CPU进行累加，耗时要多久？</p>
<p>做个简单的计算，1M的数据，Java里int型为32位，4个字节，共有1024<em>1024/4 = 262144个整数 ，则CPU 计算耗时：262144 </em>0.6 = 157 286 纳秒，而我们知道从内存读取1M数据需要250000纳秒，两者虽然有差距（当然这个差距并不小，十万纳秒的时间足够CPU执行将近二十万条指令了），但是还在一个数量级上。但是，没有任何缓存机制的情况下，意味着每个数都需要从内存中读取，这样加上CPU读取一次内存需要100纳秒，262144个整数从内存读取到CPU加上计算时间一共需要262144*100+250000 = 26 464 400 纳秒，这就存在着数量级上的差异了。</p>
<p>而且现实情况中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是基本上是无法消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p><img alt="图片13.png" data-src="https://i.loli.net/2020/06/29/LB6s7olvOyGAiNE.png" class="lazyload"></p>
<p><img alt="图片14.png" data-src="https://i.loli.net/2020/06/29/cW7mTxQJHp9SinK.png" class="lazyload"></p>
<p>在计算机系统中，寄存器划是L0级缓存，接着依次是L1，L2，L3（接下来是内存，本地磁盘，远程存储）。越往上的缓存存储空间越小，速度越快，成本也更高；越往下的存储空间越大，速度更慢，成本也更低。从上至下，每一层都可以看做是更下一层的缓存，即：L0寄存器是L1一级缓存的缓存，L1是L2的缓存，依次类推；每一层的数据都是来至它的下一层，所以每一层的数据是下一层的数据的子集。</p>
<p><img alt="图片15.png" data-src="https://i.loli.net/2020/06/29/5Px4JbjZU1AYg7M.png" class="lazyload"></p>
<p>在现代CPU上，一般来说L0， L1，L2，L3都集成在CPU内部，而L1还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存（Instruction Cache，I-Cache，L1i），分别用于存放数据和执行数据的指令解码。每个核心拥有独立的运算处理单元、控制器、寄存器、L1、L2缓存，然后一个CPU的多个核心共享最后一层CPU缓存L3。</p>
<h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个<font color="#ea3323">私有</font>的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img alt="图片16.png" data-src="https://i.loli.net/2020/06/29/wZrzbCBuvajdxoe.png" class="lazyload"></p>
<p><img alt="图片17.png" data-src="https://i.loli.net/2020/06/29/7dsgoJwvmZPOM3I.png" class="lazyload"></p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存中，之后再同步到主内存中，可是并不会即时的刷入主内存中，而是会有一定的时差，很明显这个时候线程A对变量V的操作对于线程B而言就不具备可见性了。</p>
<p>要解决共享对象可见性的问题，我们可以使用<strong>volatile关键字</strong>或者<strong>加锁</strong>。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>我们都知道CPU资源的分配都是以线程为单位的，并且是分时调用，操作系统允许某个进程执行一小段时间，例如50毫秒，过了50毫秒操作系统就会重新选择一个进程来执行（即我们所说的“任务切换”），这个50毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后。</p>
<p>那么线程切换为什么会带来问题呢？因为操作系统做任务切换，可以发生在任何一条CPU指令执行完！注意，是CPU指令！CPU指令！CPU指令！而不是高级语言里的一条语句，比如 count++，在Java里就是一条语句，但是高级语言里的一条语句往往需要多条CPU指令完成。其实count++至少包含了3条CPU指令！</p>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><h3 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h3><p>可以把volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步</p>
<p><img alt="图片18.png" data-src="https://i.loli.net/2020/06/29/T8KXO4mWzolLbQg.png" class="lazyload"></p>
<p>可以看成</p>
<p><img alt="图片19.png" data-src="https://i.loli.net/2020/06/29/8cN9ZdwrQhVRmyf.png" class="lazyload"></p>
<p>所以volatile本身具有以下这些特性：</p>
<p><strong>可见性</strong>：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p><strong>原子性</strong>：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作则不具备原子性。</p>
<p>volatile虽然能保证执行完并及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把 count=0 加载到主内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1却不是2。</p>
<h3 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h3><p>volatile关键字修饰的变量会存在一个“lock:”的前缀。</p>
<p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。<strong>LockLock会对CPU总线和高速缓存枷锁</strong>，可以理解为CPU指令级的一种锁。</p>
<p>同时该指令会将当前处理器缓存行的数据直接写回到系统内存中，且这个写回到内存的操作会使在其他CPU里缓存了该地址的数据无效。</p>
<h2 id="synchronized-的实现原理"><a href="#synchronized-的实现原理" class="headerlink" title="synchronized 的实现原理"></a>synchronized 的实现原理</h2><p>Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步的，虽然具体实现细节不大一样，但是都可以通过成对的MonitorEnter 和 MonitorExit 指令来实现。</p>
<p>对同步块，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而MonitorExit指令则插在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p>
<p>对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过MonitorEnter和MonitorExit来实现，相对于普通方法，其常量池中多了<strong>ACC_SYNCHRONIZED</strong>标识符。（注：这个后面研究Java字节码再细入）</p>
<p>JVM就是根据该标识符来实现方法同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标识是否被设置，如果设置了，执行线程将先获取 monitor，获取成功之后才能执行方法体，方法执行完后再释放Monitor。在方法执行期间，其他任何线程都无法再获得同一个Monitor对象。</p>
<p>synchronized使用的锁是存放在Java对象头里的</p>
<p><img alt="图片20.png" data-src="https://i.loli.net/2020/06/29/t2Gm8uHF6ZTivBN.png" class="lazyload"></p>
<p>具体位置是对象头的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息</p>
<p><img alt="图片21.png" data-src="https://i.loli.net/2020/06/29/py5bjYrscSGK62J.png" class="lazyload"></p>
<p>但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<p><img alt="图片22.png" data-src="https://i.loli.net/2020/06/29/CjbuEHThxVmnMJD.png" class="lazyload"></p>
<h3 id="了解各种锁"><a href="#了解各种锁" class="headerlink" title="了解各种锁"></a>了解各种锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><p>&gt;</p>
<blockquote>
<p>自旋锁原理非常简单，如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换消耗。</p>
<p>但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占有CPU自旋做无用功，所以需要设置一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间仍然没有释放锁，就会导致其他争用锁的线程在最大等待时间还是获取不到锁，这是争用线程就会停止自旋进入阻塞状态。</p>
</blockquote>
<h5 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a><strong>自旋锁的优缺点</strong></h5><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能最大幅度的提升，因为自旋的消耗小于线程阻塞挂起操作的消耗！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁之间一直都是占用CPU做无用功的，线程自旋的消耗大于线程阻塞挂起的操作消耗，其他需要CPU的线程又获取不到CPU，造成CPU的浪费。</p>
<h5 id="自旋锁的时间阈值"><a href="#自旋锁的时间阈值" class="headerlink" title="自旋锁的时间阈值"></a><strong>自旋锁的时间阈值</strong></h5><p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要。</p>
<p>JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制；</p>
<h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>一共有4种状态，<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>，它会随着竞争情况逐渐升级，锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>引入背景</strong>：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p>
<p><strong>偏向锁</strong> 顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁/解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁，它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<p><strong>偏向锁获取过程</strong>：</p>
<p>步骤1、 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
<p>步骤2、 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
<p>步骤3、 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
<p>步骤4、 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
<p>步骤5、 执行同步代码。</p>
<p><img alt="图片23.png" data-src="https://i.loli.net/2020/06/29/qTFcuIC1QbDopHz.png" class="lazyload"></p>
<p><strong>偏向锁的释放</strong>：</p>
<p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p><strong>偏向锁的适用场景</strong>：</p>
<p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p>
<p>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>
<p>jvm开启/关闭偏向锁<br>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>关闭偏向锁：-XX:-UseBiasedLocking</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p><strong>轻量级锁的加锁过程</strong>：</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态；</p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p><img alt="图片24.png" data-src="https://i.loli.net/2020/06/29/9kYuwBIU8e2nVly.png" class="lazyload"></p>
<h4 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h4><p><img alt="图片25.png" data-src="https://i.loli.net/2020/06/29/nTElAw3L8JVuCZj.png" class="lazyload"></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E8%BF%9B%E9%98%B6/">Java进阶    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/27/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GC%E6%9C%BA%E5%88%B6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta3.com.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>重拾Android-Java进阶之深入理解GC机制</span></div></a></div><div class="next-post pull_right"><a href="/2020/05/25/%E9%87%8D%E6%8B%BEAndroid-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta1.com.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>重拾Android-Java进阶之多线程与Android性能优化</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/01/重拾Android-Java进阶之RxJava编程原理/" title="重拾Android-Java进阶之RxJava编程原理"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/宇宙特辑/图片20.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之RxJava编程原理</div></a></div><div class="relatedPosts_item"><a href="/2020/05/31/重拾Android-Java进阶之深入理解IO/" title="重拾Android-Java进阶之深入理解IO"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/benjamin-elliott-LYdXESrw4dY-unsplash.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解IO</div></a></div><div class="relatedPosts_item"><a href="/2020/05/30/重拾Android-Java进阶之序列化/" title="重拾Android-Java进阶之序列化"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/cover/sean-lim-NPlv2pkYoUA-unsplash.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之序列化</div></a></div><div class="relatedPosts_item"><a href="/2020/05/29/重拾Android-Java进阶之深入理解ClassLoader类加载/" title="重拾Android-Java进阶之深入理解ClassLoader类加载"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta2.com.jpeg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解ClassLoader类加载</div></a></div><div class="relatedPosts_item"><a href="/2020/05/28/重拾Android-Java进阶之深入理解JVM/" title="重拾Android-Java进阶之深入理解JVM"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/photo-1589371709918-9dfa8c55338e.jpg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解JVM</div></a></div><div class="relatedPosts_item"><a href="/2020/05/27/重拾Android-Java进阶之深入理解GC机制/" title="重拾Android-Java进阶之深入理解GC机制"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/uploadbeta3.com.jpeg"><div class="relatedPosts_title">重拾Android-Java进阶之深入理解GC机制</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzU5OC8yNDA5OA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/uPic/1L0ne8.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2020 By Leo·Cheung</div><div class="footer_custom_text">Some of life, you have to go to the great challanges. - By Kobe Bryant</div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>浙ICP备19024714号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script async src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/LeoCheung0221/tufusiCDN@latest/dist/APlayer.min.js"></script><div class="aplayer" id="player"><script>$(function() {
    $.ajax({
        url: "https://api.i-meto.com/meting/api?server=netease&type=playlist&id=416198729",
        success: function(e) {
            var aplayerList = new APlayer({
            element: document.getElementById('player'),
            narrow: false,
            autoplay: true,
            showlrc: false,
            mutex: true,
            theme: '#FFF0',
            mode: 'random',
            preload: 'metadata',
            fixed:true,
            listmaxheight: '200px',
            music:JSON.parse(e)
            });
            window.aplayers || (window.aplayers = []),
            window.aplayers.push(aplayerList)
        }
    })
    //change aplayer style
    var aplayer  = document.getElementById('player');
    aplayer.style.boxShadow = 'none';
    aplayer.style.marginTop = '10px';
    $('.aplayer-list-light').css('background','#d8e2eb69');
})</script></div></body></html>