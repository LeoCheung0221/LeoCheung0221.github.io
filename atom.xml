<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OnePiece</title>
  <subtitle>Some of life, you have to go to the great challanges. - By Kobe Bryant</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tufusi.com/"/>
  <updated>2016-08-13T14:29:11.749Z</updated>
  <id>http://tufusi.com/</id>
  
  <author>
    <name>LeoCheung</name>
    <email>leocheung4ever@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进阶系列APP重构</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8BAPP%E9%87%8D%E6%9E%84/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之APP重构/</id>
    <published>2016-08-13T08:30:12.000Z</published>
    <updated>2016-08-13T14:29:11.749Z</updated>
    
    <content type="html">&lt;h1 id=&quot;关于App重构&quot;&gt;&lt;a href=&quot;#关于App重构&quot; class=&quot;headerlink&quot; title=&quot;关于App重构&quot;&gt;&lt;/a&gt;关于App重构&lt;/h1&gt;&lt;p&gt;对于架构的设计理念，一定随着项目经验的累积而逐渐清晰，我始终坚信，没有哪一个架构完美，如果有，那一定是。。。骗人的！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;而我能做的，就是这个架构设计Bigger than bigger(比逼格更有逼格)，曾经有位同事告诉我，你所认为别人的牛逼，只是你不懂，等你进了这个门，不过就这样。说这些不是为了说明别人所做的事情多么多么简单，而是一定要专注。工作了两年，见到过特别优秀的人有很多，每个人所散发出的气质多少都有不同，但唯一不变的，就是专注的眼神，你专注的干一件事，一年，两年，许多年，相信我，一定会成功。&lt;/p&gt;
&lt;p&gt;感（zhuang）慨（bi）结束，开搞！！！&lt;/p&gt;
&lt;h2 id=&quot;什么情况下需要重构&quot;&gt;&lt;a href=&quot;#什么情况下需要重构&quot; class=&quot;headerlink&quot; title=&quot;什么情况下需要重构&quot;&gt;&lt;/a&gt;什么情况下需要重构&lt;/h2&gt;&lt;h3 id=&quot;结构混乱&quot;&gt;&lt;a href=&quot;#结构混乱&quot; class=&quot;headerlink&quot; title=&quot;结构混乱&quot;&gt;&lt;/a&gt;结构混乱&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代码的层次感觉差，无奈业务线傻傻分不清&lt;/li&gt;
&lt;li&gt;业务模块间层次交替，主次不分，藕断丝连&lt;/li&gt;
&lt;li&gt;架构多样，你喜欢她，她喜欢他，他喜欢他&lt;/li&gt;
&lt;li&gt;编码风格各成一派，天下武林本一家，何必&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;可读性差&quot;&gt;&lt;a href=&quot;#可读性差&quot; class=&quot;headerlink&quot; title=&quot;可读性差&quot;&gt;&lt;/a&gt;可读性差&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;能一个类写下的，坚决不写第二个类 – 啊喂 new个class又不要钱&lt;/li&gt;
&lt;li&gt;编码格式，我型我秀，自立门派 – 西八 写代码我们是专业的好不&lt;/li&gt;
&lt;li&gt;多余，无用代码满屏飞 – 求得麻碟 这还不足以激起你的强迫症吗&lt;/li&gt;
&lt;li&gt;注释、注释、注释 – 斯国一 能装一波的地方还浪费掉那就可惜了&lt;/li&gt;
&lt;li&gt;继承、接口拼命用 – 他母亲的 可算是找到你大爷的大爷的大爷了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;无法弹性适应产品发展&quot;&gt;&lt;a href=&quot;#无法弹性适应产品发展&quot; class=&quot;headerlink&quot; title=&quot;无法弹性适应产品发展&quot;&gt;&lt;/a&gt;无法弹性适应产品发展&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;维护困难，牵一发而动全身&lt;/li&gt;
&lt;li&gt;业务线转变，代码就会改的面目全非&lt;/li&gt;
&lt;li&gt;新功能加入，更是找不到接入点，只能另起炉灶&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;重构目标&quot;&gt;&lt;a href=&quot;#重构目标&quot; class=&quot;headerlink&quot; title=&quot;重构目标&quot;&gt;&lt;/a&gt;重构目标&lt;/h2&gt;&lt;p&gt;重构 = 代码质量 &lt;em&gt; 代码质量 &lt;/em&gt; 代码质量 …..&lt;/p&gt;
&lt;p&gt;请接招&lt;/p&gt;
&lt;h3 id=&quot;可读性&quot;&gt;&lt;a href=&quot;#可读性&quot; class=&quot;headerlink&quot; title=&quot;可读性&quot;&gt;&lt;/a&gt;可读性&lt;/h3&gt;&lt;h4 id=&quot;越简单越要做好-－-凭你的智慧，我很难跟你解释&quot;&gt;&lt;a href=&quot;#越简单越要做好-－-凭你的智慧，我很难跟你解释&quot; class=&quot;headerlink&quot; title=&quot;越简单越要做好　－　凭你的智慧，我很难跟你解释&quot;&gt;&lt;/a&gt;越简单越要做好　－　凭你的智慧，我很难跟你解释&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有规矩成方圆 - 统一规范的命名 简洁有效的注释 有问题待解决用TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;国有国法行有行规-－-你以为躲起来就找不到你了吗？没有用的！像你这样出色的男人，无论在什么地方，都像漆黑中的萤火虫一样，那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣子，神乎其神的刀法，和那杯Dry-Martine，都深深地迷住了我。不过，虽然你是这样的出色，但是行有行规，无论怎样你要付清昨晚的过夜费呀，叫女人就不用给钱么？&quot;&gt;&lt;a href=&quot;#国有国法行有行规-－-你以为躲起来就找不到你了吗？没有用的！像你这样出色的男人，无论在什么地方，都像漆黑中的萤火虫一样，那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣子，神乎其神的刀法，和那杯Dry-Martine，都深深地迷住了我。不过，虽然你是这样的出色，但是行有行规，无论怎样你要付清昨晚的过夜费呀，叫女人就不用给钱么？&quot; class=&quot;headerlink&quot; title=&quot;国有国法行有行规　－　你以为躲起来就找不到你了吗？没有用的！像你这样出色的男人，无论在什么地方，都像漆黑中的萤火虫一样，那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣子，神乎其神的刀法，和那杯Dry Martine，都深深地迷住了我。不过，虽然你是这样的出色，但是行有行规，无论怎样你要付清昨晚的过夜费呀，叫女人就不用给钱么？&quot;&gt;&lt;/a&gt;国有国法行有行规　－　你以为躲起来就找不到你了吗？没有用的！像你这样出色的男人，无论在什么地方，都像漆黑中的萤火虫一样，那样的鲜明，那样的出众。你那忧郁的眼神，唏嘘的胡渣子，神乎其神的刀法，和那杯Dry Martine，都深深地迷住了我。不过，虽然你是这样的出色，但是行有行规，无论怎样你要付清昨晚的过夜费呀，叫女人就不用给钱么？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;结构清层次明 - 能解耦就解，想办法抽离出变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;简约而不简单-－-你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？-悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又…你看我还没说完你又把棍子给扔掉了！月光宝盒是宝物，你把他扔掉会污染环境，要是砸到小朋友怎么办？就算砸不到小朋友砸到那些花花草草也是不对的！&quot;&gt;&lt;a href=&quot;#简约而不简单-－-你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？-悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又…你看我还没说完你又把棍子给扔掉了！月光宝盒是宝物，你把他扔掉会污染环境，要是砸到小朋友怎么办？就算砸不到小朋友砸到那些花花草草也是不对的！&quot; class=&quot;headerlink&quot; title=&quot;简约而不简单　－　你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？ 悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又…你看我还没说完你又把棍子给扔掉了！月光宝盒是宝物，你把他扔掉会污染环境，要是砸到小朋友怎么办？就算砸不到小朋友砸到那些花花草草也是不对的！&quot;&gt;&lt;/a&gt;简约而不简单　－　你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？ 悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又…你看我还没说完你又把棍子给扔掉了！月光宝盒是宝物，你把他扔掉会污染环境，要是砸到小朋友怎么办？就算砸不到小朋友砸到那些花花草草也是不对的！&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;逻辑简约 - 拒绝一类含千行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;模式虽好不要贪杯-－-唉，那个金刚圈尺寸太差，前重后轻左宽右窄，他戴上之后很不舒服，整晚失眠，会连累我嘛！他虽然是个猴子，可是你也不能这样对他，官府知道了会说我虐待动物的！说起那个金刚圈，去年我在陈家村认识了一位铁匠，他手工精美、价钱又公道、童叟无欺，干脆我介绍你再定做一个吧！&quot;&gt;&lt;a href=&quot;#模式虽好不要贪杯-－-唉，那个金刚圈尺寸太差，前重后轻左宽右窄，他戴上之后很不舒服，整晚失眠，会连累我嘛！他虽然是个猴子，可是你也不能这样对他，官府知道了会说我虐待动物的！说起那个金刚圈，去年我在陈家村认识了一位铁匠，他手工精美、价钱又公道、童叟无欺，干脆我介绍你再定做一个吧！&quot; class=&quot;headerlink&quot; title=&quot;模式虽好不要贪杯　－　唉，那个金刚圈尺寸太差，前重后轻左宽右窄，他戴上之后很不舒服，整晚失眠，会连累我嘛！他虽然是个猴子，可是你也不能这样对他，官府知道了会说我虐待动物的！说起那个金刚圈，去年我在陈家村认识了一位铁匠，他手工精美、价钱又公道、童叟无欺，干脆我介绍你再定做一个吧！&quot;&gt;&lt;/a&gt;模式虽好不要贪杯　－　唉，那个金刚圈尺寸太差，前重后轻左宽右窄，他戴上之后很不舒服，整晚失眠，会连累我嘛！他虽然是个猴子，可是你也不能这样对他，官府知道了会说我虐待动物的！说起那个金刚圈，去年我在陈家村认识了一位铁匠，他手工精美、价钱又公道、童叟无欺，干脆我介绍你再定做一个吧！&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;设计模式 - 用好但不滥用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;可维护性&quot;&gt;&lt;a href=&quot;#可维护性&quot; class=&quot;headerlink&quot; title=&quot;可维护性&quot;&gt;&lt;/a&gt;可维护性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;杜绝魔鬼数字、字符串、尺寸值、颜色值等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码复用，以便维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不写死，预测可能的变化(但不要提前设计)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;可扩展性&quot;&gt;&lt;a href=&quot;#可扩展性&quot; class=&quot;headerlink&quot; title=&quot;可扩展性&quot;&gt;&lt;/a&gt;可扩展性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;良好的分层结构，MVx模式运用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过一些设计模式的使用来提高可扩展性。&lt;/p&gt;
&lt;p&gt;  法则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S(单一职责) －　Single Responsibility Principle ******************************* SRP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;＝＞　每个方法或类应当有且仅有一个改变的理由。这明确指出每个方法或类就应该只负责一件事，或者一项职责。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;O(开放/封闭)－　Open/Close Principle ****************************************** OCP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;＝＞　软件(方法、类)应当对扩展开放，对修改关闭。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L(里氏替换) －　Liskov Substitution Principle ********************************* LSP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;＝＞　用超类代替应用程序中使用的对象时，应当不会破坏应用程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I(接口分离) －　Interface Segregation Principle ******************************* ISP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;＝＞　不应当强制客户端依赖于其不使用的接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D(依赖倒置) －　Dependency Inversion Principle ******************************** DIP 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;＝＞　代码应当取决于抽象概念，而不是具体实现；这些抽象不应当依赖于细节；而细节应当依赖于抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何重构&quot;&gt;&lt;a href=&quot;#如何重构&quot; class=&quot;headerlink&quot; title=&quot;如何重构&quot;&gt;&lt;/a&gt;如何重构&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;何为重构: 软件工程希望建立完美的需求与设计，按照既有的规范编写标准划一的代码。
         快速迭代和RAD颠覆&amp;quot;全知全能&amp;quot;的神话,用近乎刀劈斧砍(crack)的方式解决问题。
此为refactoring
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为进行已久的Android工程，该如何重构?&lt;br&gt;以下参考大神blog&lt;/p&gt;
&lt;h3 id=&quot;架构选择，结构调整&quot;&gt;&lt;a href=&quot;#架构选择，结构调整&quot; class=&quot;headerlink&quot; title=&quot;架构选择，结构调整&quot;&gt;&lt;/a&gt;架构选择，结构调整&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据Project业务场景(展示型、交互型、后台工具型…)选择合适的架构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 并不是说一定要选用一个架构，比如说后台工具型的App，可能界面不多，与服务器的交互也少，基本都是由Service组成，这样直接用Android原生结构就OK。

2. 界面较多，且与服务器交互较多的建议选用MVP架构。可以通过P来做数据处理，将数据源M与展示层V解耦，便于替换数据源或是改变UI。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据选用的架构以及业务模块分包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;技术-开源库选定&quot;&gt;&lt;a href=&quot;#技术-开源库选定&quot; class=&quot;headerlink&quot; title=&quot;技术/开源库选定&quot;&gt;&lt;/a&gt;技术/开源库选定&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ListView/RecyclerView的选择，Fragment/Activity的选择等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据业务特点和选择的架构，选用相关技术/开源库支持或对当前使用的进行整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例如HTTP请求库，缓存库，图片加载库等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;确定规范&quot;&gt;&lt;a href=&quot;#确定规范&quot; class=&quot;headerlink&quot; title=&quot;确定规范&quot;&gt;&lt;/a&gt;确定规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指定编码习惯，可以根据Google推荐的Java编码规范，适当定制。&lt;/p&gt;
&lt;p&gt;  正所谓高冷的英雄从不看身后的火焰！客人你的&lt;a href=&quot;http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/&quot;&gt;蛋（代）炒（码）饭（规范）&lt;/a&gt;来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;制定代码提交规范，git flow 管理流程规范等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;自底而上，由小至大&quot;&gt;&lt;a href=&quot;#自底而上，由小至大&quot; class=&quot;headerlink&quot; title=&quot;自底而上，由小至大&quot;&gt;&lt;/a&gt;自底而上，由小至大&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从底部开始，也就是常说的Model层，数据层开始，因为这部分相对独立，可以通过接口与UI层隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要一下就大面积重构，需要逐个击破，确保当前的每一次改动都能正常运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;持续重构，伴随测试&quot;&gt;&lt;a href=&quot;#持续重构，伴随测试&quot; class=&quot;headerlink&quot; title=&quot;持续重构，伴随测试&quot;&gt;&lt;/a&gt;持续重构，伴随测试&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;持续进行小范围重构，每次重构都要伴随测试进行，保证重构质量&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;提取方法,去除重复代码；&lt;/li&gt;
&lt;li&gt;结构调整；&lt;/li&gt;
&lt;li&gt;融入面向对象/接口编程思想，注意SOLID原则；&lt;/li&gt;
&lt;li&gt;多用组合，少用继承&lt;/li&gt;
&lt;li&gt;… …&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最好有单元测试支持&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;重构而非重写&quot;&gt;&lt;a href=&quot;#重构而非重写&quot; class=&quot;headerlink&quot; title=&quot;重构而非重写&quot;&gt;&lt;/a&gt;重构而非重写&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看书看书看书 再做总结　－－　《重构-改善既有代码的设计》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;附文-－-关于架构重构的规则&quot;&gt;&lt;a href=&quot;#附文-－-关于架构重构的规则&quot; class=&quot;headerlink&quot; title=&quot;附文 － 关于架构重构的规则&quot;&gt;&lt;/a&gt;附文 － 关于架构重构的规则&lt;/h2&gt;&lt;p&gt;Uber技术主管在OSAC上谈及的关于架构重构的12条规则，不一起学习未免可惜：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LeoCheung0221/LeoCheung0221.github.io/master/image/refratoring.png&quot; alt=&quot;REFRATORING&quot;&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于App重构&quot;&gt;&lt;a href=&quot;#关于App重构&quot; class=&quot;headerlink&quot; title=&quot;关于App重构&quot;&gt;&lt;/a&gt;关于App重构&lt;/h1&gt;&lt;p&gt;对于架构的设计理念，一定随着项目经验的累积而逐渐清晰，我始终坚信，没有哪一个架构完美，如果有，那一定是。。。骗人的！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列之求职路漫漫</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B1%82%E8%81%8C%E8%B7%AF%E6%BC%AB%E6%BC%AB/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之求职路漫漫/</id>
    <published>2016-08-13T08:28:17.000Z</published>
    <updated>2016-08-13T10:38:55.019Z</updated>
    
    <content type="html">&lt;h1 id=&quot;国内一线互联网公司内部面试题库&quot;&gt;&lt;a href=&quot;#国内一线互联网公司内部面试题库&quot; class=&quot;headerlink&quot; title=&quot;国内一线互联网公司内部面试题库&quot;&gt;&lt;/a&gt;国内一线互联网公司内部面试题库&lt;/h1&gt;&lt;p&gt;摘自大神博客，基于面试，个人觉得整理的还是很全面的，大公司看重的技术能力，那一定是在应对项目时常常遇到的技术，能掌握这些，一是让自己的技术水准能更上一层楼，二，是个人观点，男人总得上进，进入大公司，体验500强公司的文化，对做人处世都大有裨益。&lt;/p&gt;
&lt;p&gt;So just try it and try it!&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、java基础&quot;&gt;&lt;a href=&quot;#一、java基础&quot; class=&quot;headerlink&quot; title=&quot;一、java基础&quot;&gt;&lt;/a&gt;一、java基础&lt;/h2&gt;&lt;h3 id=&quot;1-接口的意义-（百度）&quot;&gt;&lt;a href=&quot;#1-接口的意义-（百度）&quot; class=&quot;headerlink&quot; title=&quot;1.接口的意义**（百度）&quot;&gt;&lt;/a&gt;1.接口的意义**（百度）&lt;/h3&gt;&lt;p&gt;规范、扩展、回调&lt;/p&gt;
&lt;h3 id=&quot;2-抽象类的意义-（乐视）&quot;&gt;&lt;a href=&quot;#2-抽象类的意义-（乐视）&quot; class=&quot;headerlink&quot; title=&quot;2.抽象类的意义**（乐视）&quot;&gt;&lt;/a&gt;2.抽象类的意义**（乐视）&lt;/h3&gt;&lt;p&gt;为其子类提供一个公共的类型&lt;br&gt;封装子类中得重复内容&lt;br&gt;定义抽象方法，子类虽然有不同的实现 但是定义是一致的&lt;/p&gt;
&lt;h3 id=&quot;3-内部类的作用-百度，乐视&quot;&gt;&lt;a href=&quot;#3-内部类的作用-百度，乐视&quot; class=&quot;headerlink&quot; title=&quot;3.内部类的作用**(百度，乐视)&quot;&gt;&lt;/a&gt;3.内部类的作用**(百度，乐视)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。&lt;/li&gt;
&lt;li&gt;在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。&lt;/li&gt;
&lt;li&gt;创建内部类对象的时刻并不依赖于外围类对象的创建。&lt;/li&gt;
&lt;li&gt;内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。&lt;/li&gt;
&lt;li&gt;内部类提供了更好的封装，除了该外围类，其他类都不能访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-父类的静态方法能否被子类重写，为什么？-（猎豹）&quot;&gt;&lt;a href=&quot;#4-父类的静态方法能否被子类重写，为什么？-（猎豹）&quot; class=&quot;headerlink&quot; title=&quot;4.父类的静态方法能否被子类重写，为什么？**（猎豹）&quot;&gt;&lt;/a&gt;4.父类的静态方法能否被子类重写，为什么？**（猎豹）&lt;/h3&gt;&lt;p&gt;不能。&lt;/p&gt;
&lt;p&gt;子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现&lt;/p&gt;
&lt;h3 id=&quot;5-举1-2个排序算法，并使用java代码实现-（美团）&quot;&gt;&lt;a href=&quot;#5-举1-2个排序算法，并使用java代码实现-（美团）&quot; class=&quot;headerlink&quot; title=&quot;5.举1-2个排序算法，并使用java代码实现**（美团）&quot;&gt;&lt;/a&gt;5.举1-2个排序算法，并使用java代码实现**（美团）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qy1387/article/details/7752973&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;排序算法总结&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-列举java的集合及其之间继承关系-（百度、美团）&quot;&gt;&lt;a href=&quot;#6-列举java的集合及其之间继承关系-（百度、美团）&quot; class=&quot;headerlink&quot; title=&quot;6.列举java的集合及其之间继承关系**（百度、美团）&quot;&gt;&lt;/a&gt;6.列举java的集合及其之间继承关系**（百度、美团）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/collection.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-java虚拟机的特性-（百度、乐视）&quot;&gt;&lt;a href=&quot;#7-java虚拟机的特性-（百度、乐视）&quot; class=&quot;headerlink&quot; title=&quot;7.java虚拟机的特性**（百度、乐视）&quot;&gt;&lt;/a&gt;7.java虚拟机的特性**（百度、乐视）&lt;/h3&gt;&lt;p&gt;Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。&lt;/p&gt;
&lt;h3 id=&quot;8-哪些情况下的对象会被垃圾回收机制处理掉-（乐视、美团、小米）&quot;&gt;&lt;a href=&quot;#8-哪些情况下的对象会被垃圾回收机制处理掉-（乐视、美团、小米）&quot; class=&quot;headerlink&quot; title=&quot;8.哪些情况下的对象会被垃圾回收机制处理掉**（乐视、美团、小米）&quot;&gt;&lt;/a&gt;8.哪些情况下的对象会被垃圾回收机制处理掉**（乐视、美团、小米）&lt;/h3&gt;&lt;p&gt;Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。&lt;/p&gt;
&lt;h3 id=&quot;9-进程和线程的区别-（猎豹）&quot;&gt;&lt;a href=&quot;#9-进程和线程的区别-（猎豹）&quot; class=&quot;headerlink&quot; title=&quot;9.进程和线程的区别**（猎豹）&quot;&gt;&lt;/a&gt;9.进程和线程的区别**（猎豹）&lt;/h3&gt;&lt;p&gt;简而言之,一个程序至少有一个进程,一个进程至少有一个线程。&lt;/p&gt;
&lt;p&gt;线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;/p&gt;
&lt;p&gt;另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;/p&gt;
&lt;p&gt;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;/p&gt;
&lt;p&gt;从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/p&gt;
&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.&lt;/p&gt;
&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.&lt;/p&gt;
&lt;p&gt;一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.&lt;/p&gt;
&lt;p&gt;进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。&lt;/p&gt;
&lt;h3 id=&quot;10-Java中-和equals的区别，equals和hashCode的区别-（乐视）&quot;&gt;&lt;a href=&quot;#10-Java中-和equals的区别，equals和hashCode的区别-（乐视）&quot; class=&quot;headerlink&quot; title=&quot;10.Java中==和equals的区别，equals和hashCode的区别**（乐视）&quot;&gt;&lt;/a&gt;10.Java中==和equals的区别，equals和hashCode的区别**（乐视）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tiantiandjava/article/details/46988461&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;11-常见的排序算法时间复杂度-（小米）&quot;&gt;&lt;a href=&quot;#11-常见的排序算法时间复杂度-（小米）&quot; class=&quot;headerlink&quot; title=&quot;11.常见的排序算法时间复杂度**（小米）&quot;&gt;&lt;/a&gt;11.常见的排序算法时间复杂度**（小米）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/algorithm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-HashMap的实现原理-（美团）&quot;&gt;&lt;a href=&quot;#12-HashMap的实现原理-（美团）&quot; class=&quot;headerlink&quot; title=&quot;12.HashMap的实现原理**（美团）&quot;&gt;&lt;/a&gt;12.HashMap的实现原理**（美团）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. HashMap概述：
      HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 
2. HashMap的数据结构：
   在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/hashmap.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。&lt;/p&gt;
&lt;h3 id=&quot;13-java-状态机&quot;&gt;&lt;a href=&quot;#13-java-状态机&quot; class=&quot;headerlink&quot; title=&quot;13.java 状态机**&quot;&gt;&lt;/a&gt;13.java 状态机**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.jdon.com/designpatterns/designpattern_State.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;状态机&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-java中int-char-long各占多少字节数&quot;&gt;&lt;a href=&quot;#14-java中int-char-long各占多少字节数&quot; class=&quot;headerlink&quot; title=&quot;14.java中int char long各占多少字节数**&quot;&gt;&lt;/a&gt;14.java中int char long各占多少字节数**&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;基本类型    位数    字节数
  byte       8        1

  short      16       2

  int        32       4

  long       64       8

  float      32       4

  double     64       8

  char       16       2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;15-java-int与integer的区别&quot;&gt;&lt;a href=&quot;#15-java-int与integer的区别&quot; class=&quot;headerlink&quot; title=&quot;15.java int与integer的区别**&quot;&gt;&lt;/a&gt;15.java int与integer的区别**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;16-string-stringbuffer-stringbuilder-区别-（小米、乐视、百度）&quot;&gt;&lt;a href=&quot;#16-string-stringbuffer-stringbuilder-区别-（小米、乐视、百度）&quot; class=&quot;headerlink&quot; title=&quot;16.string stringbuffer stringbuilder 区别**（小米、乐视、百度）&quot;&gt;&lt;/a&gt;16.string stringbuffer stringbuilder 区别**（小米、乐视、百度）&lt;/h3&gt;&lt;p&gt;String 字符串常量&lt;/p&gt;
&lt;p&gt;StringBuffer 字符串变量（线程安全）&lt;/p&gt;
&lt;p&gt;StringBuilder 字符串变量（非线程安全）&lt;/p&gt;
&lt;p&gt;简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。&lt;/p&gt;
&lt;p&gt;而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：&lt;/p&gt;
&lt;p&gt;String S1 = “This is only a” + “ simple” + “ test”;&lt;/p&gt;
&lt;p&gt;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);&lt;br&gt;你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个&lt;br&gt; String S1 = “This is only a” + “ simple” + “test”; 其实就是：&lt;br&gt; String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：&lt;br&gt; String S2 = “This is only a”;&lt;br&gt;String S3 = “ simple”;&lt;br&gt;String S4 = “ test”;&lt;br&gt;String S1 = S2 +S3 + S4;&lt;br&gt;这时候 JVM 会规规矩矩的按照原来的方式去做&lt;/p&gt;
&lt;p&gt;在大部分情况下 StringBuffer &amp;gt; String&lt;/p&gt;
&lt;p&gt;StringBuffer&lt;/p&gt;
&lt;p&gt;Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。&lt;/p&gt;
&lt;p&gt;可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。&lt;/p&gt;
&lt;p&gt;StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。&lt;/p&gt;
&lt;p&gt;例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。&lt;/p&gt;
&lt;p&gt;在大部分情况下 StringBuilder &amp;gt; StringBuffer&lt;/p&gt;
&lt;p&gt;java.lang.StringBuilder&lt;/p&gt;
&lt;p&gt;java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同&lt;/p&gt;
&lt;h3 id=&quot;17-Java多态-（乐视）&quot;&gt;&lt;a href=&quot;#17-Java多态-（乐视）&quot; class=&quot;headerlink&quot; title=&quot;17.Java多态**（乐视）&quot;&gt;&lt;/a&gt;17.Java多态**（乐视）&lt;/h3&gt;&lt;p&gt;Java多态性理解&lt;/p&gt;
&lt;p&gt;Java中多态性的实现&lt;/p&gt;
&lt;p&gt;什么是多态&lt;/p&gt;
&lt;p&gt;面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。&lt;/p&gt;
&lt;p&gt;多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）&lt;/p&gt;
&lt;p&gt;实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实&lt;br&gt;际类型，根据其实际的类型调用其相应的方法。&lt;/p&gt;
&lt;p&gt;多态的作用：消除类型之间的耦合关系。&lt;/p&gt;
&lt;p&gt;现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。&lt;br&gt;下面是多态存在的三个必要条件，要求大家做梦时都能背出来！&lt;/p&gt;
&lt;p&gt;多态存在的三个必要条件&lt;br&gt;一、要有继承；&lt;br&gt;二、要有重写；&lt;br&gt;三、父类引用指向子类对象。&lt;/p&gt;
&lt;p&gt; 多态的好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。&lt;/p&gt;
&lt;h3 id=&quot;18-什么导致线程阻塞-（58、美团）&quot;&gt;&lt;a href=&quot;#18-什么导致线程阻塞-（58、美团）&quot; class=&quot;headerlink&quot; title=&quot;18.什么导致线程阻塞**（58、美团）&quot;&gt;&lt;/a&gt;18.什么导致线程阻塞**（58、美团）&lt;/h3&gt;&lt;p&gt;线程的阻塞&lt;/p&gt;
&lt;p&gt;为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.&lt;/p&gt;
&lt;p&gt;阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。&lt;br&gt;典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。&lt;/li&gt;
&lt;li&gt;suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。&lt;/li&gt;
&lt;li&gt;yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.&lt;/li&gt;
&lt;li&gt;wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。&lt;/p&gt;
&lt;p&gt;上述的核心区别导致了一系列的细节上的区别。&lt;/p&gt;
&lt;p&gt;首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。&lt;/p&gt;
&lt;p&gt;其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。&lt;/p&gt;
&lt;p&gt;wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。&lt;/p&gt;
&lt;p&gt;关于 wait() 和 notify() 方法最后再说明两点：&lt;/p&gt;
&lt;p&gt;第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。&lt;/p&gt;
&lt;p&gt;第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。&lt;/p&gt;
&lt;p&gt;谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。&lt;/p&gt;
&lt;p&gt;以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。&lt;/p&gt;
&lt;h3 id=&quot;19-抽象类接口区别-（360）&quot;&gt;&lt;a href=&quot;#19-抽象类接口区别-（360）&quot; class=&quot;headerlink&quot; title=&quot;19.抽象类接口区别**（360）&quot;&gt;&lt;/a&gt;19.抽象类接口区别**（360）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认的方法实现&lt;br&gt;抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现&lt;br&gt;子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。&lt;br&gt;子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造器&lt;br&gt;抽象类可以有构造器&lt;br&gt;接口不能有构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与正常Java类的区别&lt;br&gt;除了你不能实例化抽象类之外，它和普通Java类没有任何区&lt;br&gt;接口是完全不同的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问修饰符&lt;br&gt;抽象方法可以有public、protected和default这些修饰符&lt;br&gt;接口方法默认修饰符是public。你不可以使用其它修饰符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;main方法&lt;br&gt;抽象方法可以有main方法并且我们可以运行它&lt;br&gt;接口没有main方法，因此我们不能运行它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多继承&lt;br&gt;抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;速度&lt;br&gt;它比接口速度要快&lt;br&gt;接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加新方法&lt;br&gt;如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。&lt;br&gt;如果你往接口中添加方法，那么你必须改变实现该接口的类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;20-容器类之间的区别-（乐视、美团）&quot;&gt;&lt;a href=&quot;#20-容器类之间的区别-（乐视、美团）&quot; class=&quot;headerlink&quot; title=&quot;20.容器类之间的区别**（乐视、美团）&quot;&gt;&lt;/a&gt;20.容器类之间的区别**（乐视、美团）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;总结1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://alexyyek.github.io/2015/04/06/Collection/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;总结2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tianmaying.com/tutorial/java_collection&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;总结3&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;21-java-内部类-（小米）&quot;&gt;&lt;a href=&quot;#21-java-内部类-（小米）&quot; class=&quot;headerlink&quot; title=&quot;21.java 内部类**（小米）&quot;&gt;&lt;/a&gt;21.java 内部类**（小米）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/3388487.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-Java中hashmap和hashtable的区别-（乐视、小米）&quot;&gt;&lt;a href=&quot;#22-Java中hashmap和hashtable的区别-（乐视、小米）&quot; class=&quot;headerlink&quot; title=&quot;22.Java中hashmap和hashtable的区别**（乐视、小米）&quot;&gt;&lt;/a&gt;22.Java中hashmap和hashtable的区别**（乐视、小米）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-ArrayMap-VS-HashMap&quot;&gt;&lt;a href=&quot;#23-ArrayMap-VS-HashMap&quot; class=&quot;headerlink&quot; title=&quot;23.ArrayMap VS HashMap**&quot;&gt;&lt;/a&gt;23.ArrayMap VS HashMap**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://lvable.com/?p=217&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;比较&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、android基础&quot;&gt;&lt;a href=&quot;#二、android基础&quot; class=&quot;headerlink&quot; title=&quot;二、android基础&quot;&gt;&lt;/a&gt;二、android基础&lt;/h2&gt;&lt;h3 id=&quot;1-数据库的操作类型有哪些，如何导入外部数据库？&quot;&gt;&lt;a href=&quot;#1-数据库的操作类型有哪些，如何导入外部数据库？&quot; class=&quot;headerlink&quot; title=&quot;1.数据库的操作类型有哪些，如何导入外部数据库？**&quot;&gt;&lt;/a&gt;1.数据库的操作类型有哪些，如何导入外部数据库？**&lt;/h3&gt;&lt;p&gt;把原数据库包括在项目源码的 res/raw &lt;/p&gt;
&lt;p&gt;android系统下数据库应该存放在 /data/data/com.&lt;em&gt;.&lt;/em&gt;（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.&lt;/p&gt;
&lt;h3 id=&quot;2-是否使用过本地广播，和全局广播有什么差别？&quot;&gt;&lt;a href=&quot;#2-是否使用过本地广播，和全局广播有什么差别？&quot; class=&quot;headerlink&quot; title=&quot;2.是否使用过本地广播，和全局广播有什么差别？**&quot;&gt;&lt;/a&gt;2.是否使用过本地广播，和全局广播有什么差别？**&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。
不用担心别的应用伪造广播，造成安全隐患。
相比在系统内发送全局广播，它更高效。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米&quot;&gt;&lt;a href=&quot;#3-是否使用过intentService，作用是什么，AIDL解决了什么问题？-小米&quot; class=&quot;headerlink&quot; title=&quot;3.是否使用过intentService，作用是什么，AIDL解决了什么问题？**(小米)&quot;&gt;&lt;/a&gt;3.是否使用过intentService，作用是什么，AIDL解决了什么问题？**(小米)&lt;/h3&gt;&lt;p&gt;生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intent。&lt;/p&gt;
&lt;p&gt;生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。&lt;/p&gt;
&lt;p&gt;该服务提供了一个onBind()方法的默认实现，它返回null&lt;/p&gt;
&lt;p&gt;提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。&lt;/p&gt;
&lt;p&gt;AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。&lt;br&gt;AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。&lt;/p&gt;
&lt;h3 id=&quot;4-Activity、Window、View三者的差别，fragment的特点？-（360）&quot;&gt;&lt;a href=&quot;#4-Activity、Window、View三者的差别，fragment的特点？-（360）&quot; class=&quot;headerlink&quot; title=&quot;4.Activity、Window、View三者的差别，fragment的特点？**（360）&quot;&gt;&lt;/a&gt;4.Activity、Window、View三者的差别，fragment的特点？**（360）&lt;/h3&gt;&lt;p&gt;Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）&lt;br&gt;LayoutInflater像剪刀，Xml配置像窗花图纸。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  在Activity中调用attach，创建了一个Window
2.  创建的window是其子类PhoneWindow，在attach中创建PhoneWindow
3.  在Activity中调用setContentView(R.layout.xxx)
4.  其中实际上是调用的getWindow().setContentView()
5.  调用PhoneWindow中的setContentView方法
6.  创建ParentView： 作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）
7.  将指定的R.layout.xxx进行填充 ,通过布局填充器进行填充【其中的parent指的就是DecorView】
8.  调用到ViewGroup
9.  调用ViewGroup的removeAllView()，先将所有的view移除掉
10. 添加新的view：addView()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fragment 特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fragment可以作为Activity界面的一部分组成出现；&lt;/li&gt;
&lt;li&gt;可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用；&lt;/li&gt;
&lt;li&gt;在Activity运行过程中，可以添加、移除或者替换Fragment；&lt;/li&gt;
&lt;li&gt;Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5-描述一次网络请求的流程-（新浪）&quot;&gt;&lt;a href=&quot;#5-描述一次网络请求的流程-（新浪）&quot; class=&quot;headerlink&quot; title=&quot;5.描述一次网络请求的流程**（新浪）&quot;&gt;&lt;/a&gt;5.描述一次网络请求的流程**（新浪）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/http.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-Handler、Thread和HandlerThread的差别-（小米）&quot;&gt;&lt;a href=&quot;#6-Handler、Thread和HandlerThread的差别-（小米）&quot; class=&quot;headerlink&quot; title=&quot;6.Handler、Thread和HandlerThread的差别**（小米）&quot;&gt;&lt;/a&gt;6.Handler、Thread和HandlerThread的差别**（小米）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/9991569&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/guolin_blog/article/details/9991569&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从Android中Thread（java.lang.Thread -&amp;gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&amp;gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。&lt;/p&gt;
&lt;p&gt;android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也就是HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。&lt;/p&gt;
&lt;h3 id=&quot;7-低版本SDK实现高版本api-（小米）&quot;&gt;&lt;a href=&quot;#7-低版本SDK实现高版本api-（小米）&quot; class=&quot;headerlink&quot; title=&quot;7.低版本SDK实现高版本api**（小米）&quot;&gt;&lt;/a&gt;7.低版本SDK实现高版本api**（小米）&lt;/h3&gt;&lt;p&gt;自己实现或@TargetApi annotation&lt;/p&gt;
&lt;h3 id=&quot;8-Ubuntu编译安卓系统-（百度）&quot;&gt;&lt;a href=&quot;#8-Ubuntu编译安卓系统-（百度）&quot; class=&quot;headerlink&quot; title=&quot;8.Ubuntu编译安卓系统**（百度）&quot;&gt;&lt;/a&gt;8.Ubuntu编译安卓系统**（百度）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 进入源码根目录
2. . build/envsetup.sh
3. lunch
4. full(编译全部)
5. userdebug(选择编译版本)
6. make -j8(开启8个线程编译)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;9-launch-mode应用场景-（百度、小米、乐视）&quot;&gt;&lt;a href=&quot;#9-launch-mode应用场景-（百度、小米、乐视）&quot; class=&quot;headerlink&quot; title=&quot;9.launch mode应用场景**（百度、小米、乐视）&quot;&gt;&lt;/a&gt;9.launch mode应用场景**（百度、小米、乐视）&lt;/h3&gt;&lt;p&gt;standard，创建一个新的Activity。&lt;/p&gt;
&lt;p&gt;singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。&lt;/p&gt;
&lt;p&gt;singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。&lt;/p&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。&lt;/li&gt;
&lt;li&gt;如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。&lt;/li&gt;
&lt;li&gt;在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;singleInstance，回退栈中，只有这一个Activity，没有其他Activity。&lt;/p&gt;
&lt;p&gt;singleTop适合接收通知启动的内容显示页面。&lt;/p&gt;
&lt;p&gt;例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。&lt;/p&gt;
&lt;p&gt;singleTask适合作为程序入口点。&lt;/p&gt;
&lt;p&gt;例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。&lt;/p&gt;
&lt;p&gt;singleInstance应用场景：&lt;/p&gt;
&lt;p&gt;闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。&lt;/p&gt;
&lt;h3 id=&quot;10-touch-事件传递流程-（小米）&quot;&gt;&lt;a href=&quot;#10-touch-事件传递流程-（小米）&quot; class=&quot;headerlink&quot; title=&quot;10.touch 事件传递流程**（小米）&quot;&gt;&lt;/a&gt;10.touch 事件传递流程**（小米）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;11-view绘制流程-（百度）&quot;&gt;&lt;a href=&quot;#11-view绘制流程-（百度）&quot; class=&quot;headerlink&quot; title=&quot;11.view绘制流程**（百度）&quot;&gt;&lt;/a&gt;11.view绘制流程**（百度）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-多线程-（360）&quot;&gt;&lt;a href=&quot;#12-多线程-（360）&quot; class=&quot;headerlink&quot; title=&quot;12.多线程**（360）&quot;&gt;&lt;/a&gt;12.多线程**（360）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Activity.runOnUiThread(Runnable)&lt;/li&gt;
&lt;li&gt;View.post(Runnable),View.postDelay(Runnable,long)&lt;/li&gt;
&lt;li&gt;Handler&lt;/li&gt;
&lt;li&gt;AsyncTask&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;13.线程同步&lt;/strong&gt;（百度）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.juwends.com/tech/android/android-inter-thread-comm.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细介绍2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Singleton{    
private volatile static Singleton mSingleton;
private Singleton(){
}

public static Singleton getInstance(){
    if(mSingleton == null){\\A
        synchronized(Singleton.class){\\C
         if(mSingleton == null)
              mSingleton = new Singleton();\\B
          }
    }
    return mSingleton;
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;14-什么情况导致内存泄漏-（美团）&quot;&gt;&lt;a href=&quot;#14-什么情况导致内存泄漏-（美团）&quot; class=&quot;headerlink&quot; title=&quot;14.什么情况导致内存泄漏**（美团）&quot;&gt;&lt;/a&gt;14.什么情况导致内存泄漏**（美团）&lt;/h3&gt;&lt;p&gt;1.资源对象没关闭造成的内存泄漏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;描述：
资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。
程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.构造Adapter时，没有使用缓存的convertView&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;描述：
以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：
public View getView(int position, ViewconvertView, ViewGroup parent)
来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据    当前的屏幕布局实例化一定数量的     view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ListView回收list item的view对象的过程可以查看:&lt;br&gt;android.widget.AbsListView.java –&amp;gt; voidaddScrapView(View scrap) 方法。&lt;br&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public View getView(int position, ViewconvertView, ViewGroup parent) {
    View view = new Xxx(...); 
    ... ... 
    return view; 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修正示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public View getView(int position, ViewconvertView, ViewGroup parent) {
    View view = null; 
    if (convertView != null) { 
    view = convertView; 
    populate(view, getItem(position)); 
    ... 
    } else { 
        view = new Xxx(...); 
        ... 
    } 
    return view; 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.Bitmap对象不在使用时调用recycle()释放内存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;描述：
有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：

/** 
•Free up the memory associated with thisbitmap&amp;apos;s pixels, and mark the 
•bitmap as &amp;quot;dead&amp;quot;, meaning itwill throw an exception if getPixels() or 
•setPixels() is called, and will drawnothing. This operation cannot be 
•reversed, so it should only be called ifyou are sure there are no 
•further uses for the bitmap. This is anadvanced call, and normally need 
•not be called, since the normal GCprocess will free up this memory when 
•there are no more references to thisbitmap. 
*/ 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.试着使用关于application的context来替代和activity相关的context&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Android内存泄漏。&lt;/p&gt;
&lt;p&gt;5.注册没取消造成的内存泄漏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。
比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。
但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。
虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.集合中对象没清理造成的内存泄漏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;15-ANR定位和修正&quot;&gt;&lt;a href=&quot;#15-ANR定位和修正&quot; class=&quot;headerlink&quot; title=&quot;15.ANR定位和修正**&quot;&gt;&lt;/a&gt;15.ANR定位和修正**&lt;/h3&gt;&lt;p&gt;如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。&lt;/li&gt;
&lt;li&gt;主线程中存在耗时的计算&lt;/li&gt;
&lt;li&gt;主线程中错误的操作，比如Thread.wait或者Thread.sleep等&lt;br&gt;Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框&lt;/li&gt;
&lt;li&gt;应用在5秒内未响应用户的输入事件（如按键或者触摸）&lt;/li&gt;
&lt;li&gt;BroadcastReceiver未在10秒内完成相关的处理&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Service在特定的时间内无法处理完成 20秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用AsyncTask处理耗时IO操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。&lt;/li&gt;
&lt;li&gt;使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。&lt;/li&gt;
&lt;li&gt;Activity的onCreate和onResume回调中尽量避免耗时的代码&lt;/li&gt;
&lt;li&gt;BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;16-什么情况导致oom-（乐视、美团）&quot;&gt;&lt;a href=&quot;#16-什么情况导致oom-（乐视、美团）&quot; class=&quot;headerlink&quot; title=&quot;16.什么情况导致oom**（乐视、美团）&quot;&gt;&lt;/a&gt;16.什么情况导致oom**（乐视、美团）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）使用更加轻量的数据结构
2）Android里面使用Enum
3）Bitmap对象的内存占用
4）更大的图片
5）onDraw方法里面执行对象的创建
6）StringBuilder
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;17-Android-Service与Activity之间通信的几种方式&quot;&gt;&lt;a href=&quot;#17-Android-Service与Activity之间通信的几种方式&quot; class=&quot;headerlink&quot; title=&quot;17.Android Service与Activity之间通信的几种方式**&quot;&gt;&lt;/a&gt;17.Android Service与Activity之间通信的几种方式**&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通过Binder对象&lt;/li&gt;
&lt;li&gt;通过broadcast(广播)的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;18-Android各个版本API的区别&quot;&gt;&lt;a href=&quot;#18-Android各个版本API的区别&quot; class=&quot;headerlink&quot; title=&quot;18.Android各个版本API的区别**&quot;&gt;&lt;/a&gt;18.Android各个版本API的区别**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lijun952048910/article/details/7980562&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;19-Android代码中实现WAP方式联网-（360）&quot;&gt;&lt;a href=&quot;#19-Android代码中实现WAP方式联网-（360）&quot; class=&quot;headerlink&quot; title=&quot;19. Android代码中实现WAP方式联网**（360）&quot;&gt;&lt;/a&gt;19. Android代码中实现WAP方式联网**（360）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/asce1885/article/details/7844159&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;方法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;20-如何保证service在后台不被kill&quot;&gt;&lt;a href=&quot;#20-如何保证service在后台不被kill&quot; class=&quot;headerlink&quot; title=&quot;20.如何保证service在后台不被kill**&quot;&gt;&lt;/a&gt;20.如何保证service在后台不被kill**&lt;/h3&gt;&lt;p&gt;一、onStartCommand方法，返回START_STICKY&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;START_STICKY&lt;br&gt;在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;START_NOT_STICKY&lt;br&gt;在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;START_REDELIVER_INTENT&lt;br&gt;在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、提升service优先级&lt;/p&gt;
&lt;p&gt;在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。&lt;/p&gt;
&lt;p&gt;三、提升service进程优先级&lt;/p&gt;
&lt;p&gt;Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前台进程( FOREGROUND_APP)&lt;/li&gt;
&lt;li&gt;可视进程(VISIBLE_APP )&lt;/li&gt;
&lt;li&gt;次要服务进程(SECONDARY_SERVER )&lt;/li&gt;
&lt;li&gt;后台进程 (HIDDEN_APP)&lt;/li&gt;
&lt;li&gt;内容供应节点(CONTENT_PROVIDER)&lt;/li&gt;
&lt;li&gt;空进程(EMPTY_APP)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。&lt;/p&gt;
&lt;p&gt;四、onDestroy方法里重启service&lt;/p&gt;
&lt;p&gt;service +broadcast  方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；&lt;/p&gt;
&lt;p&gt;五、Application加上Persistent属性&lt;/p&gt;
&lt;p&gt;六、监听系统广播判断Service状态&lt;/p&gt;
&lt;p&gt;通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。&lt;/p&gt;
&lt;h3 id=&quot;21-Requestlayout，onlayout，onDraw，DrawChild区别与联系-（猎豹）&quot;&gt;&lt;a href=&quot;#21-Requestlayout，onlayout，onDraw，DrawChild区别与联系-（猎豹）&quot; class=&quot;headerlink&quot; title=&quot;21.Requestlayout，onlayout，onDraw，DrawChild区别与联系**（猎豹）&quot;&gt;&lt;/a&gt;21.Requestlayout，onlayout，onDraw，DrawChild区别与联系**（猎豹）&lt;/h3&gt;&lt;p&gt;requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。&lt;br&gt;说明：只是对View树重新布局layout过程包括measure()和layout()过程，不会调用draw()过程，但不会重新绘制&lt;br&gt;任何视图包括该调用者本身。&lt;/p&gt;
&lt;p&gt;onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局)&lt;/p&gt;
&lt;p&gt;调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)&lt;/p&gt;
&lt;p&gt;drawChild()去重新回调每个子视图的draw()方法&lt;/p&gt;
&lt;h3 id=&quot;22-invalidate-和postInvalidate-的区别及使用-（百度）&quot;&gt;&lt;a href=&quot;#22-invalidate-和postInvalidate-的区别及使用-（百度）&quot; class=&quot;headerlink&quot; title=&quot;22.invalidate()和postInvalidate() 的区别及使用**（百度）&quot;&gt;&lt;/a&gt;22.invalidate()和postInvalidate() 的区别及使用**（百度）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/mars2639/article/details/6650876&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用与区别&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-Android动画框架实现原理&quot;&gt;&lt;a href=&quot;#23-Android动画框架实现原理&quot; class=&quot;headerlink&quot; title=&quot;23.Android动画框架实现原理**&quot;&gt;&lt;/a&gt;23.Android动画框架实现原理**&lt;/h3&gt;&lt;p&gt;Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。&lt;/p&gt;
&lt;h3 id=&quot;24-Android为每个应用程序分配的内存大小是多少？-（美团）&quot;&gt;&lt;a href=&quot;#24-Android为每个应用程序分配的内存大小是多少？-（美团）&quot; class=&quot;headerlink&quot; title=&quot;24.Android为每个应用程序分配的内存大小是多少？**（美团）&quot;&gt;&lt;/a&gt;24.Android为每个应用程序分配的内存大小是多少？**（美团）&lt;/h3&gt;&lt;p&gt;android程序内存一般限制在16M，也有的是24M&lt;/p&gt;
&lt;h3 id=&quot;25-Android-View刷新机制-（百度、美团）&quot;&gt;&lt;a href=&quot;#25-Android-View刷新机制-（百度、美团）&quot; class=&quot;headerlink&quot; title=&quot;25.Android View刷新机制**（百度、美团）&quot;&gt;&lt;/a&gt;25.Android View刷新机制**（百度、美团）&lt;/h3&gt;&lt;p&gt;由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。&lt;/p&gt;
&lt;p&gt;调用流程 ：&lt;/p&gt;
&lt;p&gt;mView.draw()开始绘制，draw()方法实现的功能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绘制该View的背景&lt;/li&gt;
&lt;li&gt;为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)          &lt;/li&gt;
&lt;li&gt;调用onDraw()方法绘制视图本身   (每个View都需要重载该方法，ViewGroup不需要实现该方法)&lt;/li&gt;
&lt;li&gt;调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;26-LinearLayout对比RelativeLayout-（百度）&quot;&gt;&lt;a href=&quot;#26-LinearLayout对比RelativeLayout-（百度）&quot; class=&quot;headerlink&quot; title=&quot;26.LinearLayout对比RelativeLayout**（百度）&quot;&gt;&lt;/a&gt;26.LinearLayout对比RelativeLayout**（百度）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure&lt;/li&gt;
&lt;li&gt;RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。&lt;/li&gt;
&lt;li&gt;在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。&lt;/p&gt;
&lt;h3 id=&quot;27-优化自定义view-（百度、乐视、小米）&quot;&gt;&lt;a href=&quot;#27-优化自定义view-（百度、乐视、小米）&quot; class=&quot;headerlink&quot; title=&quot;27.优化自定义view**（百度、乐视、小米）&quot;&gt;&lt;/a&gt;27.优化自定义view**（百度、乐视、小米）&lt;/h3&gt;&lt;p&gt;为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。&lt;/p&gt;
&lt;p&gt;你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。&lt;/p&gt;
&lt;p&gt;另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。&lt;/p&gt;
&lt;p&gt;如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。&lt;/p&gt;
&lt;h3 id=&quot;28-ContentProvider-（乐视）&quot;&gt;&lt;a href=&quot;#28-ContentProvider-（乐视）&quot; class=&quot;headerlink&quot; title=&quot;28.ContentProvider**（乐视）&quot;&gt;&lt;/a&gt;28.ContentProvider**（乐视）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/coder_pig/article/details/47858489&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;29-fragment生命周期&quot;&gt;&lt;a href=&quot;#29-fragment生命周期&quot; class=&quot;headerlink&quot; title=&quot;29.fragment生命周期**&quot;&gt;&lt;/a&gt;29.fragment生命周期**&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/JackyAndroid/AndroidInterview-Q-A/raw/master/picture/fragment-life.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;30-volley解析-（美团、乐视）&quot;&gt;&lt;a href=&quot;#30-volley解析-（美团、乐视）&quot; class=&quot;headerlink&quot; title=&quot;30.volley解析**（美团、乐视）&quot;&gt;&lt;/a&gt;30.volley解析**（美团、乐视）&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volley源码解析&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;31-Android-Glide源码解析&quot;&gt;&lt;a href=&quot;#31-Android-Glide源码解析&quot; class=&quot;headerlink&quot; title=&quot;31.Android Glide源码解析**&quot;&gt;&lt;/a&gt;31.Android Glide源码解析**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.lightskystreet.com/2015/10/12/glide_source_analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Glide源码解析1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://frodoking.github.io/2015/10/10/android-glide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Glide源码解析2&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-Android-设计模式&quot;&gt;&lt;a href=&quot;#32-Android-设计模式&quot; class=&quot;headerlink&quot; title=&quot;32.Android 设计模式**&quot;&gt;&lt;/a&gt;32.Android 设计模式**&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bboyfeiyu/article/details/44563871&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;设计模式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-架构设计-（搜狐）&quot;&gt;&lt;a href=&quot;#33-架构设计-（搜狐）&quot; class=&quot;headerlink&quot; title=&quot;33.架构设计**（搜狐）&quot;&gt;&lt;/a&gt;33.架构设计**（搜狐）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JackyAndroid/AndroidInterview-Q-A/master/picture/architucture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tianmaying.com/tutorial/AndroidMVC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;架构设计&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;34-Android属性动画特性-（乐视、小米）&quot;&gt;&lt;a href=&quot;#34-Android属性动画特性-（乐视、小米）&quot; class=&quot;headerlink&quot; title=&quot;34.Android属性动画特性**（乐视、小米）&quot;&gt;&lt;/a&gt;34.Android属性动画特性**（乐视、小米）&lt;/h3&gt;&lt;p&gt;如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。&lt;/p&gt;
&lt;p&gt;注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。&lt;/p&gt;
&lt;p&gt;然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。&lt;/p&gt;
&lt;p&gt;最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;国内一线互联网公司内部面试题库&quot;&gt;&lt;a href=&quot;#国内一线互联网公司内部面试题库&quot; class=&quot;headerlink&quot; title=&quot;国内一线互联网公司内部面试题库&quot;&gt;&lt;/a&gt;国内一线互联网公司内部面试题库&lt;/h1&gt;&lt;p&gt;摘自大神博客，基于面试，个人觉得整理的还是很全面的，大公司看重的技术能力，那一定是在应对项目时常常遇到的技术，能掌握这些，一是让自己的技术水准能更上一层楼，二，是个人观点，男人总得上进，进入大公司，体验500强公司的文化，对做人处世都大有裨益。&lt;/p&gt;
&lt;p&gt;So just try it and try it!&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列之代码开发规范</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之代码开发规范/</id>
    <published>2016-08-13T08:27:45.000Z</published>
    <updated>2016-08-14T05:55:39.475Z</updated>
    
    <content type="html">&lt;p&gt;在开发中，主动权在己之手，因此有些规范实则是人为的一些硬性约束或者说习惯风格，但如若迥异之处过多，不仅影响开发速度，造成团队开发进展迟滞不前，而且对我们程序猿来说，编程素养也未能得到提高，境界上不去，总不能码一辈子吧，所以能有一套主流的开发规范常印脑海，以求不变应万变，才是上上之策。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一些约定&quot;&gt;&lt;a href=&quot;#一些约定&quot; class=&quot;headerlink&quot; title=&quot;一些约定&quot;&gt;&lt;/a&gt;一些约定&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类中public方法在前，private在后，所有不对外的方法，变量全部使用private修饰符。类中public static final的常量在最上方，其次private static final，然后public，private等。&lt;/li&gt;
&lt;li&gt;类中定义的接口放在变量声明之后，所有方法之前。&lt;/li&gt;
&lt;li&gt;方法相关性，方法之间有调用关系的，按照先后顺序排列在一起。&lt;/li&gt;
&lt;li&gt;善用空行，方法体之间必须空行，代码逻辑块之间使用空行分隔，变量声明根据变量类型适当空行。&lt;/li&gt;
&lt;li&gt;方法体不要过长，尽量提取小方法代替逻辑块，保证代码可读性。&lt;/li&gt;
&lt;li&gt;善用TODO，对于未完成或已完成但是方案不完美需后续跟踪的，使用TODO标签标示，并写好注释。&lt;/li&gt;
&lt;li&gt;不建议注释太多，要通过方法名，变量名提高代码可读性，而非注释。但是一些非常规方法，复杂逻辑，需要详细注释说明。&lt;/li&gt;
&lt;li&gt;协作中，不要做整个代码的格式化，仅格式化自己编写的那部分。&lt;/li&gt;
&lt;li&gt;注意命名以及注释英文单词，不要写错~&lt;/li&gt;
&lt;li&gt;杜绝“Magic Number”, 所有数值根据情况提取为常量，dimen或constant。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用Android Studio提供的格式化规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h3&gt;&lt;h4 id=&quot;1-Java命名&quot;&gt;&lt;a href=&quot;#1-Java命名&quot; class=&quot;headerlink&quot; title=&quot;1. Java命名&quot;&gt;&lt;/a&gt;1. Java命名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;分类          命名方式                 举例                     说明

包名          全小写                  com.cicaero.kite         公司域名倒序，“.”分隔，单个包名建议不超过12个字母

类名          首字母大写的驼峰         UserInfo                 名词形式

接口名        首字母大写的驼峰         ServerInterface          名字形式

方法名        驼峰                    getUserInfo              动词结构，含义为一个动作

常量          全大写，单词下划线分隔    MSG_UPDATE_PROGRESS      建议数值类常量从1开始，且根据功能预留数段

成员变量       m/s/is/has开头的驼峰    mImageUrl                正常成员m开头，静态s开头，布尔型is/has开头

局部变量       首字母小写的驼峰        currentPosition           名词形式，除非是循环，否则不建议使用i，j，k等简单变量名
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-资源命名&quot;&gt;&lt;a href=&quot;#2-资源命名&quot; class=&quot;headerlink&quot; title=&quot;2. 资源命名&quot;&gt;&lt;/a&gt;2. 资源命名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;分类          命名方式                  举例                    说明

布局          全小写，单词下划线分隔     activity_main.xml       Activity以activity开头，Fragment以fragment开头，
                                                               List、Grid项以item开头，Dialog布局以dialog开头，
                                                               自定义View以layout开头，其他被include的或公用组件，
                                                               诸如title_bar,bottom_bar,根据实际含义命名

Drawable      全小写，单词下划线分隔     btn_bg.png              根据图片使用方式命名， 图标以ic_开头，背景以_bg结尾，
                                                               状态drawable xml以_selector结尾。

Color         全小写，单词下划线分隔     green                   尽量根据颜色值命名

String        全小写，单词下划线分隔     app_name                模块多且大的话，根据模块建立不同的String xml 文件

style         首字母大写的驼峰          NoTitleTheme            类似类名，style本身也是有类似类的集成关系

dimension     全小写，单词下划线分隔     left_padding     

id            全小写，单词下划线分隔     user_name_tv            详细id命名规范参考以下章节
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;3-布局文件中的View-id命名&quot;&gt;&lt;a href=&quot;#3-布局文件中的View-id命名&quot; class=&quot;headerlink&quot; title=&quot;3. 布局文件中的View id命名&quot;&gt;&lt;/a&gt;3. 布局文件中的View id命名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;View              结尾命名规则

TextView          tv
Button            btn
EditText          et
ImageView         iv
ImageButton       img_btn
RadioButton       rb
RadioGroup        rg
SeekBar           seek
ProgressBar       progress
Spinner           spinner
VideoView         vv
CheckBox          cb
ListView          lv
GridView          grid
Layout            lt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;其他规范&quot;&gt;&lt;a href=&quot;#其他规范&quot; class=&quot;headerlink&quot; title=&quot;其他规范&quot;&gt;&lt;/a&gt;其他规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Gradle引入第三方库时comment加上库地址。&lt;/li&gt;
&lt;li&gt;编译相关的常量写入编译脚本。&lt;/li&gt;
&lt;/ul&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，主动权在己之手，因此有些规范实则是人为的一些硬性约束或者说习惯风格，但如若迥异之处过多，不仅影响开发速度，造成团队开发进展迟滞不前，而且对我们程序猿来说，编程素养也未能得到提高，境界上不去，总不能码一辈子吧，所以能有一套主流的开发规范常印脑海，以求不变应万变，才是上上之策。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列一年一总结</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E5%B9%B4%E4%B8%80%E6%80%BB%E7%BB%93/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之一年一总结/</id>
    <published>2016-08-13T08:27:12.000Z</published>
    <updated>2016-08-13T13:14:34.973Z</updated>
    
    <content type="html">&lt;h1 id=&quot;学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot;&gt;&lt;a href=&quot;#学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot; class=&quot;headerlink&quot; title=&quot;学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot;&gt;&lt;/a&gt;学习Android，突破自己，一年一总结，我是要当CTO的男人。&lt;/h1&gt;&lt;h1 id=&quot;无论怎样-这可能是我人生中搭建的最搓的一次架构&quot;&gt;&lt;a href=&quot;#无论怎样-这可能是我人生中搭建的最搓的一次架构&quot; class=&quot;headerlink&quot; title=&quot;无论怎样 这可能是我人生中搭建的最搓的一次架构&quot;&gt;&lt;/a&gt;无论怎样 这可能是我人生中搭建的最搓的一次架构&lt;/h1&gt;&lt;p&gt;煎熬了一个月，项目总算吭哧吭哧的完成，从最初的技术选型，到框架搭建，再到着手开发app，是一次尝试，也让自己越来越坚定的想在Android之路走下去，像这么有意思的事，不做个纪念写点东西是不行的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;开发前就已做好面对各种坑的准备，只是没想到，坑一个个来的都那么的理所当然，甚至理直气壮，关于这些必须针对模块一一列举，本系列文章目前按如下顺序写，这也是我项目开发从零到一的一个思路，可能在以后随着经验值增长，会做的更细致一些。那就开始吧，首先&lt;/p&gt;
&lt;h3 id=&quot;技术选型&quot;&gt;&lt;a href=&quot;#技术选型&quot; class=&quot;headerlink&quot; title=&quot;技术选型&quot;&gt;&lt;/a&gt;技术选型&lt;/h3&gt;&lt;p&gt;之所以把这列为第一项，很大程度上源于我对之前公司开发框架囿于桎梏所做出的一些改变吧，我很难想象再去开发一个app依旧停留在过去的思维之上，所以这次开发之前，就立过决心，这里罗列出当时的想法，一些还没付诸。&lt;br&gt;RxJava/RxAndroid + OkHttp + Retrofit ( + Dagger2 )&lt;br&gt;Dagger2还没有加入项目中，在下一版迭代前加入&lt;br&gt;后来开发中发现MVP模式开发很能解决Activity业务代码繁重的问题，解耦相当好，反正记住一个真理就行：所有牛逼的框架，那一定是解耦和相当出色的。要不然怎么可能你能用他也能用，当然性能也是衡量一个框架的好坏。反正Square公司出品，必属精品。有Github的朋友，快去star&lt;/p&gt;
&lt;h3 id=&quot;框架搭建&quot;&gt;&lt;a href=&quot;#框架搭建&quot; class=&quot;headerlink&quot; title=&quot;框架搭建&quot;&gt;&lt;/a&gt;框架搭建&lt;/h3&gt;&lt;p&gt;开发IDE: Android Studio&lt;/p&gt;
&lt;h4 id=&quot;主app-Android-Lib-Java-Lib&quot;&gt;&lt;a href=&quot;#主app-Android-Lib-Java-Lib&quot; class=&quot;headerlink&quot; title=&quot;主app + Android Lib + Java Lib&quot;&gt;&lt;/a&gt;主app + Android Lib + Java Lib&lt;/h4&gt;&lt;p&gt;（1）主app&lt;/p&gt;
&lt;p&gt;（2）Android lib&lt;/p&gt;
&lt;p&gt;（3）Java lib&lt;/p&gt;
&lt;h4 id=&quot;基类封装&quot;&gt;&lt;a href=&quot;#基类封装&quot; class=&quot;headerlink&quot; title=&quot;基类封装&quot;&gt;&lt;/a&gt;基类封装&lt;/h4&gt;&lt;h4 id=&quot;UI-开发&quot;&gt;&lt;a href=&quot;#UI-开发&quot; class=&quot;headerlink&quot; title=&quot;UI  开发&quot;&gt;&lt;/a&gt;UI  开发&lt;/h4&gt;&lt;h4 id=&quot;业务编写&quot;&gt;&lt;a href=&quot;#业务编写&quot; class=&quot;headerlink&quot; title=&quot;业务编写&quot;&gt;&lt;/a&gt;业务编写&lt;/h4&gt;&lt;h4 id=&quot;渠道发包（混淆，签名，加固，上线）&quot;&gt;&lt;a href=&quot;#渠道发包（混淆，签名，加固，上线）&quot; class=&quot;headerlink&quot; title=&quot;渠道发包（混淆，签名，加固，上线）&quot;&gt;&lt;/a&gt;渠道发包（混淆，签名，加固，上线）&lt;/h4&gt;&lt;h4 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h4&gt;&lt;h4 id=&quot;工具辅助&quot;&gt;&lt;a href=&quot;#工具辅助&quot; class=&quot;headerlink&quot; title=&quot;工具辅助&quot;&gt;&lt;/a&gt;工具辅助&lt;/h4&gt;&lt;h4 id=&quot;基础总结篇&quot;&gt;&lt;a href=&quot;#基础总结篇&quot; class=&quot;headerlink&quot; title=&quot;基础总结篇&quot;&gt;&lt;/a&gt;基础总结篇&lt;/h4&gt;&lt;h2 id=&quot;Android公共技术：&quot;&gt;&lt;a href=&quot;#Android公共技术：&quot; class=&quot;headerlink&quot; title=&quot;Android公共技术：&quot;&gt;&lt;/a&gt;Android公共技术：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Android%20%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公共技术点之 Android 动画基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公共技术点之 Java 动态代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公共技术点之依赖注入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公共技术点之 View 事件传递&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公共技术点之 View 绘制流程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-Android的Framework和Android-apk的打包过程&quot;&gt;&lt;a href=&quot;#1-Android的Framework和Android-apk的打包过程&quot; class=&quot;headerlink&quot; title=&quot;1.Android的Framework和Android apk的打包过程&quot;&gt;&lt;/a&gt;1.Android的Framework和Android apk的打包过程&lt;/h3&gt;&lt;p&gt;底层的Binder驱动，IPC的核心，SGL 2D绘图，OpenGL 3D绘图&lt;/p&gt;
&lt;h3 id=&quot;2-多线程&quot;&gt;&lt;a href=&quot;#2-多线程&quot; class=&quot;headerlink&quot; title=&quot;2.多线程&quot;&gt;&lt;/a&gt;2.多线程&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/goodlixueyong/article/details/45895997&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AsyncTask的缺陷和问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于线程池：asynctask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是asynctask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0后默认串行执行，不会出现这个问题)。针对这种情况，可以尝试自定义线程池，配合asynctask使用。&lt;/p&gt;
&lt;p&gt;关于默认线程池：核心线程池中最多有CPU_COUNT+1个，最多有CPU_COUNT*2+1个，线程等待队列的最大等待数为128，但是可以自定义线程池。线程池是由AsyncTask来管理的，线程池允许tasks并行运行，xuyao注意的是并发情况下数据的一致性问题，新数据可能会被老数据覆盖掉，类似volatile变量。所以希望tasks能够串行运行的话，使用SERIAL_EXECUTOR。&lt;/p&gt;
&lt;p&gt;自定义线程池：executeOnExecutor(Executor exec,Params… params) 自定义Executor&lt;/p&gt;
&lt;p&gt;execute(Params… params){return executeOnExecutor(sDefaultExecutor,params);}&lt;/p&gt;
&lt;p&gt;AsyncTask在不同的SDK版本中的区别：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过查阅官方文档发现，AsyncTask首次引入时，异步任务是在一个独立的线程中顺序的执行，也就是说一次只能执行一个任务，不能并行的执行，从1.6开始，AsyncTask引入了线程池，支持同时执行5个异步任务，也就是说同时只能有5个线程运行，超过的线程只能等待，等待前面的线程某个执行完了才被调度和运行。换句话说，如果一个进程中的AsyncTask实例个数超过5个，那么假如前5个都运行很长时间的话，那么第6个只能等待机会了。这是AsyncTask的一个限制，而且对于2.3以前的版本无法解决。如果你的应用需要大量的后台线程去执行任务，那么你只能放弃使用AsyncTask，自己创建线程池来管理Thread，或者干脆不用线程池直接使用Thread也无妨。不得不说，虽然AsyncTask较Thread使用起来方便，但是它最多只能同时运行5个线程，这也大大局限了它的实力，你必须要小心设计你的应用，错开使用AsyncTask的时间，尽力做到分时，或者保证数量不会大于5个，否则就会遇到上次提到的问题。可能是Google意识到了AsyncTask的局限性了，从Android3.0开始对AsyncTask的API作出了一些调整：每次只启动一个线程执行一个任务，完成之后再执行第二个任务，也就是相当于只有一个后台线程在执行所提交的任务。&lt;/p&gt;
&lt;h5 id=&quot;1、生命周期&quot;&gt;&lt;a href=&quot;#1、生命周期&quot; class=&quot;headerlink&quot; title=&quot;1、生命周期&quot;&gt;&lt;/a&gt;1、生命周期&lt;/h5&gt;&lt;p&gt;很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsyncTask会一直执行，直到doInBackground()方法执行完毕。然后，如果cancel(boolean)被调用,那么onCancelled(Result result)方法会被执行；否则，执行onPostExecute(Result result)方法。如果我们的Activity销毁之前，没有取消AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确的取消。&lt;/p&gt;
&lt;h5 id=&quot;2、内存泄漏&quot;&gt;&lt;a href=&quot;#2、内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;2、内存泄漏&quot;&gt;&lt;/a&gt;2、内存泄漏&lt;/h5&gt;&lt;p&gt;如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄漏。&lt;/p&gt;
&lt;h5 id=&quot;3、结果丢失&quot;&gt;&lt;a href=&quot;#3、结果丢失&quot; class=&quot;headerlink&quot; title=&quot;3、结果丢失&quot;&gt;&lt;/a&gt;3、结果丢失&lt;/h5&gt;&lt;p&gt;屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。&lt;/p&gt;
&lt;h5 id=&quot;4、并行还是串行&quot;&gt;&lt;a href=&quot;#4、并行还是串行&quot; class=&quot;headerlink&quot; title=&quot;4、并行还是串行&quot;&gt;&lt;/a&gt;4、并行还是串行&lt;/h5&gt;&lt;p&gt;在Android1.6之前的版本，AsyncTask是串行的，在1.6至2.3的版本，改成了并行的。在2.3之后的版本又做了 修改，可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要执行executeOnExecutor(Executor)。&lt;/p&gt;
&lt;h3 id=&quot;3-Android机制&quot;&gt;&lt;a href=&quot;#3-Android机制&quot; class=&quot;headerlink&quot; title=&quot;3.Android机制&quot;&gt;&lt;/a&gt;3.Android机制&lt;/h3&gt;&lt;h5 id=&quot;1-Linux-Sandbox-沙箱机制：&quot;&gt;&lt;a href=&quot;#1-Linux-Sandbox-沙箱机制：&quot; class=&quot;headerlink&quot; title=&quot;(1)Linux Sandbox 沙箱机制：&quot;&gt;&lt;/a&gt;(1)Linux Sandbox 沙箱机制：&lt;/h5&gt;&lt;p&gt;Android将数据分为system和data两个区。其中system是只读的，dada用来存放应用自己的数据，这保证了系统数据不会被随意改写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;应用之间的数据相互独立，每个应用都会有一个user id和group id，只有相同的user id并且来自同一个作者，才能访问它们的数据。
作者通过对apk签名来标识自己，签名和uid构成了双重的保证。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;2-用户权限机制：&quot;&gt;&lt;a href=&quot;#2-用户权限机制：&quot; class=&quot;headerlink&quot; title=&quot;(2)用户权限机制：&quot;&gt;&lt;/a&gt;(2)用户权限机制：&lt;/h5&gt;&lt;p&gt;文件权限，UID,GID&lt;/p&gt;
&lt;h5 id=&quot;3-用户权限机制：&quot;&gt;&lt;a href=&quot;#3-用户权限机制：&quot; class=&quot;headerlink&quot; title=&quot;(3)用户权限机制：&quot;&gt;&lt;/a&gt;(3)用户权限机制：&lt;/h5&gt;&lt;p&gt;android permission机制限制应用访问特定的资源，例如照相机、网络、外部存储等api&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如何让两个app运行在同一个进程里？
    1. 两个app要用相同的private key来签名
    2. 两个app的Manifest文件中要添加一样的属性 android:sharedUserId(设置成相同的UID)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-Binder机制&quot;&gt;&lt;a href=&quot;#4-Binder机制&quot; class=&quot;headerlink&quot; title=&quot;4.Binder机制&quot;&gt;&lt;/a&gt;4.Binder机制&lt;/h3&gt;&lt;p&gt;跨进程间通信(IPC):四大组件之间通过Intent互相跳转，Android实现IPC的方式是binder机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/notice520/article/details/8135600&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android中的跨进程通信的实现（一）——远程调用过程和aidl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2012-07/66195.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的Binder机制的简要理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sunxingzhesunjinbiao/article/details/42195043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的Binder机制的简要理解二&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the Android platform, the binder is used for nearly everything that happens accross in the core plateform.&lt;/p&gt;
&lt;p&gt;最底层的是Android的ashmen（Anonymous shared memoryy）机制，它负责辅助实现内存的分配，以及跨进程间通信所需要的内存共享。AIDL(Android Interface Definition Language)对BInder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。&lt;/p&gt;
&lt;p&gt;从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户区间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动了，ServiceManager提供了辅助管理的功能，Client和Server正是在Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160329110351922&quot; alt=&quot;BINDER&quot; title=&quot;binder&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Client、Server和ServiceManager实现在用户空间中，Binder驱动程序实现在内核空间中
2. Binder驱动程序和ServiceManager在Android平台已经实现，开发者只需要在用户空间实现自己的Client和Server
3. Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信
4. Client和Server之间的进程间通信通过Binder驱动程序间接实现
5. Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务器端：一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用语接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。&lt;/p&gt;
&lt;p&gt;Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会相应的创建一个mRemote对象，该对象的类型也是也是Binder类。客户就可以借助这个mRemote对象来访问远程服务。&lt;/p&gt;
&lt;p&gt;客户端：客户想要访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。&lt;/p&gt;
&lt;p&gt;在这里，我们可以看到，客户端是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，然后相应的在Binder驱动中创建一个Binder对象，接着客户端通过获取Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind（粘连）在一起，实现通信。&lt;/p&gt;
&lt;p&gt;mmap将一个文件或者其他对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。munmap执行相反的操作，删除特定地址区域的对象映射。&lt;/p&gt;
&lt;p&gt;当使用mmap映射文件到进程后，就可以直接操作这段虚拟内存进行文件的读写等操作，不必再调用read，write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。&lt;/p&gt;
&lt;p&gt;采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保存共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。&lt;/p&gt;
&lt;p&gt;aidl主要就是帮助我们完成了包装数据和解包的过程，并调用了transact过程，而用来传递的数据包我们就称为parcel&lt;/p&gt;
&lt;p&gt;AIDL: xxx.aidl-&amp;gt;xxx.java,注册service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 用aidl定义需要被调用方法接口
2. 实现这些方法
3. 调用这些方法
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;5-NDK&quot;&gt;&lt;a href=&quot;#5-NDK&quot; class=&quot;headerlink&quot; title=&quot;5.NDK&quot;&gt;&lt;/a&gt;5.NDK&lt;/h3&gt;&lt;p&gt;Dalvik虚拟机在调用一个成员函数的时候，如果发现该成员函数是一个JNI方法，那么就会直接跳到它的地址去执行。也就是说，JNI方法是直接在本地操作系统执行的，而不是Dalvik虚拟机解释器执行。由此也可以看出，JNI方法是Android应用程序与本地操作系统直接进行通信的一个手段。&lt;/p&gt;
&lt;p&gt;JNI原理：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/8923483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dalvik虚拟机JNI方法的注册过程分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例子：当libnanosleep.so文件被加载的时候，函数JNI_OnLoad就会被调用。在函数JNI_OnLoad中，参数vm描述的是当前线程中的Dalvik虚拟机，通过调用它的成员函数GetEnv就可以获得一个JNIEnv对象。有了这个JNIEnv对象之后，我们就可以调用另外一个函数jniRegisterNativeMethods来向当前进程的Dalvik虚拟机注册一个JNI方法。&lt;/p&gt;
&lt;h3 id=&quot;6-Android系统启动过程，App启动过程&quot;&gt;&lt;a href=&quot;#6-Android系统启动过程，App启动过程&quot; class=&quot;headerlink&quot; title=&quot;6.Android系统启动过程，App启动过程&quot;&gt;&lt;/a&gt;6.Android系统启动过程，App启动过程&lt;/h3&gt;&lt;p&gt;App启动过程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/stonecao/article/details/6591847&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Activity启动过程详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从桌面点击到activity启动的过程&lt;/p&gt;
&lt;p&gt;1、Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely,进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。&lt;/p&gt;
&lt;p&gt;2、Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity。&lt;/p&gt;
&lt;p&gt;3、调用ActivityManagerService的startActivity方法，这里做了进程切换（具体过程请查看源码）。&lt;/p&gt;
&lt;p&gt;4、开启Activity，调用onCreate方法&lt;/p&gt;
&lt;h3 id=&quot;7-Activity-Fragment-Service生命周期&quot;&gt;&lt;a href=&quot;#7-Activity-Fragment-Service生命周期&quot; class=&quot;headerlink&quot; title=&quot;7.Activity,Fragment,Service生命周期&quot;&gt;&lt;/a&gt;7.Activity,Fragment,Service生命周期&lt;/h3&gt;&lt;p&gt;常见的例子：程序正运行着来电话了，这个程序咋办呢？中止了呗，如果中止的时候新出的一个Activity是全屏的onPause-&amp;gt;onStop，恢复的时候onStart-&amp;gt;onResume,如果打断这个应用程序的是一个Theme为Translucent或者Dialog的Activity那么只是onPause,恢复的时候onResume。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;onPause:恢复的时候onResume&lt;/li&gt;
&lt;li&gt;onCreate:在这里创建界面，做一些数据的初始化工作&lt;/li&gt;
&lt;li&gt;onStart:到这一步变成用户可见不可交互的&lt;/li&gt;
&lt;li&gt;onPause:到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情，应该在这里保存你的一些 数据，因为这个时候你的程序的优先级降低，有可能被 系统回收。在这里保存的数据，应该在onResume里读出来。注意：这个方法里做的事情时间要短，因为下一个Activity不会等到这个方法完成才启动。&lt;/li&gt;
&lt;li&gt;onStop:变得不可见，被下一个Activity覆盖了(onPause和onStop的区别是否可见)&lt;/li&gt;
&lt;li&gt;onDestroy:这是Activity被干掉前最后一个被调用方法了，可能是外面类调用finish方法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有一个ProgressDialog在线程中转动，请在onDestroy里把它cancel掉，不然等线程结束的时候，调用Dialog的cancel会抛出异常的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;onPause,onstop,onDestroy，三种状态下，Activity都有可能被系统干掉。&lt;/p&gt;
&lt;p&gt;启动另一个Activity然后finish，先调用旧Activity的onPause方法，然后调用新的Activity和onCreate-&amp;gt;onStart-&amp;gt;onResume方法，然后调用旧Activity的onStop-&amp;gt;onDestroy方法。&lt;/p&gt;
&lt;p&gt;如果没有调用finish那么onDestroy方法不会被调用，而且在onStop之前还会调用onSavedInstanceState方法&lt;/p&gt;
&lt;p&gt;onRestart方法执行完了之后还会调用onStart方法&lt;/p&gt;
&lt;p&gt;fragment:[SupportFragmentManager,childFragment]&lt;/p&gt;
&lt;p&gt;service:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mengdd/archive/2013/03/24/2979944.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Service的生命周期&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/perfy/p/3820502.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-Service和Thread的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Service和Intent Service:没啥区别，只是IntentService在onCreate方法中开启新的HandlerThread去执行。&lt;/p&gt;
&lt;p&gt;Service运行的进程和线程：当它运行的时候如果是LocalService，那么对应的Service是运行在主进程的main线程上的。如onCreate,onStart这些函数都是在系统调用的时候在主进程的main线程上运行的。如果是RemoteSevice，那么对应的Service则是运行在独立的main线程上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 服务不是单一的进程，服务没有自己的进程，应用程序可以不同，服务运行在相同的进程中
2. 服务不是线程，可以在线程中工作
3. 在应用中，如果是长时间的在后台运行，而且不需要交互的情况下，使用服务
4. 同样是在后台运行，不需要交互的情况下，如果只是完成某个任务，之后就不需要运行，而且可能是多个任务，需要长时间运行的情况下使用线程
5. 如果任务占用CPU时间多，资源大的情况下，要使用线程
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thread的运行是独立于Activity的，也就是说当一个Activity被finish之后，如果你没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread就会一直执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160329110448313&quot; alt=&quot;THREAD_VS_SERVICE&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;8-View绘画机制&quot;&gt;&lt;a href=&quot;#8-View绘画机制&quot; class=&quot;headerlink&quot; title=&quot;8.View绘画机制&quot;&gt;&lt;/a&gt;8.View绘画机制&lt;/h3&gt;&lt;p&gt;View的绘制主要涉及三个方法：onMeasure()、onLayout()、onDraw()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. onMeasure主要用于计算view的大小，onLayout主要用于确定view在ContentView中的位置，onDraw主要是绘制View。
2. 在执行onMeasure()、onLayout()方法时都会通过相应的标志位或者对应的坐标点来判断是否需要执行对应的函数，
   如我们经常调用的invalidate方法就只会执行onDraw方法，因为此时的视图大小和位置均未发生变化，
    除非调用requestLayout方法完整强制进行view的绘制，从而执行上面三个方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进度条组件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hujiaweibujidao/ProgressView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProgressView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hujiaweibujidao/AnnotationView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AnnotationView&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;9-事件传递机制&quot;&gt;&lt;a href=&quot;#9-事件传递机制&quot; class=&quot;headerlink&quot; title=&quot;9.事件传递机制&quot;&gt;&lt;/a&gt;9.事件传递机制&lt;/h3&gt;&lt;p&gt;android 事件处理机制总结，ScrollView ViewPager ListView GridView嵌套小结&lt;/p&gt;
&lt;p&gt;当手指触摸到屏幕时，系统就会调用相应View的onTouchEvent，并传入一系列的action。&lt;/p&gt;
&lt;p&gt;dispatchTouchEvent的执行顺序为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先触发ACTIVITY的dispatchTouchEvent,然后触发ACTIVITY的onUserInteraction

然后触发LAYOUT的dispatchTouchEvent，然后触发LAYOUT的onInterceptTouchEvent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就解释了重写ViewGroup时必须调用super.dispatchTouchEvent();&lt;/p&gt;
&lt;h5 id=&quot;1-dispatchTouchEvent&quot;&gt;&lt;a href=&quot;#1-dispatchTouchEvent&quot; class=&quot;headerlink&quot; title=&quot;(1)dispatchTouchEvent:&quot;&gt;&lt;/a&gt;(1)dispatchTouchEvent:&lt;/h5&gt;&lt;p&gt;此方法一般用于初步处理事件，因为动作是由此分发，所以通常会调用super.dispatchTouchEvent。这样就会继续调用onInterceptTouchEvent，再由onInterceptTouchEvent决定事件流向。&lt;/p&gt;
&lt;h5 id=&quot;2-onInterceptTouchEvent&quot;&gt;&lt;a href=&quot;#2-onInterceptTouchEvent&quot; class=&quot;headerlink&quot; title=&quot;(2)onInterceptTouchEvent:&quot;&gt;&lt;/a&gt;(2)onInterceptTouchEvent:&lt;/h5&gt;&lt;p&gt;若返回值为true事件会传递到自己的onTouchEvent();若返回值为false传递到下一个View的dispatchTouchEvent();&lt;/p&gt;
&lt;h5 id=&quot;3-onTouchEvent&quot;&gt;&lt;a href=&quot;#3-onTouchEvent&quot; class=&quot;headerlink&quot; title=&quot;(3)onTouchEvent():&quot;&gt;&lt;/a&gt;(3)onTouchEvent():&lt;/h5&gt;&lt;p&gt;若返回值为true，事件由自己消耗，后续动作让其处理；若返回值为false，自己不消耗事件了，向上返回让其他的父View的onTouchEvent接受处理&lt;/p&gt;
&lt;p&gt;三大方法关系的伪代码：如果当前View拦截事件，就交给自己的onTouchEvent去处理，否则就丢给子View继续走相同的流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent ev)
{
       boolean consume = false;
    if(onInterceptTouchEvent(ev))
    {
           consume = onTouchEvent(ev);
    } else {
        consume = child.dispatchTouchEvent(ev);
    }
    return consume;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;onTouchEvent的传递：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当有多个层级的View时，在父层级允许的情况下，这个action会一直传递直到遇到最深层的View。所以touch事件最先调用的是最底层View的onTouchEvent，如果View的onTouchEvent接收到某个touch action并做了相应处理，最后有两种返回方式return true和return false；return true会告诉系统当前的View需要处理这次的touch事件，以后的系统发出的ACTION_MOVE,ACTION_UP还是需要继续监听并接收的，并且这次的action已经被处理掉了，父层的View是不可能触发onTouchEvent的了。所以每一个action最多只能有一个onTouchEvent接口返回true。如果返回false，便会通知系统，当前View不关心这一次的touch事件，此时这个action会传向父级，调用父级View的onTouchEvent。但是这一次的touch事件之后发出任何action，该View都不在接受，onTouchEvent在这一次的touch事件中再也不会触发，也就是说一旦View返回false，那么之后的ACTION_MOVE,ACTION_UP等ACTION就不会在传入这个View,但是下一次touch事件的action还是会传进来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父层的onInterceptTouchEvent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面说了底层的View能够接收到这次的事件有一个前提条件：在父层允许的情况下。假设不改变父层级的dispatch方法，在系统调用底层onTouchEvent之前会调用父View的onInterceptTouchEvent方法判断，父层View是否要截获本次touch事件之后的action。如果onInterceptTouchEvent返回了true，那么本次touch事件之后的所有action都不会向深层的View传递，统统都会传给父层View的onTouchEvent，就是说父层已经截获了这次touch事件，之后的action也不必询问onInterceptTouchEvent，在这次的touch事件之后发出的action时onInterceptTouchEvent不会再被调用，直到下一次touch事件的来临。如果onInterceptTouchEvent返回false，那么本次action将发送给更深层的View，并且之后的每一次action都会询问父层的onInterceptTouchEvent需不需要截获本次touch事件。只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，只有ViewGroup才有onInterceptTouchEvent方法，因为一个普通的View肯定是位于最深层的View，touch能够传到这里已经是最后一站了，肯定会调用View的onTouchEvent()。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底层View的getParent().requestDisallowInterceptTouchEvent(true)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于底层的View来说，有一种方法可以阻止父层的View获取touch事件，就是调用getParent().requestDisallowInterceptTouchEvent(true)方法。一旦底层View收到touch的action后调用这个方法那么父层View就不会再调用onInterceptTouchEvent了，也无法截获以后的action（如果父层ViewGroup和最底层View需要截获不同焦点，或不同手势的touch，不能使用这个写死）。&lt;/p&gt;
&lt;p&gt;曾经开发过程中遇到的两个示例：左边是处理ViewPager和ListView的冲突，纪录水平和垂直方向的偏移量，如果水平方向的偏移更多的话就让ViewPager处理pager滑动&lt;/p&gt;
&lt;p&gt;右边处理的ViewPager和ImageBanner的滑动冲突，同样是纪录偏移量，如果发生在ImageBanner上的水平偏移量大于垂直偏移量的话就让banner滚动&lt;/p&gt;
&lt;p&gt;想想为什么右边是重写dispatchTouchEvent方法而不是onInterceptTouchEvent方法？&lt;/p&gt;
&lt;p&gt;FixedViewPager&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public boolean onInterceptTouchEvent(MotionEvent ev)
{
    switch(ev.getAction() &amp;amp; MotionEvent.ACTION_MASK)
    {
        case MotionEvent.ACTION_DOWN:
            mX = ev.getX();
            mY = ev.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            float x = ev.getX();
            float y = ev.getY();
            float dX = x - mX;
            float dY = y - mY;
            float tmp = Math.abs(dX) / Math.abs(dY);
            mX = x;
            mY = y;
            if(tmp &amp;gt; 1)
            {
                return true;
            }
            else
            {
                return super.omInterceptTouchEvent(ev);
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;FixedImageLoadBanner&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@override
public boolean dispatchTouchEvent(MotionEvent ev)
{
    if(mX != 0 || mY != 0)
    {
        float dY = ev.getRawY() - mY;
        float dX = ev.getRawX() - mX;
        if(Math.abs(dY) &amp;gt; Math.abs(dX))
        {
            requestDisallowInterceptTouchEvent(false);
        }
        else
        {
            requestDisallowInterceptTouchEvent(true);
        }
    }
    mX = ev.getRawX();
    mY = ev.getRawY();
    return super.dispatchTouchEvent(ev);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;10-ART和Dalvik区别&quot;&gt;&lt;a href=&quot;#10-ART和Dalvik区别&quot; class=&quot;headerlink&quot; title=&quot;10.ART和Dalvik区别&quot;&gt;&lt;/a&gt;10.ART和Dalvik区别&lt;/h3&gt;&lt;p&gt;art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。&lt;/p&gt;
&lt;p&gt;ART: Ahead of Time Dalvik: Just in Time&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是Dalvik：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是ART:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。&lt;/p&gt;
&lt;p&gt;ART优点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 系统性能的显著提升
2. 应用启动更快、运行更快、体验更流畅、触感反馈更及时。
3. 更长的电池续航能力
4. 支持更低的硬件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ART缺点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 更大的存储空间占用，可能会增加10%-20%
2. 更长的应用安装时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###11.Scroller原理&lt;/p&gt;
&lt;p&gt;Scroller执行流程里面的三个核心方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. mScroller.startScroll()
2. mScroller.computeScrollOffset()
3. view.computeScroll()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1、在mScroller.startScroll()中为滑动做了一些初始化准备，比如：起始坐标，滑动的距离和方向以及持续时间(有默认值)，动画开始时间等。&lt;/p&gt;
&lt;p&gt;2、mScroller.computeScrollOffset()方法主要是根据当前已经消逝的时间来计算当前的坐标点。因为在mScroller.startScroll()中设置了动画时间，那么在computeScrollOffset()方法中依据已经消逝的时间就很容易得到当前时刻应该所处的位置并将其保存在变量mCurrX和mCurrY中。除此之外该方法还可判断动画是否已经结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160329110551127&quot; alt=&quot;SCROLLER&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-Activity-Manager-Service-ActivityThread&quot;&gt;&lt;a href=&quot;#12-Activity-Manager-Service-ActivityThread&quot; class=&quot;headerlink&quot; title=&quot;12.Activity Manager Service, ActivityThread&quot;&gt;&lt;/a&gt;12.Activity Manager Service, ActivityThread&lt;/h3&gt;&lt;h3 id=&quot;13-Android几种进程&quot;&gt;&lt;a href=&quot;#13-Android几种进程&quot; class=&quot;headerlink&quot; title=&quot;13.Android几种进程&quot;&gt;&lt;/a&gt;13.Android几种进程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 前台进程： 即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的
2. 可见线程： 可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互
3. 服务进程： 其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关系的，
             例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等，当系统要用空间运行前两者进程时才会被终止
4. 后台进程： 其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ,这样的进程系统一旦没有内存就首先被杀死。
5. 空进程：   不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如何避免后台进程被杀死？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 调用startForegound,让你的Service所在的进程成为前台进程
2. Service的onStartCommand返回START_STICKY或START_REDELIVER_INTENT
3. Service的onDestroy里面重新启动自己
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;14-Activity启动模式&quot;&gt;&lt;a href=&quot;#14-Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;14.Activity启动模式&quot;&gt;&lt;/a&gt;14.Activity启动模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;standard:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Activity的默认加载方式，该方法会通过跳转到一个新的Activity，同时将该实例压入到栈中(不管该Activity是否已经存在在Task栈中，都是采用new操作，生命周期从onCreate()开始)。例如：栈中顺序是A B C D,此时D通过Intent跳转到A，那么栈中结构就变成A B C D A,点击返回按钮的显示顺序是D C B A，依次摧毁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;singleTop:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;singleTop模式下，当前Activity D位于栈顶的时候，如果通过Intent跳转到它本身的Activity(D)，那么不会重新创建一个新的D实例(走onNewIntent()),所以栈中的结构依次为A B C D,如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个Activity，这肯定用singletop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;singleTask:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;singleTask模式下，Task栈中只能有一个对应的Activity实例。例如：Task栈1中结构为：A B C D。此时D通过Intent跳转到B（走onNewIntent()）,则栈的结构变成了:A,B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。通常应用于首页，首页肯定在栈底部，也只能在栈底部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;singleInstance:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;singleInstance模式下，会将打开的Activity压入一个新的任务栈中。例如：Task栈1中结构为：A B C,C通过Intent跳转到了D（D的模式为singleInstance），那么则会新建一个Task，栈1中结构依旧为A B C,栈2中结构为D。此时屏幕显示D，之后D通过Intent跳转到D，栈2不会压入新的D，所以两个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的launchMode在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C ,此时点击返回按钮，还是在C，栈1的结构变为A B C,而不会回到D。&lt;/p&gt;
&lt;p&gt;##&lt;/p&gt;
&lt;p&gt;launchMode为singleTask的时候，通过Intent启动到一个Activity，如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而不是调用onNewIntent方法。&lt;/p&gt;
&lt;p&gt;onSavedInstanceState的调用遵循一个重要原则，即当系统”未经你许可”时销毁了你的Activity，则onSavedInstanceState会被系统调用，这时系统的责任，因为它必须要提供一个机会让你保存你的数据，至于onRestoreInstanceState方法，需要注意的是，onSavedInstanceState方法和onRestoreInstanceState方法”不一定”是成对调用的。&lt;/p&gt;
&lt;p&gt;onRestoreInstanceState被调用的前提是，Activity A确实被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示Activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到Activity A,这种情况下Activity A一般不会因为内存的原因被销毁，故Activity的onRestoreInstanceState方法不会被执行。&lt;/p&gt;
&lt;p&gt;另外，onRestoreInstanceStated的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。&lt;/p&gt;
&lt;p&gt;onSavedInstanceState(Bundle bundle)通常和onRestoreInstanceState(Bundle bundle)不会成对出现，onRestoreInstanceState这玩意不太好触发，给大家提个好办法，横竖屏切换的时候100%会触发。然后保存在onRestoreInstanceState bundle里面的数据，就是onCreate的那个参数bundle啦，要怎么恢复就看开发者了。&lt;/p&gt;
&lt;h3 id=&quot;15-TMImageView图片库的设计&quot;&gt;&lt;a href=&quot;#15-TMImageView图片库的设计&quot; class=&quot;headerlink&quot; title=&quot;15.TMImageView图片库的设计&quot;&gt;&lt;/a&gt;15.TMImageView图片库的设计&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;Feature机制&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;16-ListView优化&quot;&gt;&lt;a href=&quot;#16-ListView优化&quot; class=&quot;headerlink&quot; title=&quot;16.ListView优化&quot;&gt;&lt;/a&gt;16.ListView优化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 首先，虽然大家都知道，还是提一下，利用好convertView来重用View，切忌每次getView都新建。ListView的核心原理就是重用View。
   ListView有一个回收器，Item滑出界面的时候view就会回收这里，需要显示新的Item的时候，就尽量重用回收器里面的View。

2. 利用好ViewType，例如你的ListView中有几个类型的Item，需要给每个类型创建不同的View，这样有利于ListView的回收，当然类型不能太多

3. 尽量让ItemView的Layout层次结构简单，这时所有Layout都必须遵守的

4. 善用自定义View，自定义View可以有效的减小Layout的层级，而且对绘制过程可以很好的控制

5. 尽量保证Adapter的hasStableIds()返回true，这样在notifyDataSetChanged()的时候，如果id不变，listView将不会重新绘制这个View，达到优化的目的。

6. 每个item不能太高，特别是不要超出屏幕的高度，可以参考Facebook的优化方法，把特别复杂的Item分解为若干个小的Item.

7. 为了保证ListView滑动的流畅性，getView()中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载。

8.使用RecyclerView代替。ListView每次更新数据都要notifyDataSetChanged(),有些太暴力了。RecyclerView在性能和可定制性上都有很大的改善，推荐使用。

9.有时需要从根本上考虑，是否真的要使用listView来实现你的需求，或者是否有其他选择？
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;17-webView&quot;&gt;&lt;a href=&quot;#17-webView&quot; class=&quot;headerlink&quot; title=&quot;17.webView&quot;&gt;&lt;/a&gt;17.webView&lt;/h3&gt;&lt;p&gt;如何使用webview在js中调用java方法？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webView.addJavaScriptInterface(new Object(){xxx}, &amp;quot;xxx&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答案：可以使用WebView控件执行JavaScript脚本，并且可以在JavaScript中执行Java代码。要想让WebView控件执行JavaScript，需要调用WebSettings.setJavaScriptEnabled方法，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WebView webView = (WebView)findViewById(R.id.webview);
WebSettings webSettings = webView.getSettings();
//设置WebView支持JavaScript
webSettings.setJavaScriptEnabled(true);
webView.setWebChromeClient(new WebChromeClient());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript调用Java方法需要使用WebView.addJavascriptInterface方法设置JavaScript调用的Java方法，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webView.addJavascriptInterface(new Object()
{
    //JavaScript调用的方法
    public String process(String value)
    {
        //处理代码
        return result;
    }
}, &amp;quot;demo&amp;quot;);       //demo是Java对象映射到JavaScript中的对象名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用下面的JavaScript代码调用process方法，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
function search()
{
    //调用searchWord方法
    result.innerHTML = &amp;quot;&amp;lt;font color=&amp;apos;red&amp;apos;&amp;gt;&amp;quot; + window.demo.process(&amp;apos;data&amp;apos;) + &amp;quot;&amp;lt;/font&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;18-SurfaceView和View的最本质的区别&quot;&gt;&lt;a href=&quot;#18-SurfaceView和View的最本质的区别&quot; class=&quot;headerlink&quot; title=&quot;18.SurfaceView和View的最本质的区别&quot;&gt;&lt;/a&gt;18.SurfaceView和View的最本质的区别&lt;/h3&gt;&lt;p&gt;SurfaceView是在一个新起的单独线程中可以重新绘制画面，而view必须在UI的主线程中更新画面。&lt;/p&gt;
&lt;p&gt;在UI的主线程中更新画面可能会引发问题，比如你更新的时间过长，那么你的主UI线程就会被你正在画的函数阻塞。那么将无法响应按键、触屏等消息。当使用SurfaceView由于是在新的线程中更新画面所以不会阻塞你的UI主线程。但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要SurfaceView中thread处理，一般就需要有一个event queue的设计来保存touchevent，这会稍稍复杂一点，因为涉及到线程安全。&lt;/p&gt;
&lt;h3 id=&quot;19-标签&quot;&gt;&lt;a href=&quot;#19-标签&quot; class=&quot;headerlink&quot; title=&quot;19.标签&quot;&gt;&lt;/a&gt;19.标签&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;http://www.cnblogs.com/chrisfang6/articles/2217711.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;merge和include&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.open-open.com/lib/view/open1395456763025.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android ViewStub的基本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简言之，都是用来解决重复布局的问题，但是标签能够在布局重用的时候减少UI层级结构。&lt;br&gt;viewStub标签是用来给其他的View事先占据好位置，当需要的时候用inflater()或者是setVisible()方法显示这些View。&lt;/p&gt;
&lt;h3 id=&quot;20-ANR排错&quot;&gt;&lt;a href=&quot;#20-ANR排错&quot; class=&quot;headerlink&quot; title=&quot;20.ANR排错&quot;&gt;&lt;/a&gt;20.ANR排错&lt;/h3&gt;&lt;p&gt;1、ANR排错一般有三种类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. KeyDispatchTimeout(5 seconds) –主要类型按键或触摸事件在特定时间内无响应
2. BroadcastTimeout(10 secends) –BroadcastReceiver在特定时间内无法处理完成
3. ServiceTimeout(20 secends) –小概率事件 Service在特定的时间内无法处理完成
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、如何避免&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. UI线程尽量只做跟UI相关的工作
2. 耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理
3. 尽量用Handler来处理UIthread和别的thread之间的交互
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、如何排查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 首先分析log
2. 从trace.txt文件查看调用stack，adb pull data/anr/traces.txt ./mytraces.txt
3. 看代码
4. 仔细查看ANR的成因(iowait?block?memoryleak?)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4、监测ANR的Watchdog&lt;/p&gt;
&lt;h3 id=&quot;21-fragment生命周期&quot;&gt;&lt;a href=&quot;#21-fragment生命周期&quot; class=&quot;headerlink&quot; title=&quot;21.fragment生命周期&quot;&gt;&lt;/a&gt;21.fragment生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160329110747255&quot; alt=&quot;FRAGMENT&quot;&gt;&lt;/p&gt;
&lt;p&gt;==================================  常见面试问题   =====================================&lt;/p&gt;
&lt;h4 id=&quot;1、横竖屏切换时候Activity的生命周期&quot;&gt;&lt;a href=&quot;#1、横竖屏切换时候Activity的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1、横竖屏切换时候Activity的生命周期&quot;&gt;&lt;/a&gt;1、横竖屏切换时候Activity的生命周期&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. 不设置Activityd饿android:configChanges时，切屏会重新掉哟过各个生命周期，切横屏时会执行一次，切竖屏时会执行两次
2. 设置Activity的android:configChanges=”orientation”时，切屏还是会调用各个生命周期，切换横竖屏只会执行一次
3. 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2、OOM-图片相关的-怎么处理&quot;&gt;&lt;a href=&quot;#2、OOM-图片相关的-怎么处理&quot; class=&quot;headerlink&quot; title=&quot;2、OOM(图片相关的)怎么处理?&quot;&gt;&lt;/a&gt;2、OOM(图片相关的)怎么处理?&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://mzh3344258.blog.51cto.com/1823534/804237&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android 内存溢出解决方案（OOM） 整理总结&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 在内存引用上做些处理，常用的有软引用、弱引用
2. 在内存中加载图片时直接在内存中作处理，如：边界压缩
3. 动态回收内存
4. 优化Dalvik虚拟机的堆内存分配
5. 自定义堆内存大小
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;3、界面优化&quot;&gt;&lt;a href=&quot;#3、界面优化&quot; class=&quot;headerlink&quot; title=&quot;3、界面优化&quot;&gt;&lt;/a&gt;3、界面优化&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.mobile-open.com/2015/38640.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android开发——性能优化之如何防止过度绘制&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太多重叠的背景(overdraw)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太多重叠的View&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个建议是 ：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认是不可见的视图，可以动态的加载一个布局，只要你用到这个重叠着的View的时候才加载，推迟加载的时间。&lt;/p&gt;
&lt;p&gt;第二个建议是：如果使用了类似Viewpager＋Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态的Inflation view，它的性能要比SetVisibility好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复杂的Layout层级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。第二个建议是：用标签来合并布局。第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。&lt;/p&gt;
&lt;h4 id=&quot;4、移动端获取网络数据优化的几个点&quot;&gt;&lt;a href=&quot;#4、移动端获取网络数据优化的几个点&quot; class=&quot;headerlink&quot; title=&quot;4、移动端获取网络数据优化的几个点&quot;&gt;&lt;/a&gt;4、移动端获取网络数据优化的几个点&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. 连接复用：节省连接建立时间，如开启 keep-alive。
   对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，
   具体可见：Android HttpURLConnection及HttpClient选择

2. 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。

3. 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 2.0)。

4. 返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。
  （也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了）

5. 根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;奇迹&lt;br&gt;这个世界每天都有奇迹&lt;br&gt;信不信在你&lt;br&gt;只是发生在你身上的奇迹几乎没有&lt;br&gt;这便是为什么你要努力&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(int 努力 = 0; 努力 &amp;lt; 奇迹.length; 努力++){
    if(努力 == 奇迹.length)
        return success;
    else 
        return again;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;努力没有失败&quot;&gt;&lt;a href=&quot;#努力没有失败&quot; class=&quot;headerlink&quot; title=&quot;努力没有失败&quot;&gt;&lt;/a&gt;努力没有失败&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot;&gt;&lt;a href=&quot;#学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot; class=&quot;headerlink&quot; title=&quot;学习Android，突破自己，一年一总结，我是要当CTO的男人。&quot;&gt;&lt;/a&gt;学习Android，突破自己，一年一总结，我是要当CTO的男人。&lt;/h1&gt;&lt;h1 id=&quot;无论怎样-这可能是我人生中搭建的最搓的一次架构&quot;&gt;&lt;a href=&quot;#无论怎样-这可能是我人生中搭建的最搓的一次架构&quot; class=&quot;headerlink&quot; title=&quot;无论怎样 这可能是我人生中搭建的最搓的一次架构&quot;&gt;&lt;/a&gt;无论怎样 这可能是我人生中搭建的最搓的一次架构&lt;/h1&gt;&lt;p&gt;煎熬了一个月，项目总算吭哧吭哧的完成，从最初的技术选型，到框架搭建，再到着手开发app，是一次尝试，也让自己越来越坚定的想在Android之路走下去，像这么有意思的事，不做个纪念写点东西是不行的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列之图片缓存技术</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之图片缓存技术/</id>
    <published>2016-08-13T08:26:30.000Z</published>
    <updated>2016-08-14T05:59:10.269Z</updated>
    
    <content type="html">&lt;p&gt;#Android 三大图片缓存原理、特性对比&lt;/p&gt;
&lt;p&gt;从总体设计和原理上对几个图片缓存进行对比，简单了解他们在某些特性上的实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一-四大图片缓存基本信息&quot;&gt;&lt;a href=&quot;#一-四大图片缓存基本信息&quot; class=&quot;headerlink&quot; title=&quot;一. 四大图片缓存基本信息&quot;&gt;&lt;/a&gt;一. 四大图片缓存基本信息&lt;/h2&gt;&lt;h3 id=&quot;Universal-ImageLoader&quot;&gt;&lt;a href=&quot;#Universal-ImageLoader&quot; class=&quot;headerlink&quot; title=&quot;Universal ImageLoader&quot;&gt;&lt;/a&gt;Universal ImageLoader&lt;/h3&gt;&lt;p&gt;是很早开源的图片缓存，在早期被很多应用使用。&lt;/p&gt;
&lt;h3 id=&quot;Picasso&quot;&gt;&lt;a href=&quot;#Picasso&quot; class=&quot;headerlink&quot; title=&quot;Picasso&quot;&gt;&lt;/a&gt;Picasso&lt;/h3&gt;&lt;p&gt;是 Square 开源的项目，且他的主导者是 JakeWharton，所以广为人知。&lt;/p&gt;
&lt;h3 id=&quot;Glide&quot;&gt;&lt;a href=&quot;#Glide&quot; class=&quot;headerlink&quot; title=&quot;Glide&quot;&gt;&lt;/a&gt;Glide&lt;/h3&gt;&lt;p&gt;是 Google 员工的开源项目，被一些 Google App 使用，在去年的 Google I/O 上被推荐，不过目前国内资料不多。&lt;/p&gt;
&lt;h3 id=&quot;Fresco&quot;&gt;&lt;a href=&quot;#Fresco&quot; class=&quot;headerlink&quot; title=&quot;Fresco&quot;&gt;&lt;/a&gt;Fresco&lt;/h3&gt;&lt;p&gt;是 Facebook 在今年上半年开源的图片缓存，主要特点包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1) 两个内存缓存加上 Native 缓存构成了三级缓存

(2) 支持流式，可以类似网页上模糊渐进式显示图片

(3) 对多帧动画图片支持更好，如 Gif、WebP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;鉴于 Fresco 还没发布正式的 1.0 版本，同时一直没太多时间熟悉 Fresco 源码，后面对比不包括 Fresco，以后有时间再加入对比。&lt;/p&gt;
&lt;p&gt;更多图片缓存库可见：&lt;a href=&quot;http://p.codekk.com/?s=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android 图片缓存库&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、基本概念&quot;&gt;&lt;a href=&quot;#二、基本概念&quot; class=&quot;headerlink&quot; title=&quot;二、基本概念&quot;&gt;&lt;/a&gt;二、基本概念&lt;/h2&gt;&lt;p&gt;在正式对比前，先了解几个图片缓存通用的概念：&lt;/p&gt;
&lt;p&gt;(1) RequestManager：请求生成和管理模块&lt;/p&gt;
&lt;p&gt;(2) Engine：引擎部分，负责创建任务(获取数据)，并调度执行&lt;/p&gt;
&lt;p&gt;(3) GetDataInterface：数据获取接口，负责从各个数据源获取数据。&lt;br&gt;比如 MemoryCache 从内存缓存获取数据、DiskCache 从本地缓存获取数据，下载器从网络获取数据等。&lt;/p&gt;
&lt;p&gt;(4) Displayer：资源(图片)显示器，用于显示或操作资源。&lt;br&gt;比如 ImageView，这几个图片缓存都不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。&lt;/p&gt;
&lt;p&gt;(5) Processor 资源(图片)处理器&lt;br&gt;负责处理资源，比如旋转、压缩、截取等。&lt;/p&gt;
&lt;p&gt;以上概念的称呼在不同图片缓存中可能不同，比如 Displayer 在 ImageLoader 中叫做 ImageAware，在 Picasso 和 Glide 中叫做 Target。&lt;/p&gt;
&lt;h2 id=&quot;三、共同优点&quot;&gt;&lt;a href=&quot;#三、共同优点&quot; class=&quot;headerlink&quot; title=&quot;三、共同优点&quot;&gt;&lt;/a&gt;三、共同优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用简单&lt;br&gt;都可以通过一句代码可实现图片获取和显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可配置度高，自适应程度高&lt;br&gt;图片缓存的下载器(重试机制)、解码器、显示器、处理器、内存缓存、本地缓存、线程池、缓存算法等大都可轻松配置。&lt;br&gt;自适应程度高，根据系统性能初始化缓存配置、系统信息变更后动态调整策略。&lt;br&gt;比如根据 CPU 核数确定最大并发数，根据可用内存确定内存缓存大小，网络状态变化时调整最大并发数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多级缓存&lt;br&gt;都至少有两级缓存、提高图片加载速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持多种数据源&lt;br&gt;支持多种数据源，网络、本地、资源、Assets 等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;支持多种 Displayer&lt;br&gt;不仅仅支持 ImageView，同时支持其他 View 以及虚拟的 Displayer 概念。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他小的共同点包括支持动画、支持 transform 处理、获取 EXIF 信息等。&lt;/p&gt;
&lt;h2 id=&quot;四、ImageLoader-设计及优点&quot;&gt;&lt;a href=&quot;#四、ImageLoader-设计及优点&quot; class=&quot;headerlink&quot; title=&quot;四、ImageLoader 设计及优点&quot;&gt;&lt;/a&gt;四、ImageLoader 设计及优点&lt;/h2&gt;&lt;h3 id=&quot;1-总体设计及流程&quot;&gt;&lt;a href=&quot;#1-总体设计及流程&quot; class=&quot;headerlink&quot; title=&quot;1. 总体设计及流程&quot;&gt;&lt;/a&gt;1. 总体设计及流程&lt;/h3&gt;&lt;p&gt;上面是 ImageLoader 的总体设计图。整个库分为 ImageLoaderEngine，Cache 及 ImageDownloader，ImageDecoder，BitmapDisplayer，BitmapProcessor 五大模块，其中 Cache 分为 MemoryCache 和 DiskCache 两部分。&lt;/p&gt;
&lt;p&gt;简单的讲就是 ImageLoader 收到加载及显示图片的任务，并将它交给 ImageLoaderEngine，ImageLoaderEngine 分发任务到具体线程池去执行，任务通过 Cache 及 ImageDownloader 获取图片，中间可能经过 BitmapProcessor 和 ImageDecoder 处理，最终转换为Bitmap 交给 BitmapDisplayer 在 ImageAware 中显示。&lt;/p&gt;
&lt;h3 id=&quot;2-ImageLoader-优点&quot;&gt;&lt;a href=&quot;#2-ImageLoader-优点&quot; class=&quot;headerlink&quot; title=&quot;2. ImageLoader 优点&quot;&gt;&lt;/a&gt;2. ImageLoader 优点&lt;/h3&gt;&lt;h5 id=&quot;1-支持下载进度监听&quot;&gt;&lt;a href=&quot;#1-支持下载进度监听&quot; class=&quot;headerlink&quot; title=&quot;(1) 支持下载进度监听&quot;&gt;&lt;/a&gt;(1) 支持下载进度监听&lt;/h5&gt;&lt;h5 id=&quot;2-可以在-View-滚动中暂停图片加载&quot;&gt;&lt;a href=&quot;#2-可以在-View-滚动中暂停图片加载&quot; class=&quot;headerlink&quot; title=&quot;(2) 可以在 View 滚动中暂停图片加载&quot;&gt;&lt;/a&gt;(2) 可以在 View 滚动中暂停图片加载&lt;/h5&gt;&lt;p&gt;通过 PauseOnScrollListener 接口可以在 View 滚动中暂停图片加载。&lt;/p&gt;
&lt;h5 id=&quot;3-默认实现多种内存缓存算法&quot;&gt;&lt;a href=&quot;#3-默认实现多种内存缓存算法&quot; class=&quot;headerlink&quot; title=&quot;(3) 默认实现多种内存缓存算法&quot;&gt;&lt;/a&gt;(3) 默认实现多种内存缓存算法&lt;/h5&gt;&lt;p&gt;这几个图片缓存都可以配置缓存算法，不过 ImageLoader 默认实现了较多缓存算法，如 Size 最大先删除、使用最少先删除、最近最少使用、先进先删除、时间最长先删除等。&lt;/p&gt;
&lt;h5 id=&quot;4-支持本地缓存文件名规则定义&quot;&gt;&lt;a href=&quot;#4-支持本地缓存文件名规则定义&quot; class=&quot;headerlink&quot; title=&quot;(4) 支持本地缓存文件名规则定义&quot;&gt;&lt;/a&gt;(4) 支持本地缓存文件名规则定义&lt;/h5&gt;&lt;h2 id=&quot;五、Picasso-设计及优点&quot;&gt;&lt;a href=&quot;#五、Picasso-设计及优点&quot; class=&quot;headerlink&quot; title=&quot;五、Picasso 设计及优点&quot;&gt;&lt;/a&gt;五、Picasso 设计及优点&lt;/h2&gt;&lt;h3 id=&quot;1-总体设计及流程-1&quot;&gt;&lt;a href=&quot;#1-总体设计及流程-1&quot; class=&quot;headerlink&quot; title=&quot;1. 总体设计及流程&quot;&gt;&lt;/a&gt;1. 总体设计及流程&lt;/h3&gt;&lt;p&gt;上面是 Picasso 的总体设计图。整个库分为 Dispatcher，RequestHandler 及 Downloader，PicassoDrawable 等模块。&lt;/p&gt;
&lt;p&gt;Dispatcher 负责分发和处理 Action，包括提交、暂停、继续、取消、网络状态变化、重试等等。&lt;/p&gt;
&lt;p&gt;简单的讲就是 Picasso 收到加载及显示图片的任务，创建 Request 并将它交给 Dispatcher，Dispatcher 分发任务到具体 RequestHandler，任务通过 MemoryCache 及 Handler(数据获取接口) 获取图片，图片获取成功后通过 PicassoDrawable 显示到 Target 中。&lt;/p&gt;
&lt;p&gt;需要注意的是上面 Data 的 File system 部分，Picasso 没有自定义本地缓存的接口，默认使用 http 的本地缓存，API 9 以上使用 okhttp，以下使用 Urlconnection，所以如果需要自定义本地缓存就需要重定义 Downloader。&lt;/p&gt;
&lt;h3 id=&quot;2-Picasso-优点&quot;&gt;&lt;a href=&quot;#2-Picasso-优点&quot; class=&quot;headerlink&quot; title=&quot;2. Picasso 优点&quot;&gt;&lt;/a&gt;2. Picasso 优点&lt;/h3&gt;&lt;h5 id=&quot;1-自带统计监控功能&quot;&gt;&lt;a href=&quot;#1-自带统计监控功能&quot; class=&quot;headerlink&quot; title=&quot;(1) 自带统计监控功能&quot;&gt;&lt;/a&gt;(1) 自带统计监控功能&lt;/h5&gt;&lt;p&gt;支持图片缓存使用的监控，包括缓存命中率、已使用内存大小、节省的流量等。&lt;/p&gt;
&lt;h5 id=&quot;2-支持优先级处理&quot;&gt;&lt;a href=&quot;#2-支持优先级处理&quot; class=&quot;headerlink&quot; title=&quot;(2) 支持优先级处理&quot;&gt;&lt;/a&gt;(2) 支持优先级处理&lt;/h5&gt;&lt;p&gt;每次任务调度前会选择优先级高的任务，比如 App 页面中 Banner 的优先级高于 Icon 时就很适用。&lt;/p&gt;
&lt;h5 id=&quot;3-支持延迟到图片尺寸计算完成加载&quot;&gt;&lt;a href=&quot;#3-支持延迟到图片尺寸计算完成加载&quot; class=&quot;headerlink&quot; title=&quot;(3) 支持延迟到图片尺寸计算完成加载&quot;&gt;&lt;/a&gt;(3) 支持延迟到图片尺寸计算完成加载&lt;/h5&gt;&lt;h5 id=&quot;4-支持飞行模式、并发线程数根据网络类型而变&quot;&gt;&lt;a href=&quot;#4-支持飞行模式、并发线程数根据网络类型而变&quot; class=&quot;headerlink&quot; title=&quot;(4) 支持飞行模式、并发线程数根据网络类型而变&quot;&gt;&lt;/a&gt;(4) 支持飞行模式、并发线程数根据网络类型而变&lt;/h5&gt;&lt;p&gt;手机切换到飞行模式或网络类型变换时会自动调整线程池最大并发数，比如 wifi 最大并发为 4， 4g 为 3，3g 为 2。&lt;br&gt;这里 Picasso 根据网络类型来决定最大并发数，而不是 CPU 核数。&lt;/p&gt;
&lt;h5 id=&quot;5-“无”本地缓存&quot;&gt;&lt;a href=&quot;#5-“无”本地缓存&quot; class=&quot;headerlink&quot; title=&quot;(5) “无”本地缓存&quot;&gt;&lt;/a&gt;(5) “无”本地缓存&lt;/h5&gt;&lt;p&gt;无”本地缓存，不是说没有本地缓存，而是 Picasso 自己没有实现，交给了 Square 的另外一个网络库 okhttp 去实现，这样的好处是可以通过请求 Response Header 中的 Cache-Control 及 Expired 控制图片的过期时间。&lt;/p&gt;
&lt;h2 id=&quot;六、Glide-设计及优点&quot;&gt;&lt;a href=&quot;#六、Glide-设计及优点&quot; class=&quot;headerlink&quot; title=&quot;六、Glide 设计及优点&quot;&gt;&lt;/a&gt;六、Glide 设计及优点&lt;/h2&gt;&lt;h3 id=&quot;1-总体设计及流程-2&quot;&gt;&lt;a href=&quot;#1-总体设计及流程-2&quot; class=&quot;headerlink&quot; title=&quot;1. 总体设计及流程&quot;&gt;&lt;/a&gt;1. 总体设计及流程&lt;/h3&gt;&lt;p&gt;上面是 Glide 的总体设计图。整个库分为 RequestManager(请求管理器)，Engine(数据获取引擎)、 Fetcher(数据获取器)、MemoryCache(内存缓存)、DiskLRUCache、Transformation(图片处理)、Encoder(本地缓存存储)、Registry(图片类型及解析器配置)、Target(目标) 等模块。&lt;/p&gt;
&lt;p&gt;简单的讲就是 Glide 收到加载及显示资源的任务，创建 Request 并将它交给RequestManager，Request 启动 Engine 去数据源获取资源(通过 Fetcher )，获取到后 Transformation 处理后交给 Target。&lt;/p&gt;
&lt;p&gt;Glide 依赖于 DiskLRUCache、GifDecoder 等开源库去完成本地缓存和 Gif 图片解码工作。&lt;/p&gt;
&lt;h3 id=&quot;2-Glide-优点&quot;&gt;&lt;a href=&quot;#2-Glide-优点&quot; class=&quot;headerlink&quot; title=&quot;2. Glide 优点&quot;&gt;&lt;/a&gt;2. Glide 优点&lt;/h3&gt;&lt;h5 id=&quot;1-图片缓存-gt-媒体缓存&quot;&gt;&lt;a href=&quot;#1-图片缓存-gt-媒体缓存&quot; class=&quot;headerlink&quot; title=&quot;(1) 图片缓存-&amp;gt;媒体缓存&quot;&gt;&lt;/a&gt;(1) 图片缓存-&amp;gt;媒体缓存&lt;/h5&gt;&lt;p&gt;Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video，所以更该当做一个媒体缓存。&lt;/p&gt;
&lt;h5 id=&quot;2-支持优先级处理-1&quot;&gt;&lt;a href=&quot;#2-支持优先级处理-1&quot; class=&quot;headerlink&quot; title=&quot;(2) 支持优先级处理&quot;&gt;&lt;/a&gt;(2) 支持优先级处理&lt;/h5&gt;&lt;h5 id=&quot;3-与-Activity-Fragment-生命周期一致，支持-trimMemory&quot;&gt;&lt;a href=&quot;#3-与-Activity-Fragment-生命周期一致，支持-trimMemory&quot; class=&quot;headerlink&quot; title=&quot;(3) 与 Activity/Fragment 生命周期一致，支持 trimMemory&quot;&gt;&lt;/a&gt;(3) 与 Activity/Fragment 生命周期一致，支持 trimMemory&lt;/h5&gt;&lt;p&gt;Glide 对每个 context 都保持一个 RequestManager，通过 FragmentTransaction 保持与 Activity/Fragment 生命周期一致，并且有对应的 trimMemory 接口实现可供调用。&lt;/p&gt;
&lt;h5 id=&quot;4-支持-okhttp、Volley&quot;&gt;&lt;a href=&quot;#4-支持-okhttp、Volley&quot; class=&quot;headerlink&quot; title=&quot;(4) 支持 okhttp、Volley&quot;&gt;&lt;/a&gt;(4) 支持 okhttp、Volley&lt;/h5&gt;&lt;p&gt;Glide 默认通过 UrlConnection 获取数据，可以配合 okhttp 或是 Volley 使用。实际 ImageLoader、Picasso 也都支持 okhttp、Volley。&lt;/p&gt;
&lt;h5 id=&quot;5-内存友好&quot;&gt;&lt;a href=&quot;#5-内存友好&quot; class=&quot;headerlink&quot; title=&quot;(5) 内存友好&quot;&gt;&lt;/a&gt;(5) 内存友好&lt;/h5&gt;&lt;p&gt;① Glide 的内存缓存有个 active 的设计&lt;br&gt;从内存缓存中取数据时，不像一般的实现用 get，而是用 remove，再将这个缓存数据放到一个 value 为软引用的 activeResources map 中，并计数引用数，在图片加载完成后进行判断，如果引用计数为空则回收掉。&lt;/p&gt;
&lt;p&gt;② 内存缓存更小图片&lt;br&gt;Glide 以 url、view_width、view_height、屏幕的分辨率等做为联合 key，将处理后的图片缓存在内存缓存中，而不是原始图片以节省大小&lt;/p&gt;
&lt;p&gt;③ 与 Activity/Fragment 生命周期一致，支持 trimMemory&lt;/p&gt;
&lt;p&gt;④ 图片默认使用默认 RGB_565 而不是 ARGB_888&lt;br&gt;虽然清晰度差些，但图片更小，也可配置到 ARGB_888。&lt;/p&gt;
&lt;p&gt;其他：Glide 可以通过 signature 或不使用本地缓存支持 url 过期&lt;/p&gt;
&lt;h2 id=&quot;七、汇总&quot;&gt;&lt;a href=&quot;#七、汇总&quot; class=&quot;headerlink&quot; title=&quot;七、汇总&quot;&gt;&lt;/a&gt;七、汇总&lt;/h2&gt;&lt;p&gt;三者总体上来说，ImageLoader 的功能以及代理容易理解长度都一般。&lt;/p&gt;
&lt;p&gt;Picasso 代码虽然只在一个包下，没有严格的包区分，但代码简单、逻辑清晰，一两个小时就能叫深入的了解完。&lt;/p&gt;
&lt;p&gt;Glide 功能强大，但代码量大、流转复杂。在较深掌握的情况下才推荐使用，免得出了问题难以下手解决。&lt;/p&gt;
&lt;p&gt;更多图片缓存库可见：&lt;a href=&quot;http://p.codekk.com/?s=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android 图片缓存库&lt;/a&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;#Android 三大图片缓存原理、特性对比&lt;/p&gt;
&lt;p&gt;从总体设计和原理上对几个图片缓存进行对比，简单了解他们在某些特性上的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列MVP架构</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8BMVP%E6%9E%B6%E6%9E%84/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之MVP架构/</id>
    <published>2016-08-13T08:25:51.000Z</published>
    <updated>2016-08-13T08:37:48.113Z</updated>
    
    <content type="html">&lt;h3 id=&quot;MVP-Model-View-Presenter&quot;&gt;&lt;a href=&quot;#MVP-Model-View-Presenter&quot; class=&quot;headerlink&quot; title=&quot;MVP(Model-View-Presenter)&quot;&gt;&lt;/a&gt;MVP(Model-View-Presenter)&lt;/h3&gt;&lt;p&gt;该软件设计架构在Android开发过程中能够分离出项目的业务逻辑代码和视图展现代码，达到解耦模块化的效果。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###MVP如何工作：&lt;br&gt;      在项目开发时，将系统分为数据模型（Model），视图（View），和Presenter（预处理层）三个部分。&lt;br&gt;其中&lt;/p&gt;
&lt;p&gt;Presenter    作为中间层，从Model层获取数据,进行处理之后,交给View层进行展示.&lt;/p&gt;
&lt;p&gt;View          只需要展示数据&lt;/p&gt;
&lt;p&gt;Model         完成数据的请求处理&lt;/p&gt;
&lt;p&gt;###各模块具体职责:&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MVP-Model-View-Presenter&quot;&gt;&lt;a href=&quot;#MVP-Model-View-Presenter&quot; class=&quot;headerlink&quot; title=&quot;MVP(Model-View-Presenter)&quot;&gt;&lt;/a&gt;MVP(Model-View-Presenter)&lt;/h3&gt;&lt;p&gt;该软件设计架构在Android开发过程中能够分离出项目的业务逻辑代码和视图展现代码，达到解耦模块化的效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进阶系列设计模式</title>
    <link href="http://tufusi.com/2016/08/13/%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://tufusi.com/2016/08/13/进阶系列之设计模式/</id>
    <published>2016-08-13T08:24:43.000Z</published>
    <updated>2016-08-13T08:52:13.342Z</updated>
    
    <content type="html">&lt;p&gt;笔记源于阅读《HeadFirst设计模式》一书&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;HeadFirst设计模式&quot;&gt;&lt;a href=&quot;#HeadFirst设计模式&quot; class=&quot;headerlink&quot; title=&quot;HeadFirst设计模式&quot;&gt;&lt;/a&gt;HeadFirst设计模式&lt;/h2&gt;&lt;h3 id=&quot;一、-设计原则&quot;&gt;&lt;a href=&quot;#一、-设计原则&quot; class=&quot;headerlink&quot; title=&quot;一、 设计原则&quot;&gt;&lt;/a&gt;一、 设计原则&lt;/h3&gt;&lt;p&gt;1） 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。&lt;/p&gt;
&lt;p&gt;2） 针对接口编程，而不是针对实现编程。&lt;/p&gt;
&lt;p&gt;3） 多用组合，少用继承。&lt;/p&gt;
&lt;p&gt;4） 为了交互对象之间的松耦合设计而努力。&lt;/p&gt;
&lt;h3 id=&quot;二、-设计模式&quot;&gt;&lt;a href=&quot;#二、-设计模式&quot; class=&quot;headerlink&quot; title=&quot;二、 设计模式&quot;&gt;&lt;/a&gt;二、 设计模式&lt;/h3&gt;&lt;h4 id=&quot;『策略模式』&quot;&gt;&lt;a href=&quot;#『策略模式』&quot; class=&quot;headerlink&quot; title=&quot;『策略模式』&quot;&gt;&lt;/a&gt;『策略模式』&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;『观察者模式』&quot;&gt;&lt;a href=&quot;#『观察者模式』&quot; class=&quot;headerlink&quot; title=&quot;『观察者模式』&quot;&gt;&lt;/a&gt;『观察者模式』&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;笔记源于阅读《HeadFirst设计模式》一书&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优秀第三方SDK分析-Fresco</title>
    <link href="http://tufusi.com/2016/06/20/%E4%BC%98%E7%A7%80%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E5%88%86%E6%9E%90-Fresco/"/>
    <id>http://tufusi.com/2016/06/20/优秀第三方SDK分析-Fresco/</id>
    <published>2016-06-20T15:09:23.000Z</published>
    <updated>2016-06-20T15:09:23.648Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android优化交互-协调布局详解</title>
    <link href="http://tufusi.com/2016/06/20/Android%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%8D%8F%E8%B0%83%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tufusi.com/2016/06/20/Android优化交互-协调布局详解/</id>
    <published>2016-06-20T14:59:11.000Z</published>
    <updated>2016-06-20T14:59:11.581Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android优化交互-嵌套机制详解</title>
    <link href="http://tufusi.com/2016/06/20/Android%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tufusi.com/2016/06/20/Android优化交互-嵌套机制详解/</id>
    <published>2016-06-20T14:57:42.000Z</published>
    <updated>2016-06-20T14:57:42.742Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio之Plugins</title>
    <link href="http://tufusi.com/2016/06/14/AndroidStudio%E4%B9%8BPlugins/"/>
    <id>http://tufusi.com/2016/06/14/AndroidStudio之Plugins/</id>
    <published>2016-06-14T13:10:00.000Z</published>
    <updated>2016-06-14T13:10:00.135Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio之Gradle</title>
    <link href="http://tufusi.com/2016/06/07/AndroidStudio%E4%B9%8BGradle/"/>
    <id>http://tufusi.com/2016/06/07/AndroidStudio之Gradle/</id>
    <published>2016-06-07T11:31:22.000Z</published>
    <updated>2016-06-19T06:24:30.132Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Gradle-概述&quot;&gt;&lt;a href=&quot;#Gradle-概述&quot; class=&quot;headerlink&quot; title=&quot;Gradle 概述&quot;&gt;&lt;/a&gt;Gradle 概述&lt;/h3&gt;&lt;p&gt;是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – &lt;a href=&quot;https://en.wikipedia.org/wiki/Groovy_(programming_language&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Groovy&lt;/a&gt;) 编写而成，再加上&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSL（领域特定语言）&lt;/a&gt;组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;analysis-in-AS&quot;&gt;&lt;a href=&quot;#analysis-in-AS&quot; class=&quot;headerlink&quot; title=&quot;analysis in AS&quot;&gt;&lt;/a&gt;analysis in AS&lt;/h4&gt;&lt;p&gt;Android Studio新建一个工程后，默认生成两个build.gralde文件，一个位于project根目录下，一个位于app目录下。除此还有一个文件settings.gradle。&lt;/p&gt;
&lt;p&gt;根目录下的脚本文件是针对module的全局配置，它的作用域内包含的所有 module 是通过settings.gradle来配置。app文件夹就是一个module，如果在当前project中新增Module – library，就要在settings.gralde文件中包含这个新的module。&lt;/p&gt;
&lt;p&gt;当然很多朋友我相信在新建项目以及库的时候更多是通过右键建立的，这样更加方便，但要知晓其中的原理，对于熟悉gradle构建系统来说是不可或缺的。&lt;/p&gt;
&lt;h3 id=&quot;gradle脚本的基本结构&quot;&gt;&lt;a href=&quot;#gradle脚本的基本结构&quot; class=&quot;headerlink&quot; title=&quot;gradle脚本的基本结构&quot;&gt;&lt;/a&gt;gradle脚本的基本结构&lt;/h3&gt;&lt;p&gt;用新建工程为例，根目录的build.gradle的内容如下所示：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Top-level build file &lt;span class=&quot;built_in&quot;&gt;where&lt;/span&gt; you can add configuration options common to all sub-projects/modules.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buildscript &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jcenter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classpath &lt;span class=&quot;string&quot;&gt;&#39;com.android.tools.build:gradle:2.1.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // NOTE: Do not place your application dependencies here; they belong&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the individual module build.gradle files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;allprojects &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jcenter(）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;task clean(&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: Delete) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delete rootProject.buildDir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后是 settings.gradle 文件：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &lt;span class=&quot;string&quot;&gt;&#39;:app&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;app就是应用程序的一个module，如果有多个module，可以在为 include 方法添加多个参数，并以逗号隔开。&lt;/p&gt;
&lt;p&gt;最后是app/build.gradle&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apply plugin: &lt;span class=&quot;string&quot;&gt;&#39;com.android.application&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compileSdkVersion 23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildToolsVersion &lt;span class=&quot;string&quot;&gt;&quot;23.0.3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    defaultConfig &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        applicationId &lt;span class=&quot;string&quot;&gt;&quot;app full name&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        minSdkVersion 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        targetSdkVersion 23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        versionCode 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        versionName &lt;span class=&quot;string&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signingConfigs &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storeFile file(&lt;span class=&quot;string&quot;&gt;&#39;release.keystore&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storePassword &lt;span class=&quot;string&quot;&gt;&quot;yourstorepassword&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            keyAlias &lt;span class=&quot;string&quot;&gt;&quot;yourkeyalias&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            keyPassword &lt;span class=&quot;string&quot;&gt;&quot;yourkeypassword&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        debug &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storeFile file(&lt;span class=&quot;string&quot;&gt;&#39;debug.keystore&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildTypes &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minifyEnabled &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proguardFiles getDefaultProguardFile(&lt;span class=&quot;string&quot;&gt;&#39;proguard-android.txt&#39;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;proguard-rules.pro&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            signingConfig signingConfigs.release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        debug &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            signingConfig signingConfigs.debug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    productFlavors &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        market &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Wandoujia &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile fileTree(dir: &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;, include: [&lt;span class=&quot;string&quot;&gt;&#39;*.jar&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;Compile &lt;span class=&quot;string&quot;&gt;&#39;junit:junit:4.12&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile &lt;span class=&quot;string&quot;&gt;&#39;com.android.support:appcompat-v7:23.4.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Groovy 的基本语法&lt;br&gt;方法调用&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apply plugin: &lt;span class=&quot;string&quot;&gt;&#39;com.android.application&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上语句中的apply是一个方法，给它传递了一个参数plugin，plugin 的值是’com.android.application’。&lt;/p&gt;
&lt;p&gt;如果有多个参数，则以逗号隔开，例如&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile name: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;, ext: &lt;span class=&quot;string&quot;&gt;&#39;aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;闭包&lt;/p&gt;
&lt;p&gt;Groovy中花括号包含的部分成为一个闭包（Closure）。例如下面的代码&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;compileOptions 是一个 Method， 它的参数是一个闭包， 这个闭包内依次执行了两个方法 – sourceCompatibility 和targetCompatibility， 参数都是JavaVersion.VERSION_1_7,即是你jdk配置环境所使用的版本。&lt;/p&gt;
&lt;p&gt;闭包也可以嵌套包含&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;常见使用方法&quot;&gt;&lt;a href=&quot;#常见使用方法&quot; class=&quot;headerlink&quot; title=&quot;常见使用方法&quot;&gt;&lt;/a&gt;常见使用方法&lt;/h4&gt;&lt;h5 id=&quot;包依赖（aar）&quot;&gt;&lt;a href=&quot;#包依赖（aar）&quot; class=&quot;headerlink&quot; title=&quot;包依赖（aar）&quot;&gt;&lt;/a&gt;包依赖（aar）&lt;/h5&gt;&lt;p&gt;使用aar时可以分为两种情况&lt;br&gt;① aar位于本地目录&lt;/p&gt;
&lt;p&gt;首先在 Build.gradle(Module:app) 中 android 的参数闭包中添加调用方法 repositories&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后在 dependencies 的参数闭包中添加&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile name: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;, ext: &lt;span class=&quot;string&quot;&gt;&#39;aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;② aar位于远程仓库&lt;/p&gt;
&lt;p&gt;这里以maven为例，当然也可以使用其他类型的仓库，例如 Ivy、Bintray。&lt;/p&gt;
&lt;p&gt;只需要在jar包引用方式后面添加一个@aar就可以了&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4@aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;包依赖（jar）&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile group:&lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano&#39;&lt;/span&gt;,module: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;,version: &lt;span class=&quot;string&quot;&gt;&#39;1.3.4&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以简写成&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;去掉重复依赖&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4&#39;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exclude module: &lt;span class=&quot;string&quot;&gt;&#39;annotations&#39;&lt;/span&gt;, group: &lt;span class=&quot;string&quot;&gt;&#39;com.google.android&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 Java7 或者 Java8&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;针对JDK1.8, 等公司项目上线我会专门看一些这方面的资料进行博客整理，主要对RetroLambda结合RxJava的一些功能展示及Sourcecode理解&lt;/p&gt;
&lt;h5 id=&quot;productFlavors（渠道打包）&quot;&gt;&lt;a href=&quot;#productFlavors（渠道打包）&quot; class=&quot;headerlink&quot; title=&quot;productFlavors（渠道打包）&quot;&gt;&lt;/a&gt;productFlavors（渠道打包）&lt;/h5&gt;&lt;p&gt;该部分在项目完成上线之前，会将所看资料整合另开一篇文章说明。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;其实在使用Gradle构建时，如果项目引用的依赖过于多而杂，而又需要考虑到这些依赖版本的更新问题，参考过&lt;a href=&quot;http://blog.zhaiyifan.cn/2016/03/14/android-new-project-from-0-p2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MarkZhai&lt;/a&gt;的博客,本人也偏向于新建全局gradle，专门用于管理版本的迭代问题，不用一处改处处改，效果在试过之后会能明显feel到。&lt;/p&gt;
&lt;p&gt;刚来新公司，一个人负责项目从零起步到最后打包上线，不得不说，这是一个挑战，但这又何尝不是一个机会，目前还处于app开发阶段。在抛弃前公司一直沿用的Volley Network Framework之后，我一直在尝试着使用更多以前未接触过的技术，RxJava，Dagger，OkHttp+Retrofit，Stetho+GsonFormat and so on，包括这次的关于Gradle的博客书写，发现Gradle其实也蛮好（zhuang）用(bi)的！当然用这些新技术需要花不少的时间成本，但“ 总有人要赢的，那个人为什么不是我 ”， 爱豆科比的经典名言啊。&lt;br&gt;努力 奋斗 致每一位正在努力的小婊砸&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gradle-概述&quot;&gt;&lt;a href=&quot;#Gradle-概述&quot; class=&quot;headerlink&quot; title=&quot;Gradle 概述&quot;&gt;&lt;/a&gt;Gradle 概述&lt;/h3&gt;&lt;p&gt;是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – &lt;a href=&quot;https://en.wikipedia.org/wiki/Groovy_(programming_language&quot;&gt;Groovy&lt;/a&gt;) 编写而成，再加上&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL（领域特定语言）&lt;/a&gt;组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。&lt;/p&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://tufusi.com/categories/Gradle/"/>
    
    
      <category term="Gradle，Android，BuildSystem" scheme="http://tufusi.com/tags/Gradle%EF%BC%8CAndroid%EF%BC%8CBuildSystem/"/>
    
  </entry>
  
  <entry>
    <title>Android部落格之RxJava框架</title>
    <link href="http://tufusi.com/2016/06/07/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRxJava%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/07/Android部落格之RxJava框架/</id>
    <published>2016-06-07T01:14:57.000Z</published>
    <updated>2016-08-07T07:22:24.491Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;a library for composing asynchronous and event-based programs using observable sequences for the Java VM&lt;/p&gt;
&lt;p&gt;一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Observables-被观察者-事件源-———–-gt-发出事件&quot;&gt;&lt;a href=&quot;#Observables-被观察者-事件源-———–-gt-发出事件&quot; class=&quot;headerlink&quot; title=&quot;Observables(被观察者/事件源) ———–&amp;gt;  发出事件&quot;&gt;&lt;/a&gt;Observables(被观察者/事件源) ———–&amp;gt;  发出事件&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Subscribers-观察者-————————–-gt-订阅接收-进行处理&quot;&gt;&lt;a href=&quot;#Subscribers-观察者-————————–-gt-订阅接收-进行处理&quot; class=&quot;headerlink&quot; title=&quot;Subscribers(观察者) ————————–&amp;gt; 订阅接收,进行处理&quot;&gt;&lt;/a&gt;Subscribers(观察者) ————————–&amp;gt; 订阅接收,进行处理&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似观察者模式,不同之处在于： 如果没有Subscribers，Observables是不会发出任何事件。&lt;/p&gt;
&lt;p&gt;更接近于观察者模式 + 迭代器模式 , 这样的模式组合可以确保每一个事件都能发送到Subscribers上进行处理。&lt;/p&gt;
&lt;p&gt;不过与迭代器模式不同之处在于 ： 迭代器模式在事件处理上采用的是“同步/拉式”的方式，而Observable采用的是”异步/推式”的方式&lt;/p&gt;
&lt;h2 id=&quot;基本实现&quot;&gt;&lt;a href=&quot;#基本实现&quot; class=&quot;headerlink&quot; title=&quot;基本实现&quot;&gt;&lt;/a&gt;基本实现&lt;/h2&gt;&lt;h4 id=&quot;1-创建Observer&quot;&gt;&lt;a href=&quot;#1-创建Observer&quot; class=&quot;headerlink&quot; title=&quot;1)  创建Observer&quot;&gt;&lt;/a&gt;1)  创建Observer&lt;/h4&gt;&lt;p&gt;可以通过两种方式进行观察者对象的创建: Observer 和 Subscriber&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Observer&amp;lt;Strting&amp;gt; observer = new Observer&amp;lt;String&amp;gt;(){
    @override
    public void onNext(String s){
        //todo 
    }

    @override
    public void onCompleted(){
        //todo
    }

    @override
    public void onError(Throwable e){
        //todo
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Subscriber&amp;lt;String&amp;gt; subscriber = new Subscriber&amp;lt;String&amp;gt;(){
    @override
    public void onNext(String s){
        //todo
    }

    @override
    public void onCompleted(){
        //todo
    }

    @override
    public void onError(){
        //todo
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;区别: &lt;/p&gt;
&lt;p&gt;(1) onStart() 这是Subscriber增加的方法,会在事件未发送之前被调用,该方法是可选方法。需记住该方法所在的线程和subscribe      所发生的线程是一致的。&lt;/p&gt;
&lt;p&gt;(2) unsubscribe() 这是Subscriber所实现的另一个接口方法,用于取消订阅.该方法被调用后,Subscriber不再接收任何事件,一般    在此方法调用前,先进行isUnsubscribed()判断一下.这个方法的重要性在于能有效降低Observable持有Subscriber的引用而造    成的内存泄漏问题&lt;/p&gt;
&lt;h4 id=&quot;2-创建Observable&quot;&gt;&lt;a href=&quot;#2-创建Observable&quot; class=&quot;headerlink&quot; title=&quot;2)  创建Observable&quot;&gt;&lt;/a&gt;2)  创建Observable&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;Observable observable = Observable.create(
    new Observable.OnSubscribe&amp;lt;String&amp;gt;(){
        @override
        public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber){
            subscriber.onNext();
            subscriber.onNext();
            subscriber.onNext();
            subscriber.onCompleted();
        }
    }
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里传入一个OnSubscribe对象作为参数,该对象会被存储在返回的Observable对象中.它的作用类似于一个计划表，当Observable被订阅时，OnSubscribe的call()方法会自动被调用，事件序列会依照设定顺序依次触发。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。&lt;/p&gt;
&lt;p&gt;这里create()方法是RxJava最基本的创造事件序列的方法.当然也还有其他快捷创建事件序列方式，如下：&lt;/p&gt;
&lt;h5 id=&quot;just-T…-将传入的参数依次发送出来&quot;&gt;&lt;a href=&quot;#just-T…-将传入的参数依次发送出来&quot; class=&quot;headerlink&quot; title=&quot;just(T…)  将传入的参数依次发送出来&quot;&gt;&lt;/a&gt;just(T…)  将传入的参数依次发送出来&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Observable observable = Observable.just(&amp;quot;AA&amp;quot;,&amp;quot;BB&amp;quot;,&amp;quot;CC&amp;quot;);
// 将会依次调用:
// onNext(&amp;quot;AA&amp;quot;);
// onNext(&amp;quot;BB&amp;quot;);
// onNext(&amp;quot;CC&amp;quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;from-T-from-Iterable-lt-extends-T-gt-将传入的数组或Iterable拆分成具体的对象后-依次发送出来&quot;&gt;&lt;a href=&quot;#from-T-from-Iterable-lt-extends-T-gt-将传入的数组或Iterable拆分成具体的对象后-依次发送出来&quot; class=&quot;headerlink&quot; title=&quot;from(T[]) / from(Iterable&amp;lt;? extends T&amp;gt;)  将传入的数组或Iterable拆分成具体的对象后,依次发送出来&quot;&gt;&lt;/a&gt;from(T[]) / from(Iterable&amp;lt;? extends T&amp;gt;)  将传入的数组或Iterable拆分成具体的对象后,依次发送出来&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;String[] words = {&amp;quot;AA&amp;quot;,&amp;quot;BB&amp;quot;,&amp;quot;CC&amp;quot;};
Observable observable = Observable.from(words);
// 将会依次调用:
// onNext(&amp;quot;AA&amp;quot;);
// onNext(&amp;quot;BB&amp;quot;);
// onNext(&amp;quot;CC&amp;quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种方式都和create()方式是等价的&lt;/p&gt;
&lt;h4 id=&quot;3-订阅Subscribe&quot;&gt;&lt;a href=&quot;#3-订阅Subscribe&quot; class=&quot;headerlink&quot; title=&quot;3)  订阅Subscribe&quot;&gt;&lt;/a&gt;3)  订阅Subscribe&lt;/h4&gt;&lt;p&gt;创建了Observable 和 Observer对象之后，用subscribe()方法将其联结, 整条链子就能执行工作。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;observable.subscribe(observer);
// 或者
observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部代码实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Subscription subscribe(Subscriber subscriber){
    subscriber.onStart();
    onSubscribe.call(subscriber);
    return subscriber;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;subscriber()主要负责三件事:&lt;/p&gt;
&lt;p&gt;1) 调用Subscriber.onStart()&lt;/p&gt;
&lt;p&gt;————— 这个方法之前描述过,是一个可选方法&lt;/p&gt;
&lt;p&gt;2) 调用Observable的OnSubscribe.call(Subscriber)&lt;/p&gt;
&lt;p&gt;————— 这里事件的发送逻辑开始执行，从这里看出，在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在被订阅时，即当subscribe()方法执行的时候发送。&lt;/p&gt;
&lt;p&gt;3）将传入的Subscriber作为Subscription返回&lt;/p&gt;
&lt;p&gt;————— 这是为方便unsubscribe()。&lt;/p&gt;
&lt;p&gt;除了subscribe(Observable) 和 subscribe(Subscriber) , subscribe() 还支持不完整定义的回调,RxJava会自动根据定义创建出Subscriber。形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;(){

    // onNext()
    @override
    public void call(String s){
        //todo
    }
};

Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;(){

    //onError
    @override
    public void call(Throwable e){
        //todo error handling
    }
};

Action0 onCompletedAction = new Action0(){

    //onCompleted()
    @override
    public void call(){
        //todo
    }
}

// 自动创建 Subscriber, 并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);

// 自动创建 Subscriber, 并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);

// 自动创建 Subscriber, 并使用 onNextAction 、 onErrorAction 和 onCompletedAction 来定义 onNext() 、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注&quot;&gt;&lt;a href=&quot;#注&quot; class=&quot;headerlink&quot; title=&quot;注:&quot;&gt;&lt;/a&gt;注:&lt;/h3&gt;&lt;p&gt;Action0 是RxJava的一个接口，它只有一个call()，这个方法是无参无返回值的；&lt;/p&gt;
&lt;p&gt;onCompleted()方法也是无参无返回值，因此Action0 可以被当成是一个包装对象;&lt;/p&gt;
&lt;p&gt;Action1 也是一个接口,也只有一个call(T param), 这个方法也没有返回值, 但有参数；&lt;/p&gt;
&lt;p&gt;onNext(obj)方法 和 onError(error) 方法 均可以被当成是一个包装对象&lt;/p&gt;
&lt;h2 id=&quot;线程控制-Scheduler&quot;&gt;&lt;a href=&quot;#线程控制-Scheduler&quot; class=&quot;headerlink&quot; title=&quot;线程控制 - Scheduler&quot;&gt;&lt;/a&gt;线程控制 - Scheduler&lt;/h2&gt;&lt;p&gt;在不指定线程的情况下, RxJava遵循的是线程不变的原则, 即: &lt;/p&gt;
&lt;p&gt;在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如需切换线程，就需要Scheduler(调度器)&lt;/p&gt;
&lt;h4 id=&quot;1）-Scheduler-API&quot;&gt;&lt;a href=&quot;#1）-Scheduler-API&quot; class=&quot;headerlink&quot; title=&quot;1） Scheduler API&quot;&gt;&lt;/a&gt;1） Scheduler API&lt;/h4&gt;&lt;p&gt;Scheduler － 调度器，相当于线程控制器，RxJava通过它来指定每一段代码应该运行在哪一个线程中。RxJava内置了一些Scheduler，适用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Schedulers.immediate(): 直接在当前线程中运行，默认的Scheduler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.newThread(): 总是启用新线程,并在新线程中执行操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.io: I/O操作(读写文件、读写数据库、网络信息交互等)所使用的Scheduler；类似于newThread()，区别在io()的内部实现是使用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。记住：不要把计算放在io()中，可以避免创建不必要的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.computation(): 计算Scheduler。这个计算指CPU密集型计算，即不会被I/O等操作限制性能的操作，比如图形的计算。该Scheduler使用固定的线程池，大小为CPU核数。切记，不要把I/O操作放在computation()中,否则I/O操作的等待时间会浪费CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外Android还有一个专用的AndroidSchedulers.mainThread()，它指定的操作将在Android主线程中运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了上述Scheduler，就可以使用subscribeOn() 和 observerOn() 来控制线程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;subscribeOn(): 指定subscribe()所发生的线程，即Observable.OnSubscribe 被激活时所在的线程/事件产生的线程。

observeOn(): 指定Subscriber所运行的线程/事件消费的线程。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Observable.just(1,2,3,4)
    .subscribeOn(Schedulers.io()) // 指定 subscribe()发生在 IO 线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定Scheduler 的回调发生在主线程中
    .subscribe(new Action1&amp;lt;Integer&amp;gt;(){
        @override
        public void call(Integer number){
            //todo
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种在subscribe()之前写上线程控制的多适用于 『后台线程取数据，主线程显示』的程序策略。&lt;/p&gt;
&lt;h4 id=&quot;2-Scheduler-原理&quot;&gt;&lt;a href=&quot;#2-Scheduler-原理&quot; class=&quot;headerlink&quot; title=&quot;2) Scheduler 原理&quot;&gt;&lt;/a&gt;2) Scheduler 原理&lt;/h4&gt;&lt;h1 id=&quot;TBD&quot;&gt;&lt;a href=&quot;#TBD&quot; class=&quot;headerlink&quot; title=&quot;TBD&quot;&gt;&lt;/a&gt;TBD&lt;/h1&gt;&lt;h2 id=&quot;变换&quot;&gt;&lt;a href=&quot;#变换&quot; class=&quot;headerlink&quot; title=&quot;变换&quot;&gt;&lt;/a&gt;变换&lt;/h2&gt;&lt;p&gt;RxJava提供了对事件序列进行变换的支持&lt;/p&gt;
&lt;p&gt;所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。&lt;/p&gt;
&lt;h4 id=&quot;（1）API&quot;&gt;&lt;a href=&quot;#（1）API&quot; class=&quot;headerlink&quot; title=&quot;（1）API&quot;&gt;&lt;/a&gt;（1）API&lt;/h4&gt;&lt;p&gt;首先看map()示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Observable.just(&amp;quot;image/ic_launcher.png&amp;quot;) // 输入类型 String
    .map(new Func1&amp;lt;String, Bitmap&amp;gt;(){
        @override
        public Bitmap call(String filePath){ // 参数类型 Strting
            return getBitmapFromPath(filePath); // 返回类型
        }
    })
    .subscribe(new Action1&amp;lt;Bitmap&amp;gt;(){
        @override
        public void call(Bitmap bitmap){ // 参数类型 Bitmap
            showBitmap(bitmap);
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注-1&quot;&gt;&lt;a href=&quot;#注-1&quot; class=&quot;headerlink&quot; title=&quot;注&quot;&gt;&lt;/a&gt;注&lt;/h3&gt;&lt;p&gt;类Func1，也是RxJava的一个接口，用于包装含有一个参数的方法。&lt;/p&gt;
&lt;p&gt;FuncX 和 ActionX 区别，FuncX包装的是有返回值的方法&lt;/p&gt;
&lt;h3 id=&quot;常用变换&quot;&gt;&lt;a href=&quot;#常用变换&quot; class=&quot;headerlink&quot; title=&quot;#常用变换&quot;&gt;&lt;/a&gt;#常用变换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;map() —————– 事件对象的直接变换，是RxJava最为常用的变换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flatMap()————– 事件对象的扁平变换，是map()的升级版&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解释: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将Observable发射的数据变换为Observables集合,然后将Observab发射的数据 『铺平化』放进一个单独的Observable中。 可以理解为将嵌套的数据结构展开的过程。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map() 和 flatMap() 区别:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;相同: 均可以把传入的参数转化之后返回另一个对象

不同: flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到Subscriber的回调方法中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flatMap() 原理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、 利用传入的事件对象创建一个Observable对象

2、 不发送这个Observable对象，而是将其激活，再开始发送事件

3、 每一个创建出来的Observable发送的事件，都被汇总到同一个Observable，再由这个汇总Observable对象负责将这些事件统一交给Subscriber的回调方法
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个步骤,其实是将事件拆成了两级,通过一组新创建Observable将初始的对象『铺平』之后，通过统一的路径分发下去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;throttleFirst() ——– 在每次事件触发之后的一定时间间隔内丢弃新的事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用作去抖动过滤，例如按钮的点击监听器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RxView.clickEvents(button) 
    .throttleFirst(500, TimeUnitMILLISECONDS)  //设置防抖间隔 500ms
    .subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以解决手抖出现点开两个重复的界面问题&lt;/p&gt;
&lt;h4 id=&quot;（2）变换的原理-lift&quot;&gt;&lt;a href=&quot;#（2）变换的原理-lift&quot; class=&quot;headerlink&quot; title=&quot;（2）变换的原理: lift()&quot;&gt;&lt;/a&gt;（2）变换的原理: lift()&lt;/h4&gt;&lt;p&gt;变换的实质： 针对事件序列的处理和再发送&lt;/p&gt;
&lt;p&gt;lift() 内部实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public &amp;lt;R&amp;gt; Observable&amp;lt;R&amp;gt; lift(Operator&amp;lt;? extends R, ? super T&amp;gt; operator){
    return Observable.create(new OnSubscribe&amp;lt;R&amp;gt;(){
        @override
        public void call(Subscriber subscriber){
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;生成一个新的Observable并返回，且新创建的Observable所用的参数OnSubscribe的回调方法call()中的onSubscribe.call(subscribe)中的onSubscribe所指代的对象不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;subscribe()中onSubscribe指的是Observable中的onSubscribe对象,但是lift()之后对象就不一样;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当含有lift()时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. lift()创建了一个Observable后，加上原Observable对象，就有两个Observable；
2. 新Observable里的新OnSubscribe加上原Observable中的OnSubscribe，也就有两个OnSubscribe;
3. 当用户调用经过lift()后的Observable的subscribe()时候,使用的是lift()所返回的新的Observable,
   于是它所触发的onSubscribe.call(subscribe)，也是用的新Observable中的OnSubscribe，即在lift()中生成的那个Observable;
4. 而这个新OnSubscribe的call()方法中的onSubscribe，就是指的原始Observable中的原始OnSubscribe，
   在这个call()方法里，新OnSubscribe利用operator.call(subscribe)生成一个新的Subscriber
   (operator就是在这里，通过自己的call()方法将新Subscribe和原始Subscriber进行关联，并插入自己的『变换』代码来实现变换)，
   接着利用这个新Subscriber向原始Observable进行订阅。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就实现lift()过程，比较像代理机制，通过事件拦截和处理实现事件序列的变换。&lt;/p&gt;
&lt;p&gt;换种方式理解： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在Observable执行了lift(Operator)方法之后，会返回一个新的Observable，
这个新的Observable会向代理一样， 负责接收原始的Observable发出的事件，并在处理之后发送给Subscriber。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##未完待续。。。&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=94639&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;a library for composing asynchronous and event-based programs using observable sequences for the Java VM&lt;/p&gt;
&lt;p&gt;一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android部落格之Retrofit框架</title>
    <link href="http://tufusi.com/2016/06/02/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRetrofit%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/02/Android部落格之Retrofit框架/</id>
    <published>2016-06-02T01:23:58.000Z</published>
    <updated>2016-06-02T01:23:58.913Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android部落格之OkHttp框架</title>
    <link href="http://tufusi.com/2016/06/01/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BOkHttp%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/01/Android部落格之OkHttp框架/</id>
    <published>2016-06-01T02:20:47.000Z</published>
    <updated>2016-08-07T07:22:36.697Z</updated>
    
    <content type="html">&lt;p&gt;来自&lt;a href=&quot;http://square.github.io/okhttp/#examples&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OkHttp官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.piasy.com/img/201607/okhttp_full_process.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;整体流程图-参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官网概述：Android和Java应用程序的HTTP&amp;amp;HTTP/2的客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h3&gt;&lt;h4 id=&quot;1、创建OkHttpClint对象&quot;&gt;&lt;a href=&quot;#1、创建OkHttpClint对象&quot; class=&quot;headerlink&quot; title=&quot;1、创建OkHttpClint对象&quot;&gt;&lt;/a&gt;1、创建OkHttpClint对象&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;OkHttpClient client = new OkHttpClient();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然也可以通过Build构造自定义的Http客户端&lt;/p&gt;
&lt;h4 id=&quot;2、发起HTTP请求&quot;&gt;&lt;a href=&quot;#2、发起HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;2、发起HTTP请求&quot;&gt;&lt;/a&gt;2、发起HTTP请求&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;String run() throws IOException{
    Request request = new Request.Builder()
      .url(url)
       .build(); 

    Response response = client.newCall(request).execute();
    return response.body().string();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OkHttpClient实现了Call.Factory, 它是负责创建HTTP请求,负责根据请求创建新的Call,代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Prepares the {@code request} to be executed at some point in the future.
 */
@override
public Call newCall(Request request){
    return new RealCall(this,request);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面针对RealCall,分情况研究:&lt;/p&gt;
&lt;h5 id=&quot;2-1-同步网络请求&quot;&gt;&lt;a href=&quot;#2-1-同步网络请求&quot; class=&quot;headerlink&quot; title=&quot;2.1 同步网络请求&quot;&gt;&lt;/a&gt;2.1 同步网络请求&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;@override
public Response execute() throws IOException{
    synchronized(this){
        if(executed) -------------------------------------------------------------(1)
            throws new IllegalStateException(&amp;quot;Already Exceuted&amp;quot;); 
        executed = true;
    }
    try{
        client.dispatcher().exedcuted(this); -------------------------------------(2)
        Response result = getResponseWithInterceptorChain(); ---------------------(3)
        if(result == null)
            throws new IOException(&amp;quot;Canceled&amp;quot;);
        return result;
    }finally{
        client.dispatcher().finished(this); --------------------------------------(4)
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;步骤分解:&lt;/p&gt;
&lt;p&gt;(1): 检查这个call是否已经执行过，每个call只能被执行一次&lt;/p&gt;
&lt;p&gt;(2): 利用client.dispatcher().executed(this)来实际执行请求&lt;/p&gt;
&lt;p&gt;(3): 调用函数获取HTTP响应结果,在这个过程中还会进行一个拦截链操作&lt;/p&gt;
&lt;p&gt;(4): 通知dispatcher执行完毕&lt;/p&gt;
&lt;p&gt;而真正发出网络请求,解析返回结果的,还是getResponseWithInterceptorChain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Response getResponseWithInterceptorChain() throws IOException{
    //Build a full stack of interceptors
    List&amp;lt;Interceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if(!retryAndFollowUpInterceptor.isForWebSocket()){
        interceptors.addAll(client.networkInterceptors());
    }

    interceptors.add(
        new CallServerInterceptor(
            retryAndFollowUpInterceptor.isForWebSocket()));
    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors,null,null,null,0,originalRequest);

    return chain.proceed(originalRequest);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Interceptor其实是最核心的一个东西,并非简简单单的拦截器,它把实际的网络请求、缓存等等功能全部统一起来，每个功能都只是一个Interceptor,再连接成一个Interceptor.Chain,最终完成一次圆满的网络请求.&lt;/p&gt;
&lt;p&gt;依照上面代码块,Interceptor.Chain的分布:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;blog.piasy.com/img/201607/okhttp_interceptors.png&quot;&gt;结构图&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.在配置OkHttpClient时设置的interceptors;

2.负责失败重试以及重定向的RetryAndFollowUpInterceptor;

3.负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的BridgeInterceptor;

4.负责人读取缓存直接返回、更新缓存的CacheInterceptor;

5.负责和服务器建立连接的ConnectInterceptor;

6.配置OkHttpClient时设置的networkInterceptors;

7.负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里位置决定功能，最后一个Interceptor一定是负责和服务器实现通信的，而重定向、缓存等一定是在通信之前完成。&lt;/p&gt;
&lt;h6 id=&quot;2-1-1-建立连接-ConnectInterceptor&quot;&gt;&lt;a href=&quot;#2-1-1-建立连接-ConnectInterceptor&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 建立连接:ConnectInterceptor&quot;&gt;&lt;/a&gt;2.1.1 建立连接:ConnectInterceptor&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;@override
public Response intercept(Chain chain) throws IOException{
    RealInterceptorChain realChain = (RealInterceptorChain)chain;
    Request request  = realChain.request();
    StreamAllocation streamAllocation = realChain.streamAllocation();

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    boolean doExtensiveHealthChecks = !request.method().equals(&amp;quot;GET&amp;quot;);
    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
    RealConnection connection = streamAllocation.connection();

    return realChain.proceed(request, streamAllocation, httpCodec, connection);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建立连接其实就是创建HttpCodec对象,HttpCodec是对HTTP协议操作的抽象,在HttpCodec中,它利用Okio对socket的读写操作进行封装.&lt;/p&gt;
&lt;h6 id=&quot;2-1-2-发送和接收数据-CallServerInterceptor&quot;&gt;&lt;a href=&quot;#2-1-2-发送和接收数据-CallServerInterceptor&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 发送和接收数据:CallServerInterceptor&quot;&gt;&lt;/a&gt;2.1.2 发送和接收数据:CallServerInterceptor&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;@override
public Response intercept(Chain chain) throws IOException{
    HttpCodec httpCodex = ((RealInterceptorChain)chain).httpStream();
    StreamAllocation streamAllocation = ((RealInterceptorChain)chain).streamAllocation();
    Request request = chain.request();

    long sentRequestMillis = System.currentTimeMillis();
    httpCodec.writeRequestHeaders(request); ----------------------------------------------------------(1)

    if(HttpMethod.permitsRequestBody(request.method()) &amp;amp;&amp;amp; request.body()!=null){ ---------------------(2)
        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
        request.body().writeTo(bufferedRequestBody);
        bufferedRequestBody.close();
    }

    httpCodec.finishRequest();

    Response response = httpCodec.readResponseHeaders() ----------------------------------------------(3)
          .request(request)
          .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();

    if (!forWebSocket || response.code() != 101) {
        response = response.newBuilder() -------------------------------------------------------------(4)
            .body(httpCodec.openResponseBody(response))
            .build();
    }

    if (&amp;quot;close&amp;quot;.equalsIgnoreCase(response.request().header(&amp;quot;Connection&amp;quot;))
          || &amp;quot;close&amp;quot;.equalsIgnoreCase(response.header(&amp;quot;Connection&amp;quot;))) {
        streamAllocation.noNewStreams();
    }

    // 省略部分检查代码

    return response;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要部分:&lt;/p&gt;
&lt;p&gt;1.向服务器发送request header;&lt;/p&gt;
&lt;p&gt;2.如果有request body，就向服务器发送;&lt;/p&gt;
&lt;p&gt;3.读取response header，先构造一个Response对象;&lt;/p&gt;
&lt;p&gt;4.如果有response body,就在3的基础上加上body构造一个新的Response对象&lt;/p&gt;
&lt;h5 id=&quot;2-2-异步网络请求-详见Dispatcher-java&quot;&gt;&lt;a href=&quot;#2-2-异步网络请求-详见Dispatcher-java&quot; class=&quot;headerlink&quot; title=&quot;2.2 异步网络请求 - 详见Dispatcher.java&quot;&gt;&lt;/a&gt;2.2 异步网络请求 - 详见Dispatcher.java&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;client.newCall(request).enqueue(new Callback(){
    @override
    public void onFailure(Call call, IOException e){
    }

    @override
    public void onResponse(Call call, Response response) throws IOException{
        System.out.println(response.body().string());
    }
});

//RealCall#enqueue
@override
public void enqueue(Callback responseCallback){
    synchronized(this){
        if(executed) throws new IllegalStateException(&amp;quot;Already Executed&amp;quot;);
        executed = true;
    }
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
}

//Dispatcher#enqueue
synchronized void enqueue(AsyncCall call){
    if(runningAsyncCalls.size()&amp;lt;maxRequests &amp;amp;&amp;amp;　runningCallForHost(call)&amp;lt;maxRequestsPerHost){
        runningAsyncCalls.add(call);
        executorService().execute(call);
    }else{
        readyAsyncCalls.add(call);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此处可以看到dispatcher在异步执行请求过程中的作用.如果当前还能执行一个并发请求,那就立即执行,否则就加入readyAsyncCalls队列,而正在执行的请求执行完毕之后,会调用promoteCalls()函数,来迭代readyAsyncCalls队列,next()出AsyncCall,并将AsyncCall加入到runningAsyncCalls队列中,开始执行.&lt;/p&gt;
&lt;p&gt;AsyncCall是RealCall的一个innerClass,继承NamedRunnable抽象类,该抽象类实现了Runnable接口,功能是设置线程名称.所以AsyncCall其实就是被OkHttp命名规范的一个异步请求类,它可以被提交到ExecutorService上执行,在执行时会调用getResponseWithInterceptorChain()函数,并将结果通过responseCallback回调传递给上层使用.&lt;/p&gt;
&lt;p&gt;如此,同步和异步其实原理是一样的,都是在getResponseWithInterceptorChain()函数中通过Interceptor链来实现网络请求逻辑,而异步则是通过ExecutorService来实现的.&lt;/p&gt;
&lt;h4 id=&quot;3、获取响应数据&quot;&gt;&lt;a href=&quot;#3、获取响应数据&quot; class=&quot;headerlink&quot; title=&quot;3、获取响应数据&quot;&gt;&lt;/a&gt;3、获取响应数据&lt;/h4&gt;&lt;p&gt;在同步(Call#execute()执行之后)或者异步(Callback#onResponse()回调中)请求完成之后,可以从Respouse对象中华获取到响应数据,包括HTTP status code, status message, response header, response body等等.这里的body需通过数据流方式来进行访问。&lt;/p&gt;
&lt;p&gt;响应body被封装到 ResponseBody类中,需注意亮点:&lt;/p&gt;
&lt;p&gt;1) 每个body只能被消费一次,多次消费会抛出异常;&lt;/p&gt;
&lt;p&gt;2) body必须被关闭,否则会发生资源泄漏&lt;/p&gt;
&lt;h4 id=&quot;4、HTTP缓存&quot;&gt;&lt;a href=&quot;#4、HTTP缓存&quot; class=&quot;headerlink&quot; title=&quot;4、HTTP缓存&quot;&gt;&lt;/a&gt;4、HTTP缓存&lt;/h4&gt;&lt;p&gt;在建立连接、和服务器通信之前，就是CacheInterceptor,在建立连接之前,我们检查响应是否已经被缓存、缓存是否可用，如果是则直接返回缓存的数据，否则就进行后面的流程，并在返回之前，把网络的数据写入缓存中。&lt;/p&gt;
&lt;p&gt;CacheInterceptor类里主要逻辑都在覆写的intercept方法里,通过缓存策略获取networkRequest和cacheResponse进行检查判断,也可以通过实现InternalCache接口,在构造OkHttpClient时进行设置,这样就可以自定义缓存策略了。&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=28188171&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;来自&lt;a href=&quot;http://square.github.io/okhttp/#examples&quot;&gt;OkHttp官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.piasy.com/img/201607/okhttp_full_process.png&quot;&gt;整体流程图-参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官网概述：Android和Java应用程序的HTTP&amp;amp;HTTP/2的客户端&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTTP Client" scheme="http://tufusi.com/categories/HTTP-Client/"/>
    
    
      <category term="技术" scheme="http://tufusi.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络通信" scheme="http://tufusi.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>十里平湖霜满天</title>
    <link href="http://tufusi.com/2016/05/31/%E5%8D%81%E9%87%8C%E5%B9%B3%E6%B9%96%E9%9C%9C%E6%BB%A1%E5%A4%A9/"/>
    <id>http://tufusi.com/2016/05/31/十里平湖霜满天/</id>
    <published>2016-05-31T09:27:09.000Z</published>
    <updated>2016-05-31T09:28:15.759Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="闲心 品读 人生" scheme="http://tufusi.com/tags/%E9%97%B2%E5%BF%83-%E5%93%81%E8%AF%BB-%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
