<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OnePiece</title>
  <subtitle>Some of life, you have to go to the great challanges. - By Kobe Bryant</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tufusi.com/"/>
  <updated>2016-06-20T15:09:23.648Z</updated>
  <id>http://tufusi.com/</id>
  
  <author>
    <name>LeoCheung</name>
    <email>leocheung4ever@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优秀第三方SDK分析-Fresco</title>
    <link href="http://tufusi.com/2016/06/20/%E4%BC%98%E7%A7%80%E7%AC%AC%E4%B8%89%E6%96%B9SDK%E5%88%86%E6%9E%90-Fresco/"/>
    <id>http://tufusi.com/2016/06/20/优秀第三方SDK分析-Fresco/</id>
    <published>2016-06-20T15:09:23.000Z</published>
    <updated>2016-06-20T15:09:23.648Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android优化交互-协调布局详解</title>
    <link href="http://tufusi.com/2016/06/20/Android%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%8D%8F%E8%B0%83%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tufusi.com/2016/06/20/Android优化交互-协调布局详解/</id>
    <published>2016-06-20T14:59:11.000Z</published>
    <updated>2016-06-20T14:59:11.581Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android优化交互-嵌套机制详解</title>
    <link href="http://tufusi.com/2016/06/20/Android%E4%BC%98%E5%8C%96%E4%BA%A4%E4%BA%92-%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tufusi.com/2016/06/20/Android优化交互-嵌套机制详解/</id>
    <published>2016-06-20T14:57:42.000Z</published>
    <updated>2016-06-20T14:57:42.742Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio之Plugins</title>
    <link href="http://tufusi.com/2016/06/14/AndroidStudio%E4%B9%8BPlugins/"/>
    <id>http://tufusi.com/2016/06/14/AndroidStudio之Plugins/</id>
    <published>2016-06-14T13:10:00.000Z</published>
    <updated>2016-06-14T13:10:00.135Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio之Gradle</title>
    <link href="http://tufusi.com/2016/06/07/AndroidStudio%E4%B9%8BGradle/"/>
    <id>http://tufusi.com/2016/06/07/AndroidStudio之Gradle/</id>
    <published>2016-06-07T11:31:22.000Z</published>
    <updated>2016-06-19T06:24:30.132Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Gradle-概述&quot;&gt;&lt;a href=&quot;#Gradle-概述&quot; class=&quot;headerlink&quot; title=&quot;Gradle 概述&quot;&gt;&lt;/a&gt;Gradle 概述&lt;/h3&gt;&lt;p&gt;是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – &lt;a href=&quot;https://en.wikipedia.org/wiki/Groovy_(programming_language&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Groovy&lt;/a&gt;) 编写而成，再加上&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DSL（领域特定语言）&lt;/a&gt;组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;analysis-in-AS&quot;&gt;&lt;a href=&quot;#analysis-in-AS&quot; class=&quot;headerlink&quot; title=&quot;analysis in AS&quot;&gt;&lt;/a&gt;analysis in AS&lt;/h4&gt;&lt;p&gt;Android Studio新建一个工程后，默认生成两个build.gralde文件，一个位于project根目录下，一个位于app目录下。除此还有一个文件settings.gradle。&lt;/p&gt;
&lt;p&gt;根目录下的脚本文件是针对module的全局配置，它的作用域内包含的所有 module 是通过settings.gradle来配置。app文件夹就是一个module，如果在当前project中新增Module – library，就要在settings.gralde文件中包含这个新的module。&lt;/p&gt;
&lt;p&gt;当然很多朋友我相信在新建项目以及库的时候更多是通过右键建立的，这样更加方便，但要知晓其中的原理，对于熟悉gradle构建系统来说是不可或缺的。&lt;/p&gt;
&lt;h3 id=&quot;gradle脚本的基本结构&quot;&gt;&lt;a href=&quot;#gradle脚本的基本结构&quot; class=&quot;headerlink&quot; title=&quot;gradle脚本的基本结构&quot;&gt;&lt;/a&gt;gradle脚本的基本结构&lt;/h3&gt;&lt;p&gt;用新建工程为例，根目录的build.gradle的内容如下所示：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Top-level build file &lt;span class=&quot;built_in&quot;&gt;where&lt;/span&gt; you can add configuration options common to all sub-projects/modules.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buildscript &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jcenter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classpath &lt;span class=&quot;string&quot;&gt;&#39;com.android.tools.build:gradle:2.1.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // NOTE: Do not place your application dependencies here; they belong&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the individual module build.gradle files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;allprojects &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jcenter(）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;task clean(&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: Delete) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delete rootProject.buildDir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后是 settings.gradle 文件：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &lt;span class=&quot;string&quot;&gt;&#39;:app&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;app就是应用程序的一个module，如果有多个module，可以在为 include 方法添加多个参数，并以逗号隔开。&lt;/p&gt;
&lt;p&gt;最后是app/build.gradle&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apply plugin: &lt;span class=&quot;string&quot;&gt;&#39;com.android.application&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compileSdkVersion 23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildToolsVersion &lt;span class=&quot;string&quot;&gt;&quot;23.0.3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    defaultConfig &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        applicationId &lt;span class=&quot;string&quot;&gt;&quot;app full name&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        minSdkVersion 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        targetSdkVersion 23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        versionCode 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        versionName &lt;span class=&quot;string&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signingConfigs &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storeFile file(&lt;span class=&quot;string&quot;&gt;&#39;release.keystore&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storePassword &lt;span class=&quot;string&quot;&gt;&quot;yourstorepassword&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            keyAlias &lt;span class=&quot;string&quot;&gt;&quot;yourkeyalias&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            keyPassword &lt;span class=&quot;string&quot;&gt;&quot;yourkeypassword&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        debug &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            storeFile file(&lt;span class=&quot;string&quot;&gt;&#39;debug.keystore&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buildTypes &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        release &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minifyEnabled &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proguardFiles getDefaultProguardFile(&lt;span class=&quot;string&quot;&gt;&#39;proguard-android.txt&#39;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;proguard-rules.pro&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            signingConfig signingConfigs.release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        debug &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            signingConfig signingConfigs.debug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    productFlavors &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        market &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Wandoujia &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile fileTree(dir: &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;, include: [&lt;span class=&quot;string&quot;&gt;&#39;*.jar&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;Compile &lt;span class=&quot;string&quot;&gt;&#39;junit:junit:4.12&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile &lt;span class=&quot;string&quot;&gt;&#39;com.android.support:appcompat-v7:23.4.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Groovy 的基本语法&lt;br&gt;方法调用&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apply plugin: &lt;span class=&quot;string&quot;&gt;&#39;com.android.application&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上语句中的apply是一个方法，给它传递了一个参数plugin，plugin 的值是’com.android.application’。&lt;/p&gt;
&lt;p&gt;如果有多个参数，则以逗号隔开，例如&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile name: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;, ext: &lt;span class=&quot;string&quot;&gt;&#39;aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;闭包&lt;/p&gt;
&lt;p&gt;Groovy中花括号包含的部分成为一个闭包（Closure）。例如下面的代码&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;compileOptions 是一个 Method， 它的参数是一个闭包， 这个闭包内依次执行了两个方法 – sourceCompatibility 和targetCompatibility， 参数都是JavaVersion.VERSION_1_7,即是你jdk配置环境所使用的版本。&lt;/p&gt;
&lt;p&gt;闭包也可以嵌套包含&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;常见使用方法&quot;&gt;&lt;a href=&quot;#常见使用方法&quot; class=&quot;headerlink&quot; title=&quot;常见使用方法&quot;&gt;&lt;/a&gt;常见使用方法&lt;/h4&gt;&lt;h5 id=&quot;包依赖（aar）&quot;&gt;&lt;a href=&quot;#包依赖（aar）&quot; class=&quot;headerlink&quot; title=&quot;包依赖（aar）&quot;&gt;&lt;/a&gt;包依赖（aar）&lt;/h5&gt;&lt;p&gt;使用aar时可以分为两种情况&lt;br&gt;① aar位于本地目录&lt;/p&gt;
&lt;p&gt;首先在 Build.gradle(Module:app) 中 android 的参数闭包中添加调用方法 repositories&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;repositories &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flatDir &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;built_in&quot;&gt;dirs&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;libs&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后在 dependencies 的参数闭包中添加&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile name: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;, ext: &lt;span class=&quot;string&quot;&gt;&#39;aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;② aar位于远程仓库&lt;/p&gt;
&lt;p&gt;这里以maven为例，当然也可以使用其他类型的仓库，例如 Ivy、Bintray。&lt;/p&gt;
&lt;p&gt;只需要在jar包引用方式后面添加一个@aar就可以了&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4@aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;包依赖（jar）&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile group:&lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano&#39;&lt;/span&gt;,module: &lt;span class=&quot;string&quot;&gt;&#39;supertoasts&#39;&lt;/span&gt;,version: &lt;span class=&quot;string&quot;&gt;&#39;1.3.4&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以简写成&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;去掉重复依赖&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &lt;span class=&quot;string&quot;&gt;&#39;com.github.johnpersano:supertoasts:1.3.4&#39;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exclude module: &lt;span class=&quot;string&quot;&gt;&#39;annotations&#39;&lt;/span&gt;, group: &lt;span class=&quot;string&quot;&gt;&#39;com.google.android&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 Java7 或者 Java8&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compileOptions &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt;Compatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  targetCompatibility JavaVersion.VERSION_1_7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;针对JDK1.8, 等公司项目上线我会专门看一些这方面的资料进行博客整理，主要对RetroLambda结合RxJava的一些功能展示及Sourcecode理解&lt;/p&gt;
&lt;h5 id=&quot;productFlavors（渠道打包）&quot;&gt;&lt;a href=&quot;#productFlavors（渠道打包）&quot; class=&quot;headerlink&quot; title=&quot;productFlavors（渠道打包）&quot;&gt;&lt;/a&gt;productFlavors（渠道打包）&lt;/h5&gt;&lt;p&gt;该部分在项目完成上线之前，会将所看资料整合另开一篇文章说明。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;其实在使用Gradle构建时，如果项目引用的依赖过于多而杂，而又需要考虑到这些依赖版本的更新问题，参考过&lt;a href=&quot;http://blog.zhaiyifan.cn/2016/03/14/android-new-project-from-0-p2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MarkZhai&lt;/a&gt;的博客,本人也偏向于新建全局gradle，专门用于管理版本的迭代问题，不用一处改处处改，效果在试过之后会能明显feel到。&lt;/p&gt;
&lt;p&gt;刚来新公司，一个人负责项目从零起步到最后打包上线，不得不说，这是一个挑战，但这又何尝不是一个机会，目前还处于app开发阶段。在抛弃前公司一直沿用的Volley Network Framework之后，我一直在尝试着使用更多以前未接触过的技术，RxJava，Dagger，OkHttp+Retrofit，Stetho+GsonFormat and so on，包括这次的关于Gradle的博客书写，发现Gradle其实也蛮好（zhuang）用(bi)的！当然用这些新技术需要花不少的时间成本，但“ 总有人要赢的，那个人为什么不是我 ”， 爱豆科比的经典名言啊。&lt;br&gt;努力 奋斗 致每一位正在努力的小婊砸&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Gradle-概述&quot;&gt;&lt;a href=&quot;#Gradle-概述&quot; class=&quot;headerlink&quot; title=&quot;Gradle 概述&quot;&gt;&lt;/a&gt;Gradle 概述&lt;/h3&gt;&lt;p&gt;是可以用于Android开发的新一代的构建系统， 也是Android Studio默认的构建工具。其脚本是基于JVM语言 – &lt;a href=&quot;https://en.wikipedia.org/wiki/Groovy_(programming_language&quot;&gt;Groovy&lt;/a&gt;) 编写而成，再加上&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL（领域特定语言）&lt;/a&gt;组成的。因为Groovy是JVM语言，所以可以使用大部分的Java语言库。所谓DSL就是专门针对Android开发的插件，比如标准Gradle之外的一些新的方法（Method）、闭包（Closure）等。&lt;/p&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://tufusi.com/categories/Gradle/"/>
    
    
      <category term="Gradle，Android，BuildSystem" scheme="http://tufusi.com/tags/Gradle%EF%BC%8CAndroid%EF%BC%8CBuildSystem/"/>
    
  </entry>
  
  <entry>
    <title>Android部落格之RxJava框架</title>
    <link href="http://tufusi.com/2016/06/07/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRxJava%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/07/Android部落格之RxJava框架/</id>
    <published>2016-06-07T01:14:57.000Z</published>
    <updated>2016-08-07T07:20:43.262Z</updated>
    
    <content type="html">&lt;h1 id=&quot;RxJava&quot;&gt;&lt;a href=&quot;#RxJava&quot; class=&quot;headerlink&quot; title=&quot;RxJava&quot;&gt;&lt;/a&gt;RxJava&lt;/h1&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;a library for composing asynchronous and event-based programs using observable sequences for the Java VM&lt;/p&gt;
&lt;p&gt;一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Observables-被观察者-事件源-———–-gt-发出事件&quot;&gt;&lt;a href=&quot;#Observables-被观察者-事件源-———–-gt-发出事件&quot; class=&quot;headerlink&quot; title=&quot;Observables(被观察者/事件源) ———–&amp;gt;  发出事件&quot;&gt;&lt;/a&gt;Observables(被观察者/事件源) ———–&amp;gt;  发出事件&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Subscribers-观察者-————————–-gt-订阅接收-进行处理&quot;&gt;&lt;a href=&quot;#Subscribers-观察者-————————–-gt-订阅接收-进行处理&quot; class=&quot;headerlink&quot; title=&quot;Subscribers(观察者) ————————–&amp;gt; 订阅接收,进行处理&quot;&gt;&lt;/a&gt;Subscribers(观察者) ————————–&amp;gt; 订阅接收,进行处理&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似观察者模式,不同之处在于： 如果没有Subscribers，Observables是不会发出任何事件。&lt;/p&gt;
&lt;p&gt;更接近于观察者模式 + 迭代器模式 , 这样的模式组合可以确保每一个事件都能发送到Subscribers上进行处理。&lt;/p&gt;
&lt;p&gt;不过与迭代器模式不同之处在于 ： 迭代器模式在事件处理上采用的是“同步/拉式”的方式，而Observable采用的是”异步/推式”的方式&lt;/p&gt;
&lt;h2 id=&quot;基本实现&quot;&gt;&lt;a href=&quot;#基本实现&quot; class=&quot;headerlink&quot; title=&quot;基本实现&quot;&gt;&lt;/a&gt;基本实现&lt;/h2&gt;&lt;h4 id=&quot;1-创建Observer&quot;&gt;&lt;a href=&quot;#1-创建Observer&quot; class=&quot;headerlink&quot; title=&quot;1)  创建Observer&quot;&gt;&lt;/a&gt;1)  创建Observer&lt;/h4&gt;&lt;p&gt;可以通过两种方式进行观察者对象的创建: Observer 和 Subscriber&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Observer&amp;lt;Strting&amp;gt; observer = new Observer&amp;lt;String&amp;gt;(){
    @override
    public void onNext(String s){
        //todo 
    }

    @override
    public void onCompleted(){
        //todo
    }

    @override
    public void onError(Throwable e){
        //todo
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Subscriber&amp;lt;String&amp;gt; subscriber = new Subscriber&amp;lt;String&amp;gt;(){
    @override
    public void onNext(String s){
        //todo
    }

    @override
    public void onCompleted(){
        //todo
    }

    @override
    public void onError(){
        //todo
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;区别: &lt;/p&gt;
&lt;p&gt;(1) onStart() 这是Subscriber增加的方法,会在事件未发送之前被调用,该方法是可选方法。需记住该方法所在的线程和subscribe      所发生的线程是一致的。&lt;/p&gt;
&lt;p&gt;(2) unsubscribe() 这是Subscriber所实现的另一个接口方法,用于取消订阅.该方法被调用后,Subscriber不再接收任何事件,一般    在此方法调用前,先进行isUnsubscribed()判断一下.这个方法的重要性在于能有效降低Observable持有Subscriber的引用而造    成的内存泄漏问题&lt;/p&gt;
&lt;h4 id=&quot;2-创建Observable&quot;&gt;&lt;a href=&quot;#2-创建Observable&quot; class=&quot;headerlink&quot; title=&quot;2)  创建Observable&quot;&gt;&lt;/a&gt;2)  创建Observable&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;Observable observable = Observable.create(
    new Observable.OnSubscribe&amp;lt;String&amp;gt;(){
        @override
        public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber){
            subscriber.onNext();
            subscriber.onNext();
            subscriber.onNext();
            subscriber.onCompleted();
        }
    }
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里传入一个OnSubscribe对象作为参数,该对象会被存储在返回的Observable对象中.它的作用类似于一个计划表，当Observable被订阅时，OnSubscribe的call()方法会自动被调用，事件序列会依照设定顺序依次触发。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。&lt;/p&gt;
&lt;p&gt;这里create()方法是RxJava最基本的创造事件序列的方法.当然也还有其他快捷创建事件序列方式，如下：&lt;/p&gt;
&lt;h5 id=&quot;just-T…-将传入的参数依次发送出来&quot;&gt;&lt;a href=&quot;#just-T…-将传入的参数依次发送出来&quot; class=&quot;headerlink&quot; title=&quot;just(T…)  将传入的参数依次发送出来&quot;&gt;&lt;/a&gt;just(T…)  将传入的参数依次发送出来&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Observable observable = Observable.just(&amp;quot;AA&amp;quot;,&amp;quot;BB&amp;quot;,&amp;quot;CC&amp;quot;);
// 将会依次调用:
// onNext(&amp;quot;AA&amp;quot;);
// onNext(&amp;quot;BB&amp;quot;);
// onNext(&amp;quot;CC&amp;quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;from-T-from-Iterable-lt-extends-T-gt-将传入的数组或Iterable拆分成具体的对象后-依次发送出来&quot;&gt;&lt;a href=&quot;#from-T-from-Iterable-lt-extends-T-gt-将传入的数组或Iterable拆分成具体的对象后-依次发送出来&quot; class=&quot;headerlink&quot; title=&quot;from(T[]) / from(Iterable&amp;lt;? extends T&amp;gt;)  将传入的数组或Iterable拆分成具体的对象后,依次发送出来&quot;&gt;&lt;/a&gt;from(T[]) / from(Iterable&amp;lt;? extends T&amp;gt;)  将传入的数组或Iterable拆分成具体的对象后,依次发送出来&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;String[] words = {&amp;quot;AA&amp;quot;,&amp;quot;BB&amp;quot;,&amp;quot;CC&amp;quot;};
Observable observable = Observable.from(words);
// 将会依次调用:
// onNext(&amp;quot;AA&amp;quot;);
// onNext(&amp;quot;BB&amp;quot;);
// onNext(&amp;quot;CC&amp;quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种方式都和create()方式是等价的&lt;/p&gt;
&lt;h4 id=&quot;3-订阅Subscribe&quot;&gt;&lt;a href=&quot;#3-订阅Subscribe&quot; class=&quot;headerlink&quot; title=&quot;3)  订阅Subscribe&quot;&gt;&lt;/a&gt;3)  订阅Subscribe&lt;/h4&gt;&lt;p&gt;创建了Observable 和 Observer对象之后，用subscribe()方法将其联结, 整条链子就能执行工作。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;observable.subscribe(observer);
// 或者
observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部代码实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Subscription subscribe(Subscriber subscriber){
    subscriber.onStart();
    onSubscribe.call(subscriber);
    return subscriber;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;subscriber()主要负责三件事:&lt;/p&gt;
&lt;p&gt;1) 调用Subscriber.onStart()&lt;/p&gt;
&lt;p&gt;————— 这个方法之前描述过,是一个可选方法&lt;/p&gt;
&lt;p&gt;2) 调用Observable的OnSubscribe.call(Subscriber)&lt;/p&gt;
&lt;p&gt;————— 这里事件的发送逻辑开始执行，从这里看出，在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在被订阅时，即当subscribe()方法执行的时候发送。&lt;/p&gt;
&lt;p&gt;3）将传入的Subscriber作为Subscription返回&lt;/p&gt;
&lt;p&gt;————— 这是为方便unsubscribe()。&lt;/p&gt;
&lt;p&gt;除了subscribe(Observable) 和 subscribe(Subscriber) , subscribe() 还支持不完整定义的回调,RxJava会自动根据定义创建出Subscriber。形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;(){

    // onNext()
    @override
    public void call(String s){
        //todo
    }
};

Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;(){

    //onError
    @override
    public void call(Throwable e){
        //todo error handling
    }
};

Action0 onCompletedAction = new Action0(){

    //onCompleted()
    @override
    public void call(){
        //todo
    }
}

// 自动创建 Subscriber, 并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);

// 自动创建 Subscriber, 并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);

// 自动创建 Subscriber, 并使用 onNextAction 、 onErrorAction 和 onCompletedAction 来定义 onNext() 、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注&quot;&gt;&lt;a href=&quot;#注&quot; class=&quot;headerlink&quot; title=&quot;注:&quot;&gt;&lt;/a&gt;注:&lt;/h3&gt;&lt;p&gt;Action0 是RxJava的一个接口，它只有一个call()，这个方法是无参无返回值的；&lt;/p&gt;
&lt;p&gt;onCompleted()方法也是无参无返回值，因此Action0 可以被当成是一个包装对象;&lt;/p&gt;
&lt;p&gt;Action1 也是一个接口,也只有一个call(T param), 这个方法也没有返回值, 但有参数；&lt;/p&gt;
&lt;p&gt;onNext(obj)方法 和 onError(error) 方法 均可以被当成是一个包装对象&lt;/p&gt;
&lt;h2 id=&quot;线程控制-Scheduler&quot;&gt;&lt;a href=&quot;#线程控制-Scheduler&quot; class=&quot;headerlink&quot; title=&quot;线程控制 - Scheduler&quot;&gt;&lt;/a&gt;线程控制 - Scheduler&lt;/h2&gt;&lt;p&gt;在不指定线程的情况下, RxJava遵循的是线程不变的原则, 即: &lt;/p&gt;
&lt;p&gt;在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如需切换线程，就需要Scheduler(调度器)&lt;/p&gt;
&lt;h4 id=&quot;1）-Scheduler-API&quot;&gt;&lt;a href=&quot;#1）-Scheduler-API&quot; class=&quot;headerlink&quot; title=&quot;1） Scheduler API&quot;&gt;&lt;/a&gt;1） Scheduler API&lt;/h4&gt;&lt;p&gt;Scheduler － 调度器，相当于线程控制器，RxJava通过它来指定每一段代码应该运行在哪一个线程中。RxJava内置了一些Scheduler，适用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Schedulers.immediate(): 直接在当前线程中运行，默认的Scheduler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.newThread(): 总是启用新线程,并在新线程中执行操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.io: I/O操作(读写文件、读写数据库、网络信息交互等)所使用的Scheduler；类似于newThread()，区别在io()的内部实现是使用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。记住：不要把计算放在io()中，可以避免创建不必要的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Schedulers.computation(): 计算Scheduler。这个计算指CPU密集型计算，即不会被I/O等操作限制性能的操作，比如图形的计算。该Scheduler使用固定的线程池，大小为CPU核数。切记，不要把I/O操作放在computation()中,否则I/O操作的等待时间会浪费CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外Android还有一个专用的AndroidSchedulers.mainThread()，它指定的操作将在Android主线程中运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了上述Scheduler，就可以使用subscribeOn() 和 observerOn() 来控制线程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;subscribeOn(): 指定subscribe()所发生的线程，即Observable.OnSubscribe 被激活时所在的线程/事件产生的线程。

observeOn(): 指定Subscriber所运行的线程/事件消费的线程。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Observable.just(1,2,3,4)
    .subscribeOn(Schedulers.io()) // 指定 subscribe()发生在 IO 线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定Scheduler 的回调发生在主线程中
    .subscribe(new Action1&amp;lt;Integer&amp;gt;(){
        @override
        public void call(Integer number){
            //todo
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种在subscribe()之前写上线程控制的多适用于 『后台线程取数据，主线程显示』的程序策略。&lt;/p&gt;
&lt;h4 id=&quot;2-Scheduler-原理&quot;&gt;&lt;a href=&quot;#2-Scheduler-原理&quot; class=&quot;headerlink&quot; title=&quot;2) Scheduler 原理&quot;&gt;&lt;/a&gt;2) Scheduler 原理&lt;/h4&gt;&lt;h1 id=&quot;TBD&quot;&gt;&lt;a href=&quot;#TBD&quot; class=&quot;headerlink&quot; title=&quot;TBD&quot;&gt;&lt;/a&gt;TBD&lt;/h1&gt;&lt;h2 id=&quot;变换&quot;&gt;&lt;a href=&quot;#变换&quot; class=&quot;headerlink&quot; title=&quot;变换&quot;&gt;&lt;/a&gt;变换&lt;/h2&gt;&lt;p&gt;RxJava提供了对事件序列进行变换的支持&lt;/p&gt;
&lt;p&gt;所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。&lt;/p&gt;
&lt;h4 id=&quot;（1）API&quot;&gt;&lt;a href=&quot;#（1）API&quot; class=&quot;headerlink&quot; title=&quot;（1）API&quot;&gt;&lt;/a&gt;（1）API&lt;/h4&gt;&lt;p&gt;首先看map()示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Observable.just(&amp;quot;image/ic_launcher.png&amp;quot;) // 输入类型 String
    .map(new Func1&amp;lt;String, Bitmap&amp;gt;(){
        @override
        public Bitmap call(String filePath){ // 参数类型 Strting
            return getBitmapFromPath(filePath); // 返回类型
        }
    })
    .subscribe(new Action1&amp;lt;Bitmap&amp;gt;(){
        @override
        public void call(Bitmap bitmap){ // 参数类型 Bitmap
            showBitmap(bitmap);
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注-1&quot;&gt;&lt;a href=&quot;#注-1&quot; class=&quot;headerlink&quot; title=&quot;注&quot;&gt;&lt;/a&gt;注&lt;/h3&gt;&lt;p&gt;类Func1，也是RxJava的一个接口，用于包装含有一个参数的方法。&lt;/p&gt;
&lt;p&gt;FuncX 和 ActionX 区别，FuncX包装的是有返回值的方法&lt;/p&gt;
&lt;h3 id=&quot;常用变换&quot;&gt;&lt;a href=&quot;#常用变换&quot; class=&quot;headerlink&quot; title=&quot;#常用变换&quot;&gt;&lt;/a&gt;#常用变换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;map() —————– 事件对象的直接变换，是RxJava最为常用的变换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flatMap()————– 事件对象的扁平变换，是map()的升级版&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解释: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将Observable发射的数据变换为Observables集合,然后将Observab发射的数据 『铺平化』放进一个单独的Observable中。 可以理解为将嵌套的数据结构展开的过程。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map() 和 flatMap() 区别:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;相同: 均可以把传入的参数转化之后返回另一个对象

不同: flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到Subscriber的回调方法中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flatMap() 原理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、 利用传入的事件对象创建一个Observable对象

2、 不发送这个Observable对象，而是将其激活，再开始发送事件

3、 每一个创建出来的Observable发送的事件，都被汇总到同一个Observable，再由这个汇总Observable对象负责将这些事件统一交给Subscriber的回调方法
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个步骤,其实是将事件拆成了两级,通过一组新创建Observable将初始的对象『铺平』之后，通过统一的路径分发下去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;throttleFirst() ——– 在每次事件触发之后的一定时间间隔内丢弃新的事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用作去抖动过滤，例如按钮的点击监听器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RxView.clickEvents(button) 
    .throttleFirst(500, TimeUnitMILLISECONDS)  //设置防抖间隔 500ms
    .subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以解决手抖出现点开两个重复的界面问题&lt;/p&gt;
&lt;h4 id=&quot;（2）变换的原理-lift&quot;&gt;&lt;a href=&quot;#（2）变换的原理-lift&quot; class=&quot;headerlink&quot; title=&quot;（2）变换的原理: lift()&quot;&gt;&lt;/a&gt;（2）变换的原理: lift()&lt;/h4&gt;&lt;p&gt;变换的实质： 针对事件序列的处理和再发送&lt;/p&gt;
&lt;p&gt;lift() 内部实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public &amp;lt;R&amp;gt; Observable&amp;lt;R&amp;gt; lift(Operator&amp;lt;? extends R, ? super T&amp;gt; operator){
    return Observable.create(new OnSubscribe&amp;lt;R&amp;gt;(){
        @override
        public void call(Subscriber subscriber){
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;生成一个新的Observable并返回，且新创建的Observable所用的参数OnSubscribe的回调方法call()中的onSubscribe.call(subscribe)中的onSubscribe所指代的对象不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;subscribe()中onSubscribe指的是Observable中的onSubscribe对象,但是lift()之后对象就不一样;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当含有lift()时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. lift()创建了一个Observable后，加上原Observable对象，就有两个Observable；
2. 新Observable里的新OnSubscribe加上原Observable中的OnSubscribe，也就有两个OnSubscribe;
3. 当用户调用经过lift()后的Observable的subscribe()时候,使用的是lift()所返回的新的Observable,
   于是它所触发的onSubscribe.call(subscribe)，也是用的新Observable中的OnSubscribe，即在lift()中生成的那个Observable;
4. 而这个新OnSubscribe的call()方法中的onSubscribe，就是指的原始Observable中的原始OnSubscribe，
   在这个call()方法里，新OnSubscribe利用operator.call(subscribe)生成一个新的Subscriber
   (operator就是在这里，通过自己的call()方法将新Subscribe和原始Subscriber进行关联，并插入自己的『变换』代码来实现变换)，
   接着利用这个新Subscriber向原始Observable进行订阅。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就实现lift()过程，比较像代理机制，通过事件拦截和处理实现事件序列的变换。&lt;/p&gt;
&lt;p&gt;换种方式理解： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在Observable执行了lift(Operator)方法之后，会返回一个新的Observable，
这个新的Observable会向代理一样， 负责接收原始的Observable发出的事件，并在处理之后发送给Subscriber。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##未完待续。。。&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=94639&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RxJava&quot;&gt;&lt;a href=&quot;#RxJava&quot; class=&quot;headerlink&quot; title=&quot;RxJava&quot;&gt;&lt;/a&gt;RxJava&lt;/h1&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;a library for composing asynchronous and event-based programs using observable sequences for the Java VM&lt;/p&gt;
&lt;p&gt;一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android部落格之Retrofit框架</title>
    <link href="http://tufusi.com/2016/06/02/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BRetrofit%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/02/Android部落格之Retrofit框架/</id>
    <published>2016-06-02T01:23:58.000Z</published>
    <updated>2016-06-02T01:23:58.913Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android部落格之OkHttp框架</title>
    <link href="http://tufusi.com/2016/06/01/Android%E9%83%A8%E8%90%BD%E6%A0%BC%E4%B9%8BOkHttp%E6%A1%86%E6%9E%B6/"/>
    <id>http://tufusi.com/2016/06/01/Android部落格之OkHttp框架/</id>
    <published>2016-06-01T02:20:47.000Z</published>
    <updated>2016-08-07T07:07:51.001Z</updated>
    
    <content type="html">&lt;h4 id=&quot;OkHttp的轮子&quot;&gt;&lt;a href=&quot;#OkHttp的轮子&quot; class=&quot;headerlink&quot; title=&quot;OkHttp的轮子&quot;&gt;&lt;/a&gt;OkHttp的轮子&lt;/h4&gt;&lt;p&gt;来自&lt;a href=&quot;http://square.github.io/okhttp/#examples&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OkHttp官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.piasy.com/img/201607/okhttp_full_process.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;整体流程图-参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官网概述：Android和Java应用程序的HTTP&amp;amp;HTTP/2的客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h3&gt;&lt;h4 id=&quot;1、创建OkHttpClint对象&quot;&gt;&lt;a href=&quot;#1、创建OkHttpClint对象&quot; class=&quot;headerlink&quot; title=&quot;1、创建OkHttpClint对象&quot;&gt;&lt;/a&gt;1、创建OkHttpClint对象&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;OkHttpClient client = new OkHttpClient();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然也可以通过Build构造自定义的Http客户端&lt;/p&gt;
&lt;h4 id=&quot;2、发起HTTP请求&quot;&gt;&lt;a href=&quot;#2、发起HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;2、发起HTTP请求&quot;&gt;&lt;/a&gt;2、发起HTTP请求&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;String run() throws IOException{
    Request request = new Request.Builder()
      .url(url)
       .build(); 

    Response response = client.newCall(request).execute();
    return response.body().string();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OkHttpClient实现了Call.Factory, 它是负责创建HTTP请求,负责根据请求创建新的Call,代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Prepares the {@code request} to be executed at some point in the future.
 */
@override
public Call newCall(Request request){
    return new RealCall(this,request);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面针对RealCall,分情况研究:&lt;/p&gt;
&lt;h5 id=&quot;2-1-同步网络请求&quot;&gt;&lt;a href=&quot;#2-1-同步网络请求&quot; class=&quot;headerlink&quot; title=&quot;2.1 同步网络请求&quot;&gt;&lt;/a&gt;2.1 同步网络请求&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;@override
public Response execute() throws IOException{
    synchronized(this){
        if(executed) -------------------------------------------------------------(1)
            throws new IllegalStateException(&amp;quot;Already Exceuted&amp;quot;); 
        executed = true;
    }
    try{
        client.dispatcher().exedcuted(this); -------------------------------------(2)
        Response result = getResponseWithInterceptorChain(); ---------------------(3)
        if(result == null)
            throws new IOException(&amp;quot;Canceled&amp;quot;);
        return result;
    }finally{
        client.dispatcher().finished(this); --------------------------------------(4)
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;步骤分解:&lt;/p&gt;
&lt;p&gt;(1): 检查这个call是否已经执行过，每个call只能被执行一次&lt;/p&gt;
&lt;p&gt;(2): 利用client.dispatcher().executed(this)来实际执行请求&lt;/p&gt;
&lt;p&gt;(3): 调用函数获取HTTP响应结果,在这个过程中还会进行一个拦截链操作&lt;/p&gt;
&lt;p&gt;(4): 通知dispatcher执行完毕&lt;/p&gt;
&lt;p&gt;而真正发出网络请求,解析返回结果的,还是getResponseWithInterceptorChain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Response getResponseWithInterceptorChain() throws IOException{
    //Build a full stack of interceptors
    List&amp;lt;Interceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if(!retryAndFollowUpInterceptor.isForWebSocket()){
        interceptors.addAll(client.networkInterceptors());
    }

    interceptors.add(
        new CallServerInterceptor(
            retryAndFollowUpInterceptor.isForWebSocket()));
    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors,null,null,null,0,originalRequest);

    return chain.proceed(originalRequest);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Interceptor其实是最核心的一个东西,并非简简单单的拦截器,它把实际的网络请求、缓存等等功能全部统一起来，每个功能都只是一个Interceptor,再连接成一个Interceptor.Chain,最终完成一次圆满的网络请求.&lt;/p&gt;
&lt;p&gt;依照上面代码块,Interceptor.Chain的分布:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;blog.piasy.com/img/201607/okhttp_interceptors.png&quot;&gt;结构图&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.在配置OkHttpClient时设置的interceptors;

2.负责失败重试以及重定向的RetryAndFollowUpInterceptor;

3.负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的BridgeInterceptor;

4.负责人读取缓存直接返回、更新缓存的CacheInterceptor;

5.负责和服务器建立连接的ConnectInterceptor;

6.配置OkHttpClient时设置的networkInterceptors;

7.负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里位置决定功能，最后一个Interceptor一定是负责和服务器实现通信的，而重定向、缓存等一定是在通信之前完成。&lt;/p&gt;
&lt;h6 id=&quot;2-1-1-建立连接-ConnectInterceptor&quot;&gt;&lt;a href=&quot;#2-1-1-建立连接-ConnectInterceptor&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 建立连接:ConnectInterceptor&quot;&gt;&lt;/a&gt;2.1.1 建立连接:ConnectInterceptor&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;@override
public Response intercept(Chain chain) throws IOException{
    RealInterceptorChain realChain = (RealInterceptorChain)chain;
    Request request  = realChain.request();
    StreamAllocation streamAllocation = realChain.streamAllocation();

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    boolean doExtensiveHealthChecks = !request.method().equals(&amp;quot;GET&amp;quot;);
    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
    RealConnection connection = streamAllocation.connection();

    return realChain.proceed(request, streamAllocation, httpCodec, connection);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建立连接其实就是创建HttpCodec对象,HttpCodec是对HTTP协议操作的抽象,在HttpCodec中,它利用Okio对socket的读写操作进行封装.&lt;/p&gt;
&lt;h6 id=&quot;2-1-2-发送和接收数据-CallServerInterceptor&quot;&gt;&lt;a href=&quot;#2-1-2-发送和接收数据-CallServerInterceptor&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 发送和接收数据:CallServerInterceptor&quot;&gt;&lt;/a&gt;2.1.2 发送和接收数据:CallServerInterceptor&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;@override
public Response intercept(Chain chain) throws IOException{
    HttpCodec httpCodex = ((RealInterceptorChain)chain).httpStream();
    StreamAllocation streamAllocation = ((RealInterceptorChain)chain).streamAllocation();
    Request request = chain.request();

    long sentRequestMillis = System.currentTimeMillis();
    httpCodec.writeRequestHeaders(request); ----------------------------------------------------------(1)

    if(HttpMethod.permitsRequestBody(request.method()) &amp;amp;&amp;amp; request.body()!=null){ ---------------------(2)
        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
        request.body().writeTo(bufferedRequestBody);
        bufferedRequestBody.close();
    }

    httpCodec.finishRequest();

    Response response = httpCodec.readResponseHeaders() ----------------------------------------------(3)
          .request(request)
          .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();

    if (!forWebSocket || response.code() != 101) {
        response = response.newBuilder() -------------------------------------------------------------(4)
            .body(httpCodec.openResponseBody(response))
            .build();
    }

    if (&amp;quot;close&amp;quot;.equalsIgnoreCase(response.request().header(&amp;quot;Connection&amp;quot;))
          || &amp;quot;close&amp;quot;.equalsIgnoreCase(response.header(&amp;quot;Connection&amp;quot;))) {
        streamAllocation.noNewStreams();
    }

    // 省略部分检查代码

    return response;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要部分:&lt;/p&gt;
&lt;p&gt;1.向服务器发送request header;&lt;/p&gt;
&lt;p&gt;2.如果有request body，就向服务器发送;&lt;/p&gt;
&lt;p&gt;3.读取response header，先构造一个Response对象;&lt;/p&gt;
&lt;p&gt;4.如果有response body,就在3的基础上加上body构造一个新的Response对象&lt;/p&gt;
&lt;h5 id=&quot;2-2-异步网络请求-详见Dispatcher-java&quot;&gt;&lt;a href=&quot;#2-2-异步网络请求-详见Dispatcher-java&quot; class=&quot;headerlink&quot; title=&quot;2.2 异步网络请求 - 详见Dispatcher.java&quot;&gt;&lt;/a&gt;2.2 异步网络请求 - 详见Dispatcher.java&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;client.newCall(request).enqueue(new Callback(){
    @override
    public void onFailure(Call call, IOException e){
    }

    @override
    public void onResponse(Call call, Response response) throws IOException{
        System.out.println(response.body().string());
    }
});

//RealCall#enqueue
@override
public void enqueue(Callback responseCallback){
    synchronized(this){
        if(executed) throws new IllegalStateException(&amp;quot;Already Executed&amp;quot;);
        executed = true;
    }
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
}

//Dispatcher#enqueue
synchronized void enqueue(AsyncCall call){
    if(runningAsyncCalls.size()&amp;lt;maxRequests &amp;amp;&amp;amp;　runningCallForHost(call)&amp;lt;maxRequestsPerHost){
        runningAsyncCalls.add(call);
        executorService().execute(call);
    }else{
        readyAsyncCalls.add(call);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此处可以看到dispatcher在异步执行请求过程中的作用.如果当前还能执行一个并发请求,那就立即执行,否则就加入readyAsyncCalls队列,而正在执行的请求执行完毕之后,会调用promoteCalls()函数,来迭代readyAsyncCalls队列,next()出AsyncCall,并将AsyncCall加入到runningAsyncCalls队列中,开始执行.&lt;/p&gt;
&lt;p&gt;AsyncCall是RealCall的一个innerClass,继承NamedRunnable抽象类,该抽象类实现了Runnable接口,功能是设置线程名称.所以AsyncCall其实就是被OkHttp命名规范的一个异步请求类,它可以被提交到ExecutorService上执行,在执行时会调用getResponseWithInterceptorChain()函数,并将结果通过responseCallback回调传递给上层使用.&lt;/p&gt;
&lt;p&gt;如此,同步和异步其实原理是一样的,都是在getResponseWithInterceptorChain()函数中通过Interceptor链来实现网络请求逻辑,而异步则是通过ExecutorService来实现的.&lt;/p&gt;
&lt;h4 id=&quot;3、获取响应数据&quot;&gt;&lt;a href=&quot;#3、获取响应数据&quot; class=&quot;headerlink&quot; title=&quot;3、获取响应数据&quot;&gt;&lt;/a&gt;3、获取响应数据&lt;/h4&gt;&lt;p&gt;在同步(Call#execute()执行之后)或者异步(Callback#onResponse()回调中)请求完成之后,可以从Respouse对象中华获取到响应数据,包括HTTP status code, status message, response header, response body等等.这里的body需通过数据流方式来进行访问。&lt;/p&gt;
&lt;p&gt;响应body被封装到 ResponseBody类中,需注意亮点:&lt;/p&gt;
&lt;p&gt;1) 每个body只能被消费一次,多次消费会抛出异常;&lt;/p&gt;
&lt;p&gt;2) body必须被关闭,否则会发生资源泄漏&lt;/p&gt;
&lt;h4 id=&quot;4、HTTP缓存&quot;&gt;&lt;a href=&quot;#4、HTTP缓存&quot; class=&quot;headerlink&quot; title=&quot;4、HTTP缓存&quot;&gt;&lt;/a&gt;4、HTTP缓存&lt;/h4&gt;&lt;p&gt;在建立连接、和服务器通信之前，就是CacheInterceptor,在建立连接之前,我们检查响应是否已经被缓存、缓存是否可用，如果是则直接返回缓存的数据，否则就进行后面的流程，并在返回之前，把网络的数据写入缓存中。&lt;/p&gt;
&lt;p&gt;CacheInterceptor类里主要逻辑都在覆写的intercept方法里,通过缓存策略获取networkRequest和cacheResponse进行检查判断,也可以通过实现InternalCache接口,在构造OkHttpClient时进行设置,这样就可以自定义缓存策略了。&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=28188171&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OkHttp的轮子&quot;&gt;&lt;a href=&quot;#OkHttp的轮子&quot; class=&quot;headerlink&quot; title=&quot;OkHttp的轮子&quot;&gt;&lt;/a&gt;OkHttp的轮子&lt;/h4&gt;&lt;p&gt;来自&lt;a href=&quot;http://square.github.io/okhttp/#examples&quot;&gt;OkHttp官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.piasy.com/img/201607/okhttp_full_process.png&quot;&gt;整体流程图-参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官网概述：Android和Java应用程序的HTTP&amp;amp;HTTP/2的客户端&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTTP Client" scheme="http://tufusi.com/categories/HTTP-Client/"/>
    
    
      <category term="技术" scheme="http://tufusi.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络通信" scheme="http://tufusi.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>十里平湖霜满天</title>
    <link href="http://tufusi.com/2016/05/31/%E5%8D%81%E9%87%8C%E5%B9%B3%E6%B9%96%E9%9C%9C%E6%BB%A1%E5%A4%A9/"/>
    <id>http://tufusi.com/2016/05/31/十里平湖霜满天/</id>
    <published>2016-05-31T09:27:09.000Z</published>
    <updated>2016-05-31T09:28:15.759Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="闲心 品读 人生" scheme="http://tufusi.com/tags/%E9%97%B2%E5%BF%83-%E5%93%81%E8%AF%BB-%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
